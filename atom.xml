<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A1ent</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-02T14:35:02.987Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>A1ent</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>优秀的文章</title>
    <link href="http://example.com/2023/02/02/%E4%BC%98%E7%A7%80%E7%9A%84%E6%96%87%E7%AB%A0/"/>
    <id>http://example.com/2023/02/02/%E4%BC%98%E7%A7%80%E7%9A%84%E6%96%87%E7%AB%A0/</id>
    <published>2023-02-02T14:31:52.000Z</published>
    <updated>2023-02-02T14:35:02.987Z</updated>
    
    <content type="html"><![CDATA[<p>Unity 3D中的内存管理<a class="link"   href="https://onevcat.com/2012/11/memory-in-unity3d/" >https://onevcat.com/2012/11/memory-in-unity3d/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>Unity热更新全书 <a class="link"   href="https://www.cnblogs.com/crazylights/p/3897742.html" >https://www.cnblogs.com/crazylights/p/3897742.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>知乎一个很不错的帖子 <a class="link"   href="https://zhuanlan.zhihu.com/p/29383687" >https://zhuanlan.zhihu.com/p/29383687 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><p>[教程汇总+持续更新]Unity从入门到入坟——收藏这一篇就够了 <a class="link"   href="https://zhuanlan.zhihu.com/p/151238164" >https://zhuanlan.zhihu.com/p/151238164 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Unity 3D中的内存管理&lt;a class=&quot;link&quot;   href=&quot;https://onevcat.com/2012/11/memory-in-unity3d/&quot; &gt;https://onevcat.com/2012/11/memory-in-unity3d/ &lt;i </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>策略游戏开发</title>
    <link href="http://example.com/2023/02/01/%E5%9B%9E%E5%90%88%E7%AD%96%E7%95%A5%E6%B8%B8%E6%88%8F/%E7%AD%96%E7%95%A5%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2023/02/01/%E5%9B%9E%E5%90%88%E7%AD%96%E7%95%A5%E6%B8%B8%E6%88%8F/%E7%AD%96%E7%95%A5%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</id>
    <published>2023-02-01T06:48:26.000Z</published>
    <updated>2023-02-03T01:30:13.359Z</updated>
    
    <content type="html"><![CDATA[<p>[Toc]</p><h1 id="Part1-后期处理（这一些效果挺不错的，值得自己去尝试一下）"><a href="#Part1-后期处理（这一些效果挺不错的，值得自己去尝试一下）" class="headerlink" title="Part1.后期处理（这一些效果挺不错的，值得自己去尝试一下）"></a>Part1.后期处理（这一些效果挺不错的，值得自己去尝试一下）</h1><p> 1.1 在Global Volume 的Volume里面 new 一个  Profile</p><p>选择 Add   Override  ， 添加 色调映射 (Tonemapping)：色调映射是将图像的 HDR 值重新映射到适合在屏幕上显示的范围内的过程。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230201150057497.png"                      alt="image-20230201150057497"                ></p><p>设置为None时：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230201150503644.png"                      alt="image-20230201150503644"                ></p><p>设置为Neutral时：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230201150533568.png"                      alt="image-20230201150533568"                ></p><p>设置为ACES时：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230201150551514.png"                      alt="image-20230201150551514"                ></p><p>Directional Light 的设置：（改不改变化不大）</p><p>主要看个人喜欢</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230201151155737.png"                      alt="image-20230201151155737"                ></p><p>再回到Gobal Volume：</p><p>Add Override, 添加一个Bloom的组件：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230201151459513.png"                      alt="image-20230201151459513"                ></p><p>该组件的作用是泛光，效果如下：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230201151446529.png"                      alt="image-20230201151446529"                ></p><p>更多详情：<a class="link"   href="https://docs.unity.cn/cn/2021.1/Manual/PostProcessingOverview.html" >https://docs.unity.cn/cn/2021.1/Manual/PostProcessingOverview.html <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><img                       lazyload                     src="/images/loading.svg"                     data-src="image-20230201152018680.png"                      alt="image-20230201152018680" style="zoom:80%;"                 ><p>后面的爆炸效果会用到 HDR，请确保它是打开的状态</p><img                       lazyload                     src="/images/loading.svg"                     data-src="image-20230201152212885.png"                      alt="image-20230201152212885" style="zoom:67%;"                 ><p>注意摄像机的 后期处理（post Processing）</p><img                       lazyload                     src="/images/loading.svg"                     data-src="image-20230201152315361.png"                      alt="image-20230201152315361" style="zoom:50%;"                 ><p>否则之前的设置将看不见。</p><p>再添加一个Vignette 的效果</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230201152538294.png"                      alt="image-20230201152538294"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230201152547068.png"                      alt="image-20230201152547068"                ></p><p>设置SSAO：（可以让角色看起来更加真实，增加一些阴影部分）</p><img                       lazyload                     src="/images/loading.svg"                     data-src="image-20230201153134238.png"                      alt="image-20230201153134238" style="zoom:67%;"                 ><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230201153215539.png"                      alt="image-20230201153215539"                ></p><h1 id="Part2-单元运动与选择"><a href="#Part2-单元运动与选择" class="headerlink" title="Part2.单元运动与选择"></a>Part2.单元运动与选择</h1><h2 id="1-选择Pivot-而不是Center-："><a href="#1-选择Pivot-而不是Center-：" class="headerlink" title="1.选择Pivot 而不是Center ："></a>1.选择Pivot 而不是Center ：</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230201155107306.png"                      alt="image-20230201155107306"                ></p><h2 id="2-单位移动"><a href="#2-单位移动" class="headerlink" title="2.单位移动"></a>2.单位移动</h2><p>移动到指定的地点</p><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">6.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Vector3 targetPosition;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//停止的距离， 防止在移动到目的地时，发生抖动；</span></span><br><span class="line">        <span class="built_in">float</span> stopDistance = <span class="number">.1</span>f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里不使用 Distance 是 为了减少开销，提高性能；</span></span><br><span class="line">        <span class="comment">// Vector3.Distance(transform.position - targetPosition);</span></span><br><span class="line">        <span class="keyword">if</span> ((transform.position - targetPosition).sqrMagnitude &gt; stopDistance * stopDistance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//移动方向 = 目标位置 - 原来位置 ，然后归一化；</span></span><br><span class="line">            Vector3 moveDirection = (targetPosition - transform.position).normalized;</span><br><span class="line"></span><br><span class="line">            transform.position += moveDirection * moveSpeed * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Input.GetKeyDown(KeyCode.J))</span><br><span class="line">            &#123;</span><br><span class="line">                Move(<span class="keyword">new</span> Vector3(<span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>(<span class="params">Vector3 targetPosition</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.targetPosition = targetPosition;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><h2 id="3-鼠标射线"><a href="#3-鼠标射线" class="headerlink" title="3.鼠标射线"></a>3.鼠标射线</h2><p>通过射线来判断鼠标是否在屏幕上</p><p>Camera.main 其实等于：</p><p>GameObject.FindTagWith(“MainCamera”); &#x2F;&#x2F;而这也是比较消耗性能的</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230201204732044.png"                      alt="image-20230201204732044"                ></p><p>ScreenPointToRay：返回从摄像机通过屏幕点的光线。</p><p>产生的光线位于世界空间中，从摄像机的近平面开始，并通过屏幕上 位置的 (x,y) 像素坐标（忽略 position.z）。</p><p>屏幕空间以像素定义。屏幕的左下角为 (0,0)，右上角为 (<a class="link"   href="https://docs.unity.cn/cn/2021.3/ScriptReference/Camera-pixelWidth.html" >pixelWidth <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> -1,<a class="link"   href="https://docs.unity.cn/cn/2021.3/ScriptReference/Camera-pixelHeight.html" >pixelHeight <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> -1)。</p><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line"></span><br><span class="line">Debug.Log(ray);</span><br></pre></td></tr></table></figure></div><h2 id="4-鼠标世界坐标"><a href="#4-鼠标世界坐标" class="headerlink" title="4.鼠标世界坐标"></a>4.鼠标世界坐标</h2><p>添加一个图层属性，用来表示想要鼠标点到地面的图层</p><p>先设置一个图层，call： Ground</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230201210441875.png"                      alt="image-20230201210441875"                ></p><p>out 关键字 其实就是帮我们创建了一个变量，来保存要击中目标的信息。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230201210616701.png"                      alt="image-20230201210616701"                ></p><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MouseWorld</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> MouseWorld instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//this 关键字指代类的当前实例</span></span><br><span class="line">        instance = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试用</span></span><br><span class="line">    <span class="comment">// private void Update()</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     transform.position = GetMousePosition();</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取鼠标点击地面的图层</span></span><br><span class="line">    [<span class="meta">SerializeField</span>]</span><br><span class="line">    LayerMask mousePlaneLayerMask;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类的实例不能访问类的静态方法，因为静态方法本身就是一个实例了，不需要再次实例，直接访问即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Vector3 <span class="title">GetMousePosition</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//射线检测鼠标位置</span></span><br><span class="line">        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">        <span class="comment">// Debug.Log(Physics.Raycast(ray));</span></span><br><span class="line"></span><br><span class="line">        Physics.Raycast(ray, <span class="keyword">out</span> RaycastHit hit, <span class="built_in">float</span>.MaxValue, instance.mousePlaneLayerMask);</span><br><span class="line">        <span class="keyword">return</span> hit.point;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="5-通过鼠标点击来进行移动"><a href="#5-通过鼠标点击来进行移动" class="headerlink" title="5.通过鼠标点击来进行移动"></a>5.通过鼠标点击来进行移动</h2><p>这个其实比较简单 ，只要判断是否按下鼠标左键，按下则调用GetPosition()</p><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果按下鼠标左键，则移动到该点</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Move(MouseWorld.GetMousePosition());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h2 id="6-public-与-SerializeField-private"><a href="#6-public-与-SerializeField-private" class="headerlink" title="6.public 与[SerializeField] private"></a>6.public 与[SerializeField] private</h2><h3 id="为什么要使用有时候不使用public-而使用-SerializeField-private-？"><a href="#为什么要使用有时候不使用public-而使用-SerializeField-private-？" class="headerlink" title="为什么要使用有时候不使用public 而使用 [SerializeField] private ？"></a>为什么要使用有时候不使用public 而使用 [SerializeField] private ？</h3><p>有时候我们会去修改一些东西，或者去用UI表示一些信息， 任何的了，任何的代码都可以去基于这个去做更多的功能 和 修改这个字段 。 </p><p>但在更复杂的游戏中，干净的代码十分主要，而干净的代码的主要方法是最小化复杂度。最小化复杂性的一个更好的方法就是尽可能的减少访问。</p><p>随着游戏的制作， 他们的任意一个都可以对这个属性进行读取，修改和操作，最终只会变得越来越复杂，而我们要记住的东西就要变多。</p><p>干净的代码十分的重要。</p><h2 id="7-设置动画"><a href="#7-设置动画" class="headerlink" title="7.设置动画"></a>7.设置动画</h2><p>角色动画到 Mixamo   <a class="link"   href="https://www.mixamo.com/#/" >https://www.mixamo.com/#/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 里面下载 ， 下载 slim shooter</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202093550042.png"                      alt="image-20230202093550042"                ></p><p>将动画导入Unity 后，将他们的Rig ，Animation Type 改为 Humanoid（人类），点击应用。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202093642272.png"                      alt="image-20230202093642272"                ></p><p>然后选择 Animation ，这个可以修改我们的动画的名称</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202093830380.png"                      alt="image-20230202093830380"                ></p><p>在 如果是循环的动画，记得勾选 looptime</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202093915593.png"                      alt="image-20230202093915593"                ></p><p>，我们可以通过更改 Root Transform Rotation 来更改自己想要的方向</p><p>Body Orientation，身体定向,可以看出他拿枪的方向并不是我们想要的，</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202094216385.png"                      alt="image-20230202094216385"                ></p><p>这时候我们就可以设置为Original</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202094259063.png"                      alt="image-20230202094259063"                ></p><h2 id="8-动画控制器"><a href="#8-动画控制器" class="headerlink" title="8.动画控制器"></a>8.动画控制器</h2><p>新建一个动画控制器 AnimationController ，</p><p>我们可以选择 Set as Layer Defalt State ，来设置初始动画</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202095207331.png"                      alt="image-20230202095207331"                ></p><p>当我们设置为Run 时</p><p>角色会向前跑动，那是因为我们勾选了Apply Root Motion 根运动，</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202095551351.png"                      alt="image-20230202095551351"                ></p><p>我们选择一个箭头：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202100201369.png"                      alt="image-20230202100201369"                ></p><h3 id="动画过渡"><a href="#动画过渡" class="headerlink" title="动画过渡"></a>动画过渡</h3><p>动画过渡允许<a class="link"   href="https://docs.unity.cn/cn/2022.1/Manual/StateMachineBasics.html" >状态机 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>从一个动画状态切换或混合到另一动画状态。过渡不仅定义状态之间的混合应该耗费多长时间，而且还定义它们应该在什么条件下激活。您可以设置仅在特定条件成立时才发生过渡。要设置这些条件，请在 Animator Controller 中指定参数值。</p><p>例如，您的角色可能具有“巡逻”状态和“睡眠”状态。您可以将巡逻和睡眠之间的过渡设置为仅在“alertness”参数值低于某个水平时才会发生。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/classTransitionAnimatorPreview.jpg"                      alt="在 Inspector中查看过渡的示例。"                >在 Inspector中查看过渡的示例。</p><p>要为过渡命名，请在字段中输入名称，如下所示：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/AnimatorTransitionName.png"                      alt="img"                ></p><p>状态的 Inspector 窗口会显示该状态使用的过渡，如下所示：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/AnimatorTransitionNameInState.png"                      alt="img"                ></p><p>在任何给定时间只能有一个激活的过渡。但是，当前激活的过渡可能会被另一个过渡中断（如果已将设置配置为允许此行为，请参阅以下的<a class="link"   href="https://docs.unity.cn/cn/2022.1/Manual/class-Transition.html#TransitionInterruption" >过渡中断 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）。</p><h3 id="过渡属性"><a href="#过渡属性" class="headerlink" title="过渡属性"></a>过渡属性</h3><p>要查看某个过渡的属性，请单击 Animator 窗口中连接两个状态的过渡线。这些属性将显示在 Inspector 窗口中。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/class-Transition-Properties.png"                      alt="img"                ></p><p>使用以下属性可调整过渡及其在当前状态和下一状态之间如何混合。</p><table><thead><tr><th align="left"><strong>属性</strong></th><th align="left"><strong>功能</strong></th></tr></thead><tbody><tr><td align="left"><strong>Has Exit Time</strong></td><td align="left"><strong>Exit Time</strong> 是一种不依赖参数的特殊过渡。但是，它依赖状态的标准化时间。选中此选项可在 <strong>Exit Time</strong> 指定的具体时间进行过渡。</td></tr><tr><td align="left"><strong>Settings</strong></td><td align="left">包含详细过渡设置的折叠菜单（如下所示）。</td></tr><tr><td align="left"><strong>Exit Time</strong></td><td align="left">如果选中 <strong>Has Exit Time__，此值表示过渡可以生效的确切时间。该时间以标准化时间表示（例如，退出时间为 0.75 表示，在已播放 75% 动画的第一帧上，__Exit Time</strong> 条件为 true）。在下一帧上，该条件为 false。  对于循环动画，每个循环都会评估退出时间小于 1 的过渡，因此可使用此选项在每个循环的动画中以适当时机对过渡进行计时。  对 <strong>Exit Time</strong> 大于 1 的过渡仅评估一次，因此此类过渡可用于在固定循环次数后的特定时间退出。例如，过渡的退出时间为 3.5 的情况下，在三个半循环后对该过渡评估一次。</td></tr><tr><td align="left"><strong>Fixed Duration</strong></td><td align="left">如果选中 <strong>Fixed Duration</strong> 复选框，则以秒为单位解读过渡时间。如果未选中 <strong>Fixed Duration</strong> 复选框，则过渡时间解读为源状态的标准化时间的一部分。</td></tr><tr><td align="left"><strong>Transition Duration</strong></td><td align="left">相对于当前状态持续时间的过渡持续时间，以标准化时间或秒为单位（具体取决于 <strong>Fixed Duration</strong> 模式）。此时间在过渡图中显示为两个蓝色标记之间的部分。</td></tr><tr><td align="left"><strong>Transition Offset</strong></td><td align="left">过渡到的目标状态的起始播放的时间偏移。例如，值为 0.5 表示目标状态在其时间轴的 50% 处开始播放。</td></tr><tr><td align="left"><strong>Interruption Source</strong></td><td align="left">此选项用于控制该过渡可能中断的情况（请参阅下文的<a class="link"   href="https://docs.unity.cn/cn/2022.1/Manual/class-Transition.html#TransitionInterruption" >过渡中断 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）。</td></tr><tr><td align="left"><strong>Ordered Interruption</strong></td><td align="left">确定当前过渡是否可在不考虑顺序的情况下被其他过渡中断（请参阅下文的<a class="link"   href="https://docs.unity.cn/cn/2022.1/Manual/class-Transition.html#TransitionInterruption" >过渡中断 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）。</td></tr><tr><td align="left"><strong>Conditions</strong></td><td align="left">一个过渡可以具有单个条件、多个条件或根本没有条件。如果过渡没有条件，Unity Editor 只会考虑 <strong>Exit Time__，并在达到退出时间时发生过渡。如果过渡有一个或多个条件，则必须满足所有条件才能触发过渡。  一个条件包含：  - 一个事件参数（在条件中考虑其值）。 - 条件谓词（需要时填写，例如，浮点数的“小于”或“大于”）。 - 一个参数值（需要时填写）。  如果为该过渡选择</strong> Has Exit Time__ 并有一个或多个条件，请注意 Unity Editor 在 <strong>Exit Time</strong> 之后考虑条件是否为 true。这样可确保在动画的特定部分中进行过渡。</td></tr></tbody></table><h3 id="过渡中断"><a href="#过渡中断" class="headerlink" title="过渡中断"></a>过渡中断</h3><p>使用 <strong>Interruption Source</strong> 和 <strong>Ordered Interruption</strong> 属性可控制如何中断过渡。</p><p>在概念上，中断顺序就像这些过渡已排队，然后解析为一个有效过渡从第一个过渡插入到最后一个过渡。</p><h4 id="Interruption-Source-属性"><a href="#Interruption-Source-属性" class="headerlink" title="Interruption Source 属性"></a>Interruption Source 属性</h4><p><a class="link"   href="https://docs.unity.cn/cn/2022.1/Manual/class-State.html" >AnyState <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 中的过渡始终首先添加在队列中，然后其他过渡根据 <strong>Interruption Source</strong> 的值排队：</p><table><thead><tr><th align="left"><strong>值</strong></th><th align="left"><strong>功能</strong></th></tr></thead><tbody><tr><td align="left"><strong>None</strong></td><td align="left">不再添加任何过渡。</td></tr><tr><td align="left"><strong>Current State</strong></td><td align="left">将当前状态的过渡排队。</td></tr><tr><td align="left"><strong>Next State</strong></td><td align="left">使下一状态的过渡进行排队。</td></tr><tr><td align="left"><strong>Current State then Next State</strong></td><td align="left">将当前状态的过渡排序，然后将下一状态的过渡排序。</td></tr><tr><td align="left"><strong>Next State then Current State</strong></td><td align="left">将下一状态的过渡排队，然后将当前状态的过渡排队。</td></tr></tbody></table><h4 id="Ordered-Interruption-属性"><a href="#Ordered-Interruption-属性" class="headerlink" title="Ordered Interruption 属性"></a>Ordered Interruption 属性</h4><p><strong>Ordered Interruption</strong> 属性将更改队列的解析方式。</p><p>根据该属性的值，对队列的解析将在以下列出的不同时间结束。</p><table><thead><tr><th align="left"><strong>值</strong></th><th align="left"><strong>结束时间</strong></th></tr></thead><tbody><tr><td align="left"><strong>选中</strong></td><td align="left">已找到有效过渡或当前过渡。</td></tr><tr><td align="left"><strong>取消选中</strong></td><td align="left">已找到有效过渡。</td></tr></tbody></table><p>只有 <a class="link"   href="https://docs.unity.cn/cn/2022.1/Manual/class-State.html" >AnyState <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 过渡才能被自身中断。</p><p>要了解有关过渡中断的更多信息，请参阅 Unity 博客文章<a class="link"   href="https://blogs.unity3d.com/2016/07/13/wait-ive-changed-my-mind-state-machine-transition-interruptions/" >状态机过渡中断 (State Machine Transition Interruptions) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p><h3 id="过渡图"><a href="#过渡图" class="headerlink" title="过渡图"></a>过渡图</h3><p>要手动调整以上列出的设置，可直接在字段中输入数字或使用过渡图。在操作视图元素时，过渡图会修改上述值。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/AnimatorTransitionSettingsAndGraph.svg"                      alt="Inspector 中显示的过渡设置和过渡图"                >Inspector 中显示的过渡设置和过渡图</p><p>请根据以下说明更改图形视图中的过渡属性：</p><ul><li>拖动 <strong>Duration “out”</strong> 标记可更改过渡的__持续时间 (Duration)__。</li><li>拖动 <strong>Duration “in”</strong> 标记可更改过渡的持续时间以及__退出时间 (Exit Time)__。</li><li>拖动目标状态可调整__过渡偏移 (Transition Offset)__。</li><li>拖动预览播放游标可在 Inspector 底部的预览窗口中快速预览动画混合（效果）。</li></ul><h3 id="混合树状态之间的过渡"><a href="#混合树状态之间的过渡" class="headerlink" title="混合树状态之间的过渡"></a>混合树状态之间的过渡</h3><p>如果属于此过渡的当前状态或下一状态是<a class="link"   href="https://docs.unity.cn/cn/2022.1/Manual/class-BlendTree.html" >混合树 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>状态，则混合树参数将出现在 Inspector 中。通过调整这些值可预览在混合树值设置为不同配置时的过渡表现情况。 如果混合树包含不同长度的剪辑，您应该测试在显示短剪辑和长剪辑时的过渡表现。调整这些值不会影响过渡在运行时的行为方式；它们仅用于帮助您预览不同条件下的过渡表现情况。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/AnimatorTransitionInspectorShowingBlendtreeParams.png"                      alt="当前状态或下一状态是混合树状态时显示的混合树参数预览控件。"                >当前状态或下一状态是混合树状态时显示的混合树参数预览控件。</p><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><p>一个过渡可以具有单个条件、多个条件或根本没有条件。如果过渡没有条件，Unity Editor 只会考虑 __Exit Time__，并在达到退出时间时发生过渡。如果过渡有一个或多个条件，则必须满足所有条件才能触发过渡。</p><p>一个条件包含：</p><ul><li>一个事件参数（在条件中考虑其值）。</li><li>条件谓词（需要时填写，例如，浮点数的小于或大于）。</li><li>一个参数值（需要时填写）。</li></ul><p>如果为该过渡启用 <strong>Has Exit Time</strong> 并有一个或多个条件，仅在状态的退出时间之后才会检查这些条件。这样可确保仅在动画的特定部分中进行过渡。</p><h3 id="设置枪械的位置"><a href="#设置枪械的位置" class="headerlink" title="设置枪械的位置"></a>设置枪械的位置</h3><p>通过角色的Root 来找到他的右手</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202102407444.png"                      alt="image-20230202102407444"                ></p><p>将枪械放到右手</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202102434944.png"                      alt="image-20230202102434944"                ></p><p>我们可以通过运行游戏来摆放枪械的位置，找到正确的位置，将它Copy下来，再粘贴</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202102550248.png"                      alt="image-20230202102550248"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202102606763.png"                      alt="image-20230202102606763"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202102632975.png"                      alt="image-20230202102632975"                ></p><p>，但是再跑动的时候，枪械的位置不理想，</p><p>打开Animation，发现是只读</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202102955288.png"                      alt="image-20230202102955288"                ></p><p>我们可以去到，对Rifle Run 复制一份 ， Ctrl + D;</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202103026254.png"                      alt="image-20230202103026254"                ></p><p>将原先的名字修改</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202103250432.png"                      alt="image-20230202103250432"                ></p><p>将原先的动画替换</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202103327975.png"                      alt="image-20230202103327975"                ></p><p>这样便可以去修改 动画里面枪械的位置</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202110010408.png"                      alt="image-20230202110010408"                ></p><h2 id="9-单位动画参数"><a href="#9-单位动画参数" class="headerlink" title="9. 单位动画参数"></a>9. 单位动画参数</h2><p>这后面就只记录比较重要的内容了，太累了</p><p>代码重构</p><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Unit</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Animator unitController;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> <span class="built_in">bool</span> isWalking = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> moveSpeed = <span class="number">4.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Vector3 targetPosition;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MoveController();</span><br><span class="line">        UnitAnimSwitch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MoveController</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//停止的距离， 防止在移动到目的地时，发生抖动；</span></span><br><span class="line">        <span class="built_in">float</span> stopDistance = <span class="number">.1</span>f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里不使用 Distance 是 为了减少开销，提高性能；</span></span><br><span class="line">        <span class="comment">// Vector3.Distance(transform.position - targetPosition);</span></span><br><span class="line">        <span class="keyword">if</span> ((transform.position - targetPosition).sqrMagnitude &gt; stopDistance * stopDistance)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//移动方向 = 目标位置 - 原来位置 ，然后归一化；</span></span><br><span class="line">            Vector3 moveDirection = (targetPosition - transform.position).normalized;</span><br><span class="line"></span><br><span class="line">            transform.position += moveDirection * moveSpeed * Time.deltaTime;</span><br><span class="line"></span><br><span class="line">            isWalking = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            isWalking = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果按下鼠标左键，则移动到该点</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            Move(MouseWorld.GetMousePosition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Move</span>(<span class="params">Vector3 targetPosition</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.targetPosition = targetPosition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnitAnimSwitch</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        unitController.SetBool(<span class="string">&quot;IsWalking&quot;</span>, isWalking);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="10-移动时旋转"><a href="#10-移动时旋转" class="headerlink" title="10.移动时旋转"></a>10.移动时旋转</h2><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Vector3.Lerp(float a, float b, float t);</span></span><br><span class="line">            <span class="comment">//线性插值，起始点，目标点 ，旋转的速度</span></span><br><span class="line">            <span class="built_in">float</span> rotateSpeed = <span class="number">8.0f</span>;</span><br><span class="line">            transform.forward = Vector3.Lerp(transform.forward, moveDirection, rotateSpeed * Time.deltaTime);</span><br></pre></td></tr></table></figure></div><h2 id="11-单位选择"><a href="#11-单位选择" class="headerlink" title="11.单位选择"></a>11.单位选择</h2><p>新建一个 叫 UnitActionSystem 的 空物体，新建一个UnitActionSystem 脚本</p><p>将点击移动的代码放入进去 ，</p><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitActionSystem</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Unit selectUnit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果按下鼠标左键，则移动到该点</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            selectUnit.Move(MouseWorld.GetMousePosition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//再Unit.cs 上添加</span></span><br><span class="line"><span class="comment">//游戏开始时，目标位置 = 当前位置，这样 多个角色就不会重叠在一起</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        targetPosition = transform.position;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><p>添加一个碰撞体，勾选is Trigger ，确保我们能够点到他</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202115942770.png"                      alt="image-20230202115942770"                ></p><p>单元检测代码：</p><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitActionSystem</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Unit selectUnit;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> LayerMask unitLayerMask;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果按下鼠标左键，则移动到该点</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButton(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果检测到了Unit,则返回 ，这样我们才可以选择地面移动</span></span><br><span class="line">            <span class="keyword">if</span> (TryHandleUnitSelection()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果检测到的不是Unit 而是地面则移动,并且selectUnit 不能为空</span></span><br><span class="line">            <span class="keyword">if</span> (selectUnit != <span class="literal">null</span>)</span><br><span class="line">                selectUnit.Move(MouseWorld.GetMousePosition());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">bool</span> <span class="title">TryHandleUnitSelection</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Physics.Raycast(ray, <span class="keyword">out</span> RaycastHit unitInfo, <span class="built_in">float</span>.MaxValue, unitLayerMask))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//TryGetComponent：</span></span><br><span class="line">            <span class="comment">//bool 如果发现组件，则返回 /true/，否则返回 /false/。</span></span><br><span class="line">            <span class="comment">// 获取指定类型的组件（如果存在）。</span></span><br><span class="line">            <span class="comment">// TryGetComponent 将尝试获取给定类型的组件。与 GameObject.GetComponent 相比的显著差异在于，如果请求的组件不存在，则此方法不在  编辑器中进行分配。</span></span><br><span class="line">            <span class="keyword">if</span> (unitInfo.transform.TryGetComponent&lt;Unit&gt;(<span class="keyword">out</span> Unit unit))</span><br><span class="line">            &#123;</span><br><span class="line">                selectUnit = unit;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//等于上面一个if语句</span></span><br><span class="line">            <span class="comment">// Unit unit1 = unitInfo.transform.GetComponent&lt;Unit&gt;();</span></span><br><span class="line">            <span class="comment">// if (unit1 != null)</span></span><br><span class="line">            <span class="comment">// &#123;</span></span><br><span class="line">            <span class="comment">//     selectUnit = unitInfo.collider.GetComponent&lt;Unit&gt;();</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我们要确保我们的单位选择系统要早点执行，可以再ProjectSetting上进行调整，调整到比默认时间快</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202125957213.png"                      alt="image-20230202125957213"                ></p><h2 id="12-选择单元的视觉效果"><a href="#12-选择单元的视觉效果" class="headerlink" title="12.选择单元的视觉效果"></a>12.选择单元的视觉效果</h2><p>新建一个 UnitSlectVisual 的脚本</p><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitSelectVisual</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Unit unit;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> MeshRenderer meshRenderer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        meshRenderer = GetComponent&lt;MeshRenderer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>这里用到了委托的方法</p><h3 id="invoke和begininvoke-区别"><a href="#invoke和begininvoke-区别" class="headerlink" title="invoke和begininvoke 区别"></a><a class="link"   href="http://blog.csdn.net/thebesttome/article/details/7589856" >invoke和begininvoke 区别 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3><p>一直对invoke和begininvoke的使用和概念比较混乱，这两天看了些资料，对这两个的用法和原理有了些新的认识和理解。</p><p> 首先说下，invoke和begininvoke的使用有两种情况：</p><ol><li><p>control中的invoke、begininvoke。</p></li><li><p>delegrate中的invoke、begininvoke。</p></li></ol><p> 这两种情况是不同的，我们这里要讲的是第1种。下面我们在来说下.NET中对invoke和begininvoke的官方定义。</p><p> control.invoke(参数delegate)方法:在<strong>拥有</strong>此控件的基础窗口句柄的线程上<strong>执行</strong>指定的委托。</p><p> control.begininvoke(参数delegate)方法:在<strong>创建</strong>控件的基础句柄所在线程上<strong>异步执行</strong>指定委托。</p><p> 根据这两个概念我们大致理解invoke表是<strong>同步</strong>、begininvoke表示<strong>异步</strong>。</p><p><strong>如果你的后台线程在更新一个UI控件的状态后不需要等待，而是要继续往下处理，那么你就应该使用BeginInvoke来进行异步处理。</strong></p><p><strong>如果你的后台线程需要操作UI控件，并且需要等到该操作执行完毕才能继续执行，那么你就应该使用Invoke。</strong></p><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ? 等于 if(onselectUnitChanged != null)</span></span><br><span class="line">OnSelectUnitChanged?.Invoke(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UnitSelectVisual</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> Unit unit;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">SerializeField</span>] <span class="keyword">private</span> MeshRenderer meshRenderer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Awake</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        meshRenderer = GetComponent&lt;MeshRenderer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//切换角色事件 注册 </span></span><br><span class="line">        UnitActionSystem.Instance.OnSelectUnitChanged += UnitActionSystem_OnSelectedUnitChanged;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UnitActionSystem_OnSelectedUnitChanged</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs empty</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        UpdateVisual();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">UpdateVisual</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (UnitActionSystem.Instance.GetSelectedUnit() == unit)</span><br><span class="line">        &#123;</span><br><span class="line">            meshRenderer.enabled = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            meshRenderer.enabled = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><h1 id="Part3-网格系统和相机"><a href="#Part3-网格系统和相机" class="headerlink" title="Part3.网格系统和相机"></a>Part3.网格系统和相机</h1><h2 id="1-网格系统设计"><a href="#1-网格系统设计" class="headerlink" title="1.网格系统设计"></a>1.网格系统设计</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202165020609.png"                      alt=" "                ></p><h2 id="2-网格系统"><a href="#2-网格系统" class="headerlink" title="2.网格系统"></a>2.网格系统</h2><p>新建一个GridSystem脚本</p> <div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">GridSystem</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> width;</span><br><span class="line">    <span class="built_in">int</span> height;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GridSystem</span>(<span class="params"><span class="built_in">int</span> width, <span class="built_in">int</span> height</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//网格绘制 ，沿着 z 轴绘制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> x = <span class="number">0</span>; x &lt; width; x++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> z = <span class="number">0</span>; z &lt; height; z++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//绘制线 ， 并加上一点偏移 </span></span><br><span class="line">                Debug.DrawLine(GetWorldPosition(x, z), GetWorldPosition(x, z) + Vector3.right * <span class="number">.2</span>f, Color.white, <span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取世界坐标系</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vector3 <span class="title">GetWorldPosition</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> z</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Vector3(x, <span class="number">0</span>, z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>新建一个测试脚本</p><div class="highlight-container" data-rel="C#"><figure class="iseeu highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Testing</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> GridSystem(<span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在运行游戏的时候 记得打开Gizmos，有白色的线段则 成功。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202181304333.png"                      alt="image-20230202181304333"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/image-20230202181340001.png"                      alt="image-20230202181340001"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[Toc]&lt;/p&gt;
&lt;h1 id=&quot;Part1-后期处理（这一些效果挺不错的，值得自己去尝试一下）&quot;&gt;&lt;a href=&quot;#Part1-后期处理（这一些效果挺不错的，值得自己去尝试一下）&quot; class=&quot;headerlink&quot; title=&quot;Part1.后期处理（这一些效果挺</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>基于MVC架构的UI设计</title>
    <link href="http://example.com/2023/01/30/%E5%9F%BA%E4%BA%8EMVC%E6%9E%B6%E6%9E%84%E7%9A%84UI%E8%AE%BE%E8%AE%A1/"/>
    <id>http://example.com/2023/01/30/%E5%9F%BA%E4%BA%8EMVC%E6%9E%B6%E6%9E%84%E7%9A%84UI%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-01-30T13:30:35.000Z</published>
    <updated>2023-01-30T16:06:28.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个Unity框架需要满足那些条件："><a href="#一个Unity框架需要满足那些条件：" class="headerlink" title="一个Unity框架需要满足那些条件："></a>一个Unity框架需要满足那些条件：</h1><ol><li><p>非常方便的使用，程序，策划，美术，能在一起很好的工作；</p></li><li><p>要能做到代码非常方便的能维护；</p></li><li><p>降低开发难度，让开发变得简单；</p></li><li><p>做好我们的一些的更新机制与版本管理</p></li><li><p>一键打包发布</p></li><li><p>打空包</p></li><li><p>制作工具： 路径编辑工具 + 地图编辑器 + Excel表格解析</p><p>。。。。</p></li></ol><h1 id="2-Unity开发框架的一些基本的原则："><a href="#2-Unity开发框架的一些基本的原则：" class="headerlink" title="2.Unity开发框架的一些基本的原则："></a>2.Unity开发框架的一些基本的原则：</h1><p>原则1 ：程序做程序，美术做美术，策划数据；</p><p>—&gt; 程序逻辑与美术视图（地图，角色，UI，特效。。。)分开；</p><p> 程序 —&gt; 拼逻辑，美术—&gt; 做资源；</p><p>—-&gt; 程序逻辑与策划的数据  —-&gt; 策划；（Excel 表格， 行为树， 状态机）</p><p>原则2：</p><p>方便代码维护  ？—-&gt; Unity哪些习惯是不好维护这个代码的？</p><p>Unity不好维护代码的习惯： 代码 —&gt;挂到节点上； —-&gt;后面不知道代码在哪里调用；把视图翻开，一个个看，看这个节点有没有挂代码；—&gt;方便更新；</p><p>直接往我们的视图上，手动的去挂脚本，只有文本可搜索的代码，才是能维护的代码。</p><p>(确实，到后期如果代码、文件太多，在维护的时候需要自己一个个去翻)</p><p>原则3：</p><p>要求我们的游戏场景不要放任何逻辑相关的内容节点 —&gt; 场景是空的；</p><p>所以干脆切换场景我们都不要， 我们游戏运行的时候只有一个运行时的场景；</p><p>场景只是一个运行时的载体和容器；</p><p>如果你的游戏内容 —-&gt; 放到场景里面 —-&gt; 如何打包；</p><p>更新资源更方便，代码维护会更方便；</p><p>美术用的场景 —&gt; 不会打包到安装包里面；</p><p>原则4：</p><p>方便资源更新，方便热更新，方便打空包，场景空的，new 资源 —&gt;代码加载资源;</p><p>坚决不用Resource.load，代码加载资源，不用，为什么呢？</p><p>Resources里面的资源，不管你用了还是没用 —&gt;都要被打包进去 —&gt; 打空包不方便</p><p>使用纯 AssetsBundle 来做我们的资源更新 + 资源加载 + 资源管理；</p><p>step1：加载ab包到内存；</p><p>step2：从ab包里面加载资源 —-&gt;给游戏使用</p><p>step3：做好资源管理不要用的资源我们释放掉；</p><p>​好处1：方便打空包（空的场景， 没有Resources）</p><p>​好处2：方便更新，Assets Bundle机制，天然就是给我们更新资源，资源更新；</p><p>​好处3： ab包会压缩资源，如果所你要把资源放到安装包里面，包体会小；</p><p>​StreammingAssets&#x2F; 文件夹下，那么这个时候，我们就可以加载得到这个ab包；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一个Unity框架需要满足那些条件：&quot;&gt;&lt;a href=&quot;#一个Unity框架需要满足那些条件：&quot; class=&quot;headerlink&quot; title=&quot;一个Unity框架需要满足那些条件：&quot;&gt;&lt;/a&gt;一个Unity框架需要满足那些条件：&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>绘画练手</title>
    <link href="http://example.com/2023/01/30/%E7%BB%98%E7%94%BB%E7%BB%83%E6%89%8B/"/>
    <id>http://example.com/2023/01/30/%E7%BB%98%E7%94%BB%E7%BB%83%E6%89%8B/</id>
    <published>2023-01-30T12:01:45.000Z</published>
    <updated>2023-01-30T12:10:02.441Z</updated>
    
    <content type="html"><![CDATA[<p>这两幅画好像都是高中时候画的，不过好多没保存好，找不到了，现在就存在这里吧</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/1.jpg"                      alt="1"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/3.jpg"                      alt="2"                ></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这两幅画好像都是高中时候画的，不过好多没保存好，找不到了，现在就存在这里吧&lt;/p&gt;
&lt;p&gt;&lt;img  
                     lazyload
                     src=&quot;/images/loading.svg&quot;
        </summary>
      
    
    
    
    
    <category term="绘画练手" scheme="http://example.com/tags/%E7%BB%98%E7%94%BB%E7%BB%83%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer Plus</title>
    <link href="http://example.com/2023/01/30/C-Primer-Plus-1/"/>
    <id>http://example.com/2023/01/30/C-Primer-Plus-1/</id>
    <published>2023-01-30T10:41:51.000Z</published>
    <updated>2023-01-30T11:57:10.347Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Unity脚本的生命周期</title>
    <link href="http://example.com/2023/01/29/Unity%E8%84%9A%E6%9C%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://example.com/2023/01/29/Unity%E8%84%9A%E6%9C%AC%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2023-01-29T09:05:06.000Z</published>
    <updated>2023-01-29T14:57:15.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Unity的生命周期"><a href="#1-Unity的生命周期" class="headerlink" title="1.Unity的生命周期"></a>1.Unity的生命周期</h2><h3 id="1-1-新版生命周期图表"><a href="#1-1-新版生命周期图表" class="headerlink" title="1.1 新版生命周期图表"></a>1.1 新版生命周期图表</h3><p><a class="link"   href="https://docs.unity3d.com/cn/2022.2/Manual/ExecutionOrder.html" >生命周期官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><img                       lazyload                     src="/images/loading.svg"                     data-src="/images/monobehaviour_flowchart.jpg"                                       ><h3 id="1-2-加载第一个场景"><a href="#1-2-加载第一个场景" class="headerlink" title="1.2 加载第一个场景"></a>1.2 加载第一个场景</h3><p>场景开始时将调用以下函数（为场景中的每个对象调用一次）。</p><ul><li><strong>Awake：</strong>始终在任何 Start 函数之前并在实例化预制件之后调用此函数。（如果游戏对象在启动期间处于非活动状态，则在激活之后才会调用 Awake。）</li><li><strong>OnEnable：</strong>（仅在对象处于激活状态时调用）在启用对象后立即调用此函数。在创建 MonoBehaviour 实例时（例如加载关卡或实例化具有脚本组件的游戏对象时）会执行此调用。</li></ul><p>请注意，对于添加到场景中的对象，在为任何对象调用 Start 和 Update 等函数之前，会为_所有_ 脚本调用 Awake 和 OnEnable 函数。当然，在游戏运行过程中实例化对象时，不能强制执行此调用。</p><h3 id="1-3-Editor"><a href="#1-3-Editor" class="headerlink" title="1.3 Editor"></a>1.3 Editor</h3><ul><li><strong>Reset：</strong>调用 Reset 可以在脚本首次附加到对象时以及使用 <em>Reset</em> 命令时初始化脚本的属性。</li><li><strong>OnValidate：</strong>每当设置脚本的属性时都会调用 OnValidate，包括反序列化对象时，这可能发生在不同的时间，例如在编辑器中打开场景时和域重新加载后。</li></ul><h3 id="1-4-在第一次帧更新之前"><a href="#1-4-在第一次帧更新之前" class="headerlink" title="1.4 在第一次帧更新之前"></a>1.4 在第一次帧更新之前</h3><ul><li><strong>Start：</strong>仅当启用脚本实例后，才会在第一次帧更新之前调用 Start。</li></ul><p>对于场景资源中的对象，在为任何脚本调用 Update 等函数之前，将在所有脚本上调用 Start 函数。当然，在游戏运行过程中实例化对象时，不能强制执行此调用。</p><h3 id="1-5-帧之间"><a href="#1-5-帧之间" class="headerlink" title="1.5 帧之间"></a>1.5 帧之间</h3><ul><li><strong>OnApplicationPause：</strong>在帧的结尾处调用此函数（在正常帧更新之间有效检测到暂停）。在调用 <strong>OnApplicationPause</strong> 之后，将发出一个额外帧，从而允许游戏显示图形来指示暂停状态。</li></ul><h3 id="1-6-更新顺序"><a href="#1-6-更新顺序" class="headerlink" title="1.6 更新顺序"></a>1.6 更新顺序</h3><p>跟踪游戏逻辑和交互、动画、摄像机位置等的时候，可以使用一些不同事件。常见方案是在 <strong>Update</strong> 函数中执行大多数任务，但是也可以使用其他函数。</p><ul><li><strong>FixedUpdate：</strong>调用 <strong>FixedUpdate</strong> 的频度常常超过 <strong>Update</strong>。如果帧率很低，可以每帧调用该函数多次；如果帧率很高，可能在帧之间完全不调用该函数。在 <strong>FixedUpdate</strong> 之后将立即进行所有物理计算和更新。在 <strong>FixedUpdate</strong> 内应用运动计算时，无需将值乘以 <strong>Time.deltaTime</strong>。这是因为 <strong>FixedUpdate</strong> 的调用基于可靠的计时器（独立于帧率）。</li><li><strong>Update：</strong>每帧调用一次 <strong>Update</strong>。这是用于帧更新的主要函数。</li><li><strong>LateUpdate：</strong>每帧调用一次 <strong>LateUpdate__（在</strong> Update__ 完成后）。<strong>LateUpdate</strong> 开始时，在 <strong>Update</strong> 中执行的所有计算便已完成。<strong>LateUpdate</strong> 的常见用途是跟随第三人称摄像机。如果在 <strong>Update</strong> 内让角色移动和转向，可以在 <strong>LateUpdate</strong> 中执行所有摄像机移动和旋转计算。这样可以确保角色在摄像机跟踪其位置之前已完全移动。</li></ul><p>通常，不应依赖为不同的游戏对象调用相同事件函数的顺序 - 除非顺序明确记录或可设置。（如果需要对播放器循环进行更细粒度的控制，可以使用 <a class="link"   href="https://docs.unity3d.com/cn/2022.2/ScriptReference/LowLevel.PlayerLoop.html" >PlayerLoop API <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。）</p><p>不能指定为同一 MonoBehaviour 子类的不同实例调用事件函数的顺序。例如，一个 MonoBehaviour 的 <strong>Update</strong> 函数可能会在另一个游戏对象（包括其父级或子级游戏对象）上的相同 MonoBehaviour 的 <strong>Update</strong> 函数之前或之后调用。</p><p>可以指定一个 MonoBehaviour 子类的事件函数应在不同子类的事件函数之前调用（使用 Project Settings 窗口的 Script Execution Order 面板）。例如，如果有两个脚本，EngineBehaviour 和 SteeringBehaviour，可以设置 Script Execution Order，这样 EngineBehaviours 始终在 SteeringBehaviours 之前更新。</p><h3 id="1-7-动画更新循环"><a href="#1-7-动画更新循环" class="headerlink" title="1.7 动画更新循环"></a>1.7 动画更新循环</h3><p>Unity 评估动画系统时，将调用以下函数和 <a class="link"   href="https://docs.unity3d.com/cn/2022.2/Manual/Profiler.html" >Profiler <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 标记。</p><ul><li><p><strong>OnStateMachineEnter：</strong>在<strong>状态机更新 (State Machine Update)</strong> 步骤中，当控制器的状态机进行流经 Entry 状态的转换时，将在第一个更新帧上调用此回调。在转换到 <strong>StateMachine</strong> 子状态时不会调用此回调。</p><p>仅当动画图中存在控制器组件（例如，<a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/Animations.AnimatorController.html"><strong>AnimatorController</strong></a>、<a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/AnimatorOverrideController.html"><strong>AnimatorOverrideController</strong></a> 或 <a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/Animations.AnimatorControllerPlayable.html"><strong>AnimatorControllerPlayable</strong></a>）时才会发生此回调。</p><p><strong>注意：</strong>将此回调添加到 <a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/StateMachineBehaviour.html"><strong>StateMachineBehaviour</strong></a> 组件会禁用多线程的状态机评估。</p></li><li><p><strong>OnStateMachineExit：</strong>在<strong>状态机更新 (State Machine Update)</strong> 步骤中，当控制器的状态机进行流经 Exit 状态的转换时，将在最后一个更新帧上调用此回调。在转换到 <strong>StateMachine</strong> 子状态时不会调用此回调。</p><p>仅当动画图中存在控制器组件（例如，<a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/Animations.AnimatorController.html"><strong>AnimatorController</strong></a>、<a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/AnimatorOverrideController.html"><strong>AnimatorOverrideController</strong></a> 或 <a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/Animations.AnimatorControllerPlayable.html"><strong>AnimatorControllerPlayable</strong></a>）时才会发生此回调。</p><p><strong>注意：</strong>将此回调添加到 <a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/StateMachineBehaviour.html"><strong>StateMachineBehaviour</strong></a> 组件会禁用多线程的状态机评估。</p></li><li><p><strong>触发动画事件 (Fire Animation Events)：</strong>调用在上次更新时间和当前更新时间之间采样的所有剪辑中的所有动画事件。</p></li><li><p><strong>StateMachineBehaviour (OnStateEnter&#x2F;OnStateUpdate&#x2F;OnStateExit)：</strong>一个层最多可以有 3 个活动状态：当前状态、中断状态和下一个状态。使用一个定义 <strong>OnStateEnter</strong>、<strong>OnStateUpdate</strong> 或 <strong>OnStateExit</strong> 回调的 StateMachineBehaviour 组件为每个活动状态调用此函数。</p><p>依次针对当前状态、中断状态和下一个状态调用此函数。</p><p>仅当动画图中存在控制器组件（例如，<a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/Animations.AnimatorController.html"><strong>AnimatorController</strong></a>、<a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/AnimatorOverrideController.html"><strong>AnimatorOverrideController</strong></a> 或 <a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/Animations.AnimatorControllerPlayable.html"><strong>AnimatorControllerPlayable</strong></a>）时才会执行此步骤。</p></li><li><p><strong>OnAnimatorMove：</strong>在每个更新帧中为每个 Animator 组件调用一次此函数来修改根运动 (Root Motion)。</p></li><li><p><strong>StateMachineBehaviour(OnStateMove)：</strong>使用定义此回调的 <a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/StateMachineBehaviour.html"><strong>StateMachineBehaviour</strong></a> 在每个活动状态中调用此函数。</p></li><li><p><strong>OnAnimatorIK：</strong>设置动画 IK。为每个启用 <strong>IK pass</strong> 的 Animator Controller 层进行一次此调用。</p><p>仅当使用人形骨架时才会执行此事件。</p></li><li><p><strong>StateMachineBehaviour(OnStateIK)：</strong>使用在启用 <strong>IK pass</strong> 的层上定义此回调的 <a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/StateMachineBehaviour.html"><strong>StateMachineBehaviour</strong></a> 组件在每个活动状态中调用此函数。</p></li><li><p><strong>WriteProperties：</strong>从主线程将所有其他动画属性写入场                                            <a href="#%E7%9B%AE%E5%BD%95">返回目录</a></p></li></ul><h4 id="1-7-1有用的性能分析标记"><a href="#1-7-1有用的性能分析标记" class="headerlink" title="1.7.1有用的性能分析标记"></a>1.7.1有用的性能分析标记</h4><p><a class="link"   href="https://docs.unity3d.com/cn/2022.2/Manual/ExecutionOrder.html#ScriptLifecycleFlowchart" >脚本生命周期流程图 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>中显示的某些动画函数不是可以调用的事件函数；它们是 Unity 处理动画时调用的内部函数。</p><p>这些函数具有 Profiler 标记，因此您可以使用 <a class="link"   href="https://docs.unity3d.com/cn/2022.2/Manual/Profiler.html" >Profiler <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 查看 Unity 在帧中调用这些函数的时间。知道 Unity 调用这些函数的时间有助于准确了解所调用的事件函数的具体执行时间。</p><p>例如，假设在 <strong>FireAnimationEvents</strong> 回调中调用 <a class="link"   href="https://docs.unity3d.com/cn/2022.2/ScriptReference/Animator.Play.html" >Animator.Play <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。如果知道只有在执行<strong>状态机更新 (State Machine Update)</strong> 和<strong>流程图 (Process Graph)</strong> 函数后才会触发 <strong>FireAnimationEvents</strong> 回调，就可以预期动画剪辑会在下一帧播放，而不是马上播放。</p><ul><li><p><strong>状态机更新 (State Machine Update)：</strong>在执行序列的此步骤中评估所有状态机。仅当动画图中存在控制器组件（例如，<a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/Animations.AnimatorController.html"><strong>AnimatorController</strong></a>、<a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/AnimatorOverrideController.html"><strong>AnimatorOverrideController</strong></a> 或 <a href="https://docs.unity3d.com/cn/2022.2/ScriptReference/Animations.AnimatorControllerPlayable.html"><strong>AnimatorControllerPlayable</strong></a>）时才会发生此回调。</p><p><strong>注意：</strong>状态机评估通常是多线程的，但添加某些回调（例如，<strong>OnStateMachineEnter</strong> 和 <strong>OnStateMachineExit</strong>）会禁用多线程。请参数上文的<a class="link"   href="https://docs.unity3d.com/cn/2022.2/Manual/ExecutionOrder.html#AnimationUpdateLoop" >动画更新循环 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>以了解详细信息。</p></li><li><p><strong>ProcessGraph：</strong>评估所有动画图。此过程包括对需要评估的所有动画剪辑进行采样以及计算根运动 (Root Motion)。</p></li><li><p><strong>ProcessAnimation：</strong>混合动画图的结果。</p></li><li><p><strong>WriteTransforms：</strong>将所有动画变换从工作线程写入场景。</p><p>如果一个人形骨架的多个层启用了 <strong>IK pass</strong>，则该人形骨架可以有多个 <strong>WriteTransforms</strong> 通道（请参阅<a class="link"   href="https://docs.unity3d.com/cn/2022.2/Manual/ExecutionOrder.html#ScriptLifecycleFlowchart" >脚本生命周期流程图 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>）。</p></li></ul><h3 id="1-8-Rendering"><a href="#1-8-Rendering" class="headerlink" title="1.8 Rendering"></a>1.8 Rendering</h3><ul><li><strong>OnPreCull：</strong>在摄像机剔除场景之前调用。剔除操作将确定摄像机可以看到哪些对象。正好在进行剔除之前调用 OnPreCull。</li><li><strong>OnBecameVisible&#x2F;OnBecameInvisible：</strong>对象变为对任何摄像机可见&#x2F;不可见时调用。</li><li><strong>OnWillRenderObject：</strong>如果对象可见，则为每个摄像机调用<strong>一次</strong>。</li><li><strong>OnPreRender：</strong>在摄像机开始渲染场景之前调用。</li><li><strong>OnRenderObject：</strong>所有常规场景渲染完成之后调用。此时，可以使用 <a class="link"   href="https://docs.unity3d.com/cn/2022.2/ScriptReference/GL.html" >GL <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 类或 <a class="link"   href="https://docs.unity3d.com/cn/2022.2/ScriptReference/Graphics.DrawMeshNow.html" >Graphics.DrawMeshNow <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 来绘制自定义几何形状。</li><li><strong>OnPostRender：</strong>在摄像机完成场景渲染后调用。</li><li><strong>OnRenderImage：</strong>在场景渲染完成后调用以允许对图像进行后处理，请参阅<a class="link"   href="https://docs.unity3d.com/cn/2022.2/Manual/PostProcessingOverview.html" >后期处理效果 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</li><li><strong>OnGUI：</strong>每帧调用多次以响应 GUI 事件。首先处理布局和重新绘制事件，然后为每个输入事件处理布局和键盘&#x2F;鼠标事件。</li><li><strong>OnDrawGizmos</strong> 用于在场景视图中绘制辅助图标以实现可视化。</li></ul><p><strong>Note:</strong> These callbacks only work with the Built-in Render Pipeline.</p><h3 id="1-9-协程"><a href="#1-9-协程" class="headerlink" title="1.9 协程"></a>1.9 协程</h3><p>Update 函数返回后将运行正常协程更新。协程是一个可暂停执行 (yield) 直到给定的 YieldInstruction 达到完成状态的函数。 协程的不同用法：</p><ul><li><strong>yield</strong> 在下一帧上调用所有 Update 函数后，协程将继续。</li><li><strong>yield WaitForSeconds</strong> 在为帧调用所有 Update 函数后，在指定的时间延迟后继续。</li><li><strong>yield WaitForFixedUpdate</strong> 在所有脚本上调用所有 FixedUpdate 后继续。如果协同程序在 FixedUpdate 之前生成，那么它会在当前帧的 FixedUpdate 之后继续运行。</li><li><strong>yield WWW</strong> 在 WWW 下载完成后继续。</li><li><strong>yield StartCoroutine</strong> 将协程链接起来，并会等待 MyFunc 协程先完成。</li></ul><h3 id="1-10-销毁对象时"><a href="#1-10-销毁对象时" class="headerlink" title="1.10 销毁对象时"></a>1.10 销毁对象时</h3><ul><li><strong>OnDestroy：</strong>对象存在的最后一帧完成所有帧更新之后，调用此函数（可能应 Object.Destroy 要求或在场景关闭时销毁该对象）。</li></ul><h3 id="1-11-退出时"><a href="#1-11-退出时" class="headerlink" title="1.11 退出时"></a>1.11 退出时</h3><p>在场景中的所有活动对象上调用以下函数：</p><ul><li><strong>OnApplicationQuit：</strong>在退出应用程序之前在所有游戏对象上调用此函数。在编辑器中，用户停止播放模式时，调用函数。</li><li><strong>OnDisable：</strong>行为被禁用或处于非活动状态时，调用此函数。</li></ul><h3 id="主要的生命周期"><a href="#主要的生命周期" class="headerlink" title="主要的生命周期"></a>主要的生命周期</h3><p><strong>Reset :</strong> 用户第一次添加组件时或用户点击见组件面板上的Reset按钮时调用</p><p><strong>OnAwake</strong>: 当脚本实例被载入时Awake被调用，一般可以在这个地方将当前脚本禁用:this.enable&#x3D;false，如果这样做了，则会直接跳转到OnDisable方法执行一次，然后其它的任何方法，都将不再被执行。如果当前脚本处于可用状态，则正常的执行顺序是继续向下执行OnEnable，当然我们可以在另外一个脚本中实现这个脚本组件的启动：this.enab&#x3D;true;</p><p><strong>OnStart</strong>: Start仅在Update函数第一次被调用前调用。</p><p><strong>OnUpdate</strong>：渲染一帧之前被调用。这里是大部分游戏行为代码被执行的地方，除了物理代码。</p><p><strong>LateUpdate</strong>: 是在所有Update函数调用后被调用。这可用于调整脚本执行顺序。例如:当物体在Update里移动时，跟随物体的相机可以在LateUpdate里实现。如果后面写了Reset，则会又回到Update</p><p><strong>OnGUI</strong>: 渲染和处理GUI事件时调用，当然，如果你使用了NGUI，这个生命周期的事情就不用考虑了。</p><p><strong>FixedUpdate</strong>: 这个函数在每个物理时间步被调用一次。这是处理基于物理游戏行为的地方。常用于移动模型等操作。不受帧率影响，默认0.02s，如果卡帧了Update就不会再执行，而FixedUpdate则继续执行。</p><p>Edit-&gt;preject setting -&gt;Time -&gt; (Inspector监测视图）Fixed Timestep 设置刷新时间</p><p><strong>OnDisable</strong>: 当对象变为不可用或非激活状态时此函数被调用。这个时候，脚本并不会被销毁，在这个状态下，可以重新回到OnEnable状态（enable&#x3D;true）。</p><p><strong>OnDestroy</strong>: 当MonoBehaviour将被销毁时，这个函数被调用。当前脚本的生命周期结束。</p><p>建议一般在Awake中做一些初始化，在Start中获取游戏对象</p><p>其他的生命周期：</p><p><strong>OnPreCull</strong>:在相机剔除场景之前调用此函数。相机可见的对象取决于剔除。OnPreCull 函数调用发生在剔除之前。</p><p><strong>OnBecameVisible&#x2F;OnBecameInvisible</strong>:在对象对于相机可见&#x2F;不可见时调用此函数。</p><p><strong>OnWillRenderObject</strong>:如果对象可见，则为每个相机调用一次此函数。</p><p><strong>OnPreRender</strong>:在相机开始渲染场景之前调用此函数。</p><p><strong>OnRenderObject</strong>:在完成所有常规场景渲染后调用此函数。此时，可使用 GL 类或 Graphics.DrawMeshNow 绘制自定义几何图形。</p><p><strong>OnPostRender</strong>:在相机完成场景渲染后调用此函数。</p><p><strong>OnRenderImage</strong>（仅限专业版）：在完成场景渲染后调用此函数，以便对屏幕图像进行后处理。</p><p><strong>OnGUI</strong>:在每帧上多次调用此函数，以响应 GUI 事件。程序首先将处理 Layout 和 Repaint 事件，然后再处理每个输入事件的 Layout 和 keyboard&#x2F;鼠标事件。</p><p><strong>OnDrawGizmos</strong>: 用于在场景视图中绘制小图示 (Gizmos)，以实现可视化目的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-Unity的生命周期&quot;&gt;&lt;a href=&quot;#1-Unity的生命周期&quot; class=&quot;headerlink&quot; title=&quot;1.Unity的生命周期&quot;&gt;&lt;/a&gt;1.Unity的生命周期&lt;/h2&gt;&lt;h3 id=&quot;1-1-新版生命周期图表&quot;&gt;&lt;a href=&quot;#1</summary>
      
    
    
    
    
    <category term="Unity" scheme="http://example.com/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>性能优化</title>
    <link href="http://example.com/2023/01/29/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2023/01/29/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2023-01-29T05:51:51.000Z</published>
    <updated>2023-01-29T10:34:22.792Z</updated>
    
    <content type="html"><![CDATA[<h1 id="性能优化篇"><a href="#性能优化篇" class="headerlink" title="性能优化篇"></a>性能优化篇</h1><p><code>(一些自己想了解的，想知道为什么这么做的)</code></p><hr><h2 id="1-在for循环里面，为什么-使用-i-会-比-i-好？"><a href="#1-在for循环里面，为什么-使用-i-会-比-i-好？" class="headerlink" title="1.在for循环里面，为什么 使用 ++i 会 比 i++ 好？"></a>1.在for循环里面，为什么 使用 ++i 会 比 i++ 好？</h2><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (语句<span class="number">1</span>; 语句<span class="number">2</span>; 语句<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 被执行的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><ul><li>语句 1， 在循环（代码块）开始前执行</li><li>语句 2 ，定义运行循环（代码块）的条件</li><li>语句 3 ，在循环（代码块）已被执行之后执行</li></ul><p><strong>这就是循环中的 <code>++i</code> 和 <code>i++</code> 结果一样的原因，但是性能不一样，在大量数据的时候 <code>++i</code> 的性能要比 <code>i++</code> 的性能好原因：<code>i++</code> 由于是在使用当前值之后 <code>再+1</code> ，所以需要一个临时的变量来转存。 而 <code>++i</code> 则是在直接 <code>+1</code> ，<code>省去了对内存的操作的环节</code>，相对而言能够提高性能。</strong></p><p><strong>简而言之：<code>++i 省去了对内存的操作的环节，性能更高。✌</code></strong></p><p>😶‍🌫️</p><h2 id="2-多脚本优化"><a href="#2-多脚本优化" class="headerlink" title="2.多脚本优化"></a>2.多脚本优化</h2><p>脚本挂的越多，执行效率就越低。这些脚本都需要执行生命周期的方法，此时Unity需要遍历他们，然后再反射调用每个脚本的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;性能优化篇&quot;&gt;&lt;a href=&quot;#性能优化篇&quot; class=&quot;headerlink&quot; title=&quot;性能优化篇&quot;&gt;&lt;/a&gt;性能优化篇&lt;/h1&gt;&lt;p&gt;&lt;code&gt;(一些自己想了解的，想知道为什么这么做的)&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;1-在for</summary>
      
    
    
    
    <category term="Unity性能优化" scheme="http://example.com/categories/Unity%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
    <category term="性能优化" scheme="http://example.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++学习</title>
    <link href="http://example.com/2023/01/29/C-%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2023/01/29/C-%E5%AD%A6%E4%B9%A0/</id>
    <published>2023-01-29T05:45:15.000Z</published>
    <updated>2023-01-29T05:45:15.087Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>C++学习</title>
    <link href="http://example.com/2023/01/29/C-Primer-Plus-1/chapter01/"/>
    <id>http://example.com/2023/01/29/C-Primer-Plus-1/chapter01/</id>
    <published>2023-01-29T05:45:15.000Z</published>
    <updated>2023-01-30T10:50:19.502Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-预备知识"><a href="#第一章-预备知识" class="headerlink" title="第一章 预备知识"></a>第一章 预备知识</h1><p>C++总览简介</p><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。<br>C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。<br>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。<br>C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。</p><p>注意：使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p><p>面向对象程序设计</p><p>C++最大的亮点就是面向对象程序设计理念的运用。包括面向对象开发的四大特性：<br>    封装<br>    抽象<br>    继承<br>    多态</p><p>C++的组成部分</p><p>标准的 C++ 由三个重要部分组成：<br>    核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。<br>    C++ 标准库，提供了大量的函数，用于操作文件、字符串等。<br>    标准模板库（STL），提供了大量的方法，用于操作数据结构等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一章-预备知识&quot;&gt;&lt;a href=&quot;#第一章-预备知识&quot; class=&quot;headerlink&quot; title=&quot;第一章 预备知识&quot;&gt;&lt;/a&gt;第一章 预备知识&lt;/h1&gt;&lt;p&gt;C++总览简介&lt;/p&gt;
&lt;p&gt;C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规</summary>
      
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习</title>
    <link href="http://example.com/2023/01/29/C-Primer-Plus-1/chapter02/"/>
    <id>http://example.com/2023/01/29/C-Primer-Plus-1/chapter02/</id>
    <published>2023-01-29T05:45:15.000Z</published>
    <updated>2023-01-30T10:50:27.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-开始学习-C"><a href="#第二章-开始学习-C" class="headerlink" title="第二章 开始学习 C++"></a>第二章 开始学习 C++</h1><p>（略）这一章很简单，无笔记。</p><p>C++用分号隔开每一个执行语句。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第二章-开始学习-C&quot;&gt;&lt;a href=&quot;#第二章-开始学习-C&quot; class=&quot;headerlink&quot; title=&quot;第二章 开始学习 C++&quot;&gt;&lt;/a&gt;第二章 开始学习 C++&lt;/h1&gt;&lt;p&gt;（略）这一章很简单，无笔记。&lt;/p&gt;
&lt;p&gt;C++用分号隔开每一个执</summary>
      
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习</title>
    <link href="http://example.com/2023/01/29/C-Primer-Plus-1/chapter04/"/>
    <id>http://example.com/2023/01/29/C-Primer-Plus-1/chapter04/</id>
    <published>2023-01-29T05:45:15.000Z</published>
    <updated>2023-01-30T10:50:55.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-复合类型"><a href="#第四章-复合类型" class="headerlink" title="第四章 复合类型"></a>第四章 复合类型</h1><p>本章很重要（特别是指针部分），需要掌握的内容为:</p><ul><li>创建和使用数组；</li><li>创建和使用C-风格字符串；</li><li>创建和使用 string 类字符串；</li><li>使用方法 getline() 和 get() 读取字符串；</li><li>混合输入字符串和数字；</li><li>创建和使用结构体；</li><li>创建和使用共用体；</li><li>创建和使用枚举类型；</li><li>创建和使用指针；</li><li>使用 new 和 delete 管理动态内存；</li><li>创建动态数组；</li><li>创建动态结构；</li><li>自动存储、静态存储和动态存储；</li><li>vector 和 array 类简介。</li></ul><h2 id="4-1-数组"><a href="#4-1-数组" class="headerlink" title="4.1 数组"></a>4.1 数组</h2><p>数组（array) 是一种数据格式，能够存储多个<strong>同类型</strong>的值。每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。</p><blockquote><p>即一个数组所在的内存区域是连续的。</p></blockquote><p>要创建数组，可使用声明语句。数组声明应指出以下三点： </p><ul><li>存储在每个元素中的值的类型； </li><li>数组名； </li><li>数组中的元素数。</li></ul><p>在C++中，通过在简单变量后面添加中括号（其中包含 元素数目）来完成数组声明。而数组中的每一个元素都看作是一个简单变量。声明数组的通用格式为 : </p><p><code>typeName arrayName[arraySize]</code></p><p>表达式arraySize指定元素数目，它必须是整型常数（如10）或const 值，也可以是常量表达式（如8 * sizeof（int）），即其中所有的值在编 译时都是已知的。具体说，arraySize不能是变量，变量的值是在程序 运行时设置的。如：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> months[<span class="number">12</span>];   <span class="comment">// 声明一个包含 12 个整数的数组</span></span><br></pre></td></tr></table></figure></div><p>C++ 通过使用下标来访问数组中的每一个元素，C++ 数据从0开始编号，数组总长度-1 是最后一个元素，如上：months[0] 为第一个元素，months[11] 是最后一个元素。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210721153711828.png"                      alt="image-20210721153711828"                ></p><h3 id="4-1-1"><a href="#4-1-1" class="headerlink" title="4.1.1"></a>4.1.1</h3><p>C++可以在声明语句中初始化数组，只需提供一个用逗号分隔的值列表（初始化列表），并将它们用花 括号括起即可。如 ：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> yamcosts[<span class="number">3</span>] = &#123;<span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure></div><p>如果没有初始化数组的值，则其元素值将是不确定的，这意味着元素的值为以前驻留在该内 存单元中的值。</p><blockquote><p>将sizeof运算符用于数组名，得到的将是整个数组 中的字节数。</p></blockquote><h3 id="4-1-2-数组的初始化规则"><a href="#4-1-2-数组的初始化规则" class="headerlink" title="4.1.2 数组的初始化规则"></a>4.1.2 数组的初始化规则</h3><p>只有在定义数组时才能使用初始化，此后就不能使用了，<strong>也不能将一个数组赋给另一个数组</strong>：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210721154858602.png"                      alt="image-20210721154858602"                ></p><blockquote><p>这个方式和 Python 完全不同，原因可能是 Python 以引用为基础赋值，C++此处则是值赋值，只能一个一个来（声明时除外）。</p></blockquote><p>但此后，仍然可以通过下标分别给数组中的元素赋值。注意，<strong>这里是赋值不再是初始化</strong>。</p><p>初始化数组时，提供的值可以少于数组的元素数目，编译器将把其他元素设置为 0。因此，将数组中所有的元素都初始化为0非常简单—只要显式地将第 一个元素初始化为0，然后编译器会自动将其他元素都初始化为0。</p><p><em>还有一种方法，如果初始化数组时方括号内（[ ]）为空，C++编译器将计算元素个 数。但这是很糟糕的做法，不提倡，不举例。</em></p><h3 id="4-1-3-C-11数组初始化方法"><a href="#4-1-3-C-11数组初始化方法" class="headerlink" title="4.1.3 C++11数组初始化方法"></a>4.1.3 C++11数组初始化方法</h3><p>数组以前就可使用列表初始化， 但C++11中的列表初始化新增了一些功能。</p><ul><li>首先，初始化数组时，可省略等号（&#x3D;）；</li><li>其次，可不在大括号内包含任何东西，这将把所有元素都设置为零；</li><li>第三，列表初始化禁止缩窄转换。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210721160721085.png"                      alt="image-20210721160721085"                ></p><p>在上述代码中，第一条语句不能通过编译，因为将浮点数转换为整 型是缩窄操作，即使浮点数的小数点后面为零。第二条语句也不能通过 编译，因为1122011超出了char变量的取值范围（这里假设char变量的长 度为8位）。第三条语句可通过编译，因为虽然112是一个int值，但它在 char变量的取值范围内。</p><h2 id="4-2-字符串"><a href="#4-2-字符串" class="headerlink" title="4.2 字符串"></a>4.2 字符串</h2><p>字符串是存储在内存的一片连续字节中的一系列字符，这里的<strong>连续</strong>是重点。<br>存储在连续字节中的一系列字符意味着可以将字符串存储在char数 组中，其中每个字符都位于自己的数组元素中。字符串提供了一种存储 文本信息的便捷方式。本章介绍两种处理字符串的方法：（1）C-风格字符串；（2）基于 string 类的方法。</p><p>C-风格字符串具有 一种特殊的性质：以空字符（null character）结尾，空字符被写作 \0， 其ASCII码为0，用来标记字符串的结尾。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210721161457763.png"                      alt="image-20210721161457763"                ></p><p>这两个数组都是char数组，但只有第二个数组是字符串，空字符对 C-风格字符串而言至关重要。C++有很多处理字符串的函数，其 中包括cout使用的那些函数。它们都逐个地处理字符串中的字符，直到 到达空字符为止。如果使用cout显示上面的cat这样的字符串，则将显示 前7个字符，发现空字符后停止。使用cout显示上面的dog数 组（它不是字符串），cout将打印出数组中的8个字母，并接着将内存 中随后的各个字节解释为要打印的字符，直到遇到空字符为止（因此不加空字符是C-风格字符串中极其危险的行为）。</p><p>有一种更好的、 将字符数组初始化为字符串的方法—只需使用一个用引号括起的字符串 即可，这种字符串被称为字符串常量（string constant）或字符串字面值 （string literal），如下所示：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210721162122919.png"                      alt="image-20210721162122919"                ></p><p>用引号括起来的字符串<strong>隐式</strong>地包括结尾的空字符，因此不用显式地包括它。</p><p>最需要注意的是，<strong>使用C-风格字符串，在确定存储字符串所需的最短数组时，别忘了+1，要将结尾的空字符计算在内</strong>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210721162704816.png"                      alt="image-20210721162704816"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210721162840015.png"                      alt="image-20210721162840015"                ></p><blockquote><p>这里的赋值改为：<code>char shirt_size[2] = &quot;S&quot;;</code>  才是正确的。</p></blockquote><h3 id="4-2-1-拼接字符串常量"><a href="#4-2-1-拼接字符串常量" class="headerlink" title="4.2.1 拼接字符串常量"></a>4.2.1 拼接字符串常量</h3><p>事实上，任何两个由空 白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。 因此，下面所有的输出语句都是等效的：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210721163221414.png"                      alt="image-20210721163221414"                ></p><p>注意，拼接时不会在被连接的字符串之间添加空格，第二个字符串 的第一个字符将紧跟在第一个字符串的最后一个字符（不考虑\0）后 面。第一个字符串中的\0字符将被第二个字符串的第一个字符取代。</p><h3 id="4-2-2-在数组中使用字符串"><a href="#4-2-2-在数组中使用字符串" class="headerlink" title="4.2.2 在数组中使用字符串"></a>4.2.2 在数组中使用字符串</h3><p>从程序清单4.2中可以学到什么呢？<br>首先，sizeof运算符指出整个数组的长度：15字节，但 strlen( )函数返回的是存储在数组中的字符串的长度，而不是数组本身的长度。<br>另外，strlen( ) 只计算可见的字符，而不把空字符计算在内。因此，对于Basicman，返回的值为8，而不是 9。如果cosmic是字符串，则要存储该字符串，数组的长度不能短于strlen（cosmic）+1。<br>由于name1和name2是数组，所以可以用索引来访问数组中各个字符。例如，该程序使用 name1[0]找到数组的第一个字符。另外，该程序将name2[3]设置为空字符。这使得字符串在第 3个字符后即结束，虽然数组中还有其他的字符（参见图4.3）。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210721164300455.png"                      alt="image-20210721164300455"                ></p><p>程序清单 4.2 使用 cin 暗含两个问题:</p><ul><li>遇到空格结束；</li><li>输入字符串长于目标数组。</li></ul><h3 id="4-2-3-字符串输入"><a href="#4-2-3-字符串输入" class="headerlink" title="4.2.3 字符串输入"></a>4.2.3 字符串输入</h3><p>cin是如何确定已完成字符串输入呢？由于不能通过键盘输入空字 符，因此cin需要用别的方法来确定字符串的结尾位置。cin使用空白 （空格、制表符和换行符）来确定字符串的结束位置，这意味着cin在 获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串 放到数组中，并自动在结尾添加空字符。</p><p>这个例子的实际结果是，cin把Alistair作为第一个字符串，并将它 放到name数组中。这把Dreeb留在输入队列中。当cin在输入队列中搜索 用户喜欢的甜点时，它发现了Dreeb，因此cin读取Dreeb，并将它放到 dessert数组中。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210721171126781.png"                      alt="image-20210721171126781"                ></p><p>另一个问题是，输入字符串可能比目标数组长（运行中没有揭示出 来）。像这个例子一样使用cin，确实不能防止将包含30个字符的字符 串放到20个字符的数组中的情况发生。</p><p>文章将这个问题的系统处理留到第 17 章，但下文也能解决。</p><h3 id="4-2-4-每次读取一行字符串输入"><a href="#4-2-4-每次读取一行字符串输入" class="headerlink" title="4.2.4 每次读取一行字符串输入"></a>4.2.4 每次读取一行字符串输入</h3><p>每次读取一个单词通常不是最好的选择。具体地说，需要采用面向行而不是面向单词的方法。istream中的类（如 cin）提供了一些面向行的类成员函数：<code>getline()</code> 和 <code>get()</code>。这两个函数都读取一 行输入，直到到达换行符（回车符）。区别是，<code>getline()</code> 将读入并丢弃换行符，而 <code>get()</code> 则将换行符保留在输入队列中。<strong>注意是还保留在输入流里，没有被读走！</strong></p><p>1．面向行的输入：getline( )</p><p>getline( )函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。通过 <code>cin.getline()</code> 调用。该函数有两个参数，第一个参数是存储输入行的数组名称，第二个参数是要读取的字符数。如果这个参数为20，则函数最多读取19个字符或者碰到换行符为止，并自动在结尾处添加空字符。如：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(array_name, <span class="number">20</span>);</span><br></pre></td></tr></table></figure></div><p>例子程序清单 4.4:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722004651618.png"                      alt="image-20210722004651618"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722004809212.png"                      alt="image-20210722004809212"                ></p><p>2．面向行的输入：get( )</p><p><code>iostream</code> 中的 <code>get()</code> 虽然和 <code>getline()</code> 类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但 get 将换行符保留在输入队列中，假设我们连续两次 调用 <code>get( )</code> 那么要注意了。</p><p>第一次调用后，换行符将被留在输入队列中，因此第二次调用时看到的第一个字符便是换行符，此时 <code>get()</code> 以为已经到达行尾了，而没有发现任何可读取的内容。<strong>如果不借助于帮助，<code>get()</code> 将不能跨过该换行符</strong>。</p><p>这时要用 <code>get()</code> 的另一种变体——不带任何参数，可读取下一个字符（即使是换行符），因此可以用它来处理换行符，为读取下一行输入做好准备。例子：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722005755295.png"                      alt="image-20210722005755295"                ></p><p>由于 <code>cin.get(name, ArSize)</code> 返回的还是 cin 对象，因此还可以合并起来调用：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(name, ArSize).<span class="built_in">get</span>();  <span class="comment">// 这样也能同时将末尾的换行符读走</span></span><br></pre></td></tr></table></figure></div><p>但风险就是，<strong>假如 ArSize 小于一行的字符数，那么调用 <code>get()</code> 后就会发生字符丢失</strong>。</p><p><code>getline()</code> 成员函数也同样可以合并调用连续读取字符串：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(name1, ArSize).<span class="built_in">getline</span>(name2, ArSize);</span><br></pre></td></tr></table></figure></div><p>这语句将把输入中 连续的两行分别读入到数组name1和name2 中，其效果与两次调用 <code>cin.getline()</code> 相同。</p><p>为什么要使用 <code>get()</code>，而不是 <code>getline()</code> 呢？<br>首先，老式实现没有 <code>getline()</code>。其次，<code>get()</code> 使输入更仔细。例如，假设用<code>get( )</code> 将一行读入数组中。<strong>如何知道停止读取的原因是由于已经读取了整行，而不是由于数组已填满呢？</strong> （getline，判断不了）， 查看下一个输入字符，如果是换行符，说明已读取了整行；否则，说明该行中还有其他输入。</p><p>总之， <code>getline()</code> 使用起来简单一些，但 <code>get( )</code> 使得检查错误更简单些。</p><p>3．空行和其他问题</p><p>当 <code>getline()</code> 或 <code>get()</code> 读取空行时，将发生什么情况？最初的做法是， 下一条输入语句将在前一条 <code>getline()</code> 或 <code>get()</code> 结束读取的位置开始读取； 但当前的做法是，当 <code>get()</code>（不是getline）读取空行后将设置失效位 （failbit）。这意味着接下来的输入将被阻断，要用 <code>cin.clear()</code> 的命令来恢复输入。</p><p>另一个潜在的问题是，输入字符串可能比分配的空间长。如果输入行包含的字符数比指定的多，则 <code>getline()</code> 和 <code>get()</code> 将把余下的字符留在输入队列中，<code>getline()</code> 还会设置失效位，并关闭后面的输入。</p><h3 id="4-2-5-混合输入字符串和数字"><a href="#4-2-5-混合输入字符串和数字" class="headerlink" title="4.2.5 混合输入字符串和数字"></a>4.2.5 混合输入字符串和数字</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722012337405.png"                      alt="image-20210722012337405"                ></p><p>清单程序4.6 的一个问题是：<br>当cin读取年份，将回 车键生成的换行符留在了输入队列中。后面的cin.getline( )看到换行符 后，将认为是一个空行，并将一个空字符串赋给address数组。解决之道 是，在读取地址之前先读取并丢弃换行符。这可以通过几种方法来完 成，其中包括使用没有参数的get( )和使用接受一个char参数的get( )。</p><p>也可以利用表达式cin&gt;&gt;year返回cin对象，将调用拼接起来：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(cin &gt;&gt; year).<span class="built_in">get</span>();  <span class="comment">// or (cin &gt;&gt; year).get(ch);</span></span><br></pre></td></tr></table></figure></div><h2 id="4-3-string-类简介"><a href="#4-3-string-类简介" class="headerlink" title="4.3 string 类简介"></a>4.3 string 类简介</h2><p><code>string</code> 类包含于头文件 <code>string</code> 并位于名称空间 <code>std</code> 中，使用起来比字符数组简单，它提供了将字符串作为一种数据类型的表示方法，符合 C++ 的风格。<br>string 类定义隐藏了字符串的数组性质，让我们能够像处理普通变量那样处理字符串。</p><p>在很多方面，使用 string 对象的方式和使用字符数组相同：</p><ul><li>可以使用 C-风格字符串来初始化 string 对象；</li><li>可以使用 cin 来将键盘输入存储到 string 对象中；</li><li>可以使用 cout 来显示 string 对象；</li><li>可以使用数组表示法来访问存储在 string 对象中的字符。</li></ul><p>string 对象和字符数组的主要区别是，可以将 string 对象声明为简单变量，而不是数组。</p><p>类设计让程序能够自动处理string的大小。例如，str1的声明创建一 个长度为0的 string 对象，但程序将输入读取到str1中时，将自动调整 str1 的长度。</p><p>这使得与使用数组相比，使用string对象更方便，也更安全。从理论上说，可以将char 数组视为一组用于存储一个字符串的 char 存储单元，而 string 类变量是一个表示字符串的实体。</p><h3 id="4-3-1-C-11字符串初始化"><a href="#4-3-1-C-11字符串初始化" class="headerlink" title="4.3.1 C++11字符串初始化"></a>4.3.1 C++11字符串初始化</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722141823630.png"                      alt="image-20210722141823630"                ></p><h3 id="4-3-2-string-赋值、拼接和附加"><a href="#4-3-2-string-赋值、拼接和附加" class="headerlink" title="4.3.2 string 赋值、拼接和附加"></a>4.3.2 string 赋值、拼接和附加</h3><p>string 可以如简单变量那般操作。比如，虽然不能将一个数组赋给另一个数组，但却可以将一个 string 对象赋给另一个 string 对象。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722142110617.png"                      alt="image-20210722142110617"                ></p><p>可以使用运算符 + 将两个string 对象合并起来，还可以使用运算符 +&#x3D; 将字符串附加到string对象的末尾。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;aa&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;bb&quot;</span>;</span><br><span class="line">string str3;</span><br><span class="line"></span><br><span class="line">str3 = str1 + str2;  <span class="comment">// 正确</span></span><br><span class="line">str3 += str1;        <span class="comment">// 正确</span></span><br><span class="line">str3 += <span class="string">&quot; cc&quot;</span>;       <span class="comment">// 一样正确</span></span><br></pre></td></tr></table></figure></div><h3 id="4-3-3-string类的其他操作"><a href="#4-3-3-string类的其他操作" class="headerlink" title="4.3.3 string类的其他操作"></a>4.3.3 string类的其他操作</h3><p>处理string对象的语法通常比使用C字符串函数简单，尤其是执行较为复杂的操作时。例如，对于下述操作：</p><p><code>str3 = str1 + str2;</code></p><p>使用C-风格字符串时，需要使用的函数如下：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(charr3, charr1);</span><br><span class="line"><span class="built_in">strcat</span>(charr3, charr2);</span><br></pre></td></tr></table></figure></div><p><code>strcpy()</code> 和  <code>strcat()</code> 函数包含在头文件 cstring 中。函数 <code>strcpy()</code> 将字符串复制到字符数组中，使用函数 <code>strcat()</code> 将字符串附加到字符数组末尾。<br>另外，使用字符数组时，<strong>总是存在目标数组过小，无法存储指定信息的危险</strong>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722143658095.png"                      alt="image-20210722143658095"                ></p><p>函数strcat( )试图将全部12个字符复制到数组site中，这将覆盖相邻的内存。这可能导致程序终止，或者程序继续运行，但数据被损坏。<strong>string类具有自动调整大小的功能，从而能够避免这种问题发生</strong>。</p><h3 id="4-3-4-string类I-x2F-O"><a href="#4-3-4-string类I-x2F-O" class="headerlink" title="4.3.4 string类I&#x2F;O"></a>4.3.4 string类I&#x2F;O</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722144341278.png"                      alt="image-20210722144341278"                ></p><p>在用户输入之前，该程序指出数组charr中的字符串长度为27，这比 该数组的长度要大。这里要两点需要说明。首先，为初始化的数组的内 容是未定义的；其次，函数strlen( )从数组的第一个元素开始计算字节 数，直到遇到空字符。在这个例子中，在数组末尾的几个字节后才遇到 空字符。对于未被初始化的数据，第一个空字符的出现位置是随机的， 因此您在运行该程序时，得到的数组长度很可能与此不同。</p><p>用户输入之前，str中的字符串长度为0。这是因为未被初始化的string对象的长度被自动设置为0。 <strong>这是和字符串数组不同的地方</strong>。</p><p>源代码中是将一行输入读取到string对象中的代码是：<code>getline(cin, str);</code>。这个 <code>getline()</code> 不是类方法，它将 cin 作为参数，指出去哪里查找输入，另外，也没有指出字符串长度 的参数，因为 <code>string</code> 对象将根据字符串的长度自动调整自己的大小。</p><h3 id="4-3-5-其他形式的字符串字面值"><a href="#4-3-5-其他形式的字符串字面值" class="headerlink" title="4.3.5 其他形式的字符串字面值"></a>4.3.5 其他形式的字符串字面值</h3><p>除char类型外，C++还有类型wchar_t；而C++11新 增了类型char16_t和char32_t。可创建这些类型的数组和这些类型的字符 串字面值。对于这些类型的字符串字面值，C++分别使用前缀L、u和U 表示，下面是一个如何使用这些前缀的例子：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722162656588.png"                      alt="image-20210722162656588"                ></p><p>C++11还支持Unicode字符编码方案UTF-8。<br>C++11新增的另一种类型是原始（raw）字符串，并使用前缀 R 来标识，原始字符表示的就是自己，例如，序列 <code>\n</code> 不表示换行符，而表示两个常 规字符—斜杠和n，因此在屏幕上显示时，将显示这两个字符。</p><h2 id="4-4-结构体简介"><a href="#4-4-结构体简介" class="headerlink" title="4.4 结构体简介"></a>4.4 结构体简介</h2><p><strong>结构体（Struct）</strong>是 一种比数组更灵活的数据格式，因为同一个结构体可以存储多种不同类型的数据，从而将数据的表示合并到一起。</p><blockquote><p>原文称 struct 为 “结构”，我认为这不符合一贯以来的称呼，因此在这个笔记中我一律改为通常在 <code>C/C++</code> 中所称呼的 “结构体”。</p></blockquote><p>结构体是用户定义的类型，而结构体声明定义了这种类型的数据属性。结构体的定义需要用 关键字 <strong>struct</strong> 做标识。 定义了类型后，便可以创建这种类型的变量。以下例子是一个结构体的定义，它使用了一个适合用于存储字符串的 char数组、一个float和一个double。列表中的每一项都被称为结构体成员，因此 infatable 结构体有3个成员（参见图4.6）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722163912443.png"                      alt="image-20210722163912443"                ></p><p>定义之后就可以将这个结构体当做常规的 C++ 数据类型（如同 int、double、string等）来使用。</p><p>在结构体类型中，可以通过使用成员运算符 <code>.</code> 来访问各个成员。</p><h3 id="4-4-1-在程序中使用结构体"><a href="#4-4-1-在程序中使用结构体" class="headerlink" title="4.4.1 在程序中使用结构体"></a>4.4.1 在程序中使用结构体</h3><p>结构声明的位置很重要。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722165020076.png"                      alt="image-20210722165020076"                ></p><p>结构体的初始化方式和数组一样，使用逗号分隔值列表，并将这些值用花括号括起。如:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722165157045.png"                      alt="image-20210722165157045"                ></p><p>花括号中每个值可以独占一行，也可以将他们都放在同一行中，注意变量之间有逗号隔开就行，其他的随意。</p><h3 id="4-4-2-C-11-结构体初始化"><a href="#4-4-2-C-11-结构体初始化" class="headerlink" title="4.4.2 C++11 结构体初始化"></a>4.4.2 C++11 结构体初始化</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722165537179.png"                      alt="image-20210722165537179"                ></p><h3 id="4-4-3-结构体可以将string类作为成员吗"><a href="#4-4-3-结构体可以将string类作为成员吗" class="headerlink" title="4.4.3 结构体可以将string类作为成员吗?"></a>4.4.3 结构体可以将string类作为成员吗?</h3><p>可以，只要编译器支持 string 类型就没问题，唯一要注意的问题注意添加名字空间 std 。 如:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722165802188.png"                      alt="image-20210722165802188"                ></p><h3 id="4-4-4-其他结构属性"><a href="#4-4-4-其他结构属性" class="headerlink" title="4.4.4 其他结构属性"></a>4.4.4 其他结构属性</h3><p>结构体和 C++ 内置类型的用法类似，它可以作为参数传递给函数，也可以让函数返回一个结构体。另外，<strong>还可以使用赋值运算符（&#x3D;）将结构体赋给另一个同类型的结构体</strong>，这样结构体中每个成员都将被设置为另一个结构中相应成员的值，即使成员是数组。这种赋值被称为成员赋值（memberwise assignment）。</p><p>结构体类型还可以同时完成定义结构体和创建结构体变量的工作，只需将变量名放在结束括号的后面即可：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722170446818.png"                      alt="image-20210722170446818"                ></p><p>但不推荐这样做，将结构体定义和变量声明分开，可以使程序更易于阅读和理解。</p><h3 id="4-4-5-结构体数组"><a href="#4-4-5-结构体数组" class="headerlink" title="4.4.5 结构体数组"></a>4.4.5 结构体数组</h3><p>创建结构体数组的方法和创建 C++ 基本类型的数组完全相同。</p><p>要初始化结构体数组，可以使用初始化数组的规则（用逗号分隔每个元素的值，并将这些值用花括号括起）和初始化结构体的规则（用逗号分隔每个成员的值，并将这些值用花括号括起）。由于数组中的每个 元素都是结构，因此可以使用结构初始化的方式来提供它的值。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722170912740.png"                      alt="image-20210722170912740"                ></p><h2 id="4-5-共用体"><a href="#4-5-共用体" class="headerlink" title="4.5 共用体"></a>4.5 共用体</h2><p>共用体（union），也叫联合体是一种数据格式，它能够存储不同的数据类型， 但只能同时存储其中的一种类型。也就是说，结构体可以同时存储 int、 long和double，共用体只能存储int、long或double。共用体的句法与结构相似，但含义不同。如：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722171406230.png"                      alt="image-20210722171406230"                ></p><p><strong>共用体每次只能存储一个值</strong>，因此它必须有足够的空间来存储最大的成员，所以，共用体的长度为其最大成员的。</p><p>共用体的用途之一是，当数据项使用两种或更多种格式（但不会同时使用）时，可节省内存空间，其实对当前内存充裕的计算机来说，并非很有必要使用共用体。</p><h2 id="4-6-枚举"><a href="#4-6-枚举" class="headerlink" title="4.6 枚举"></a>4.6 枚举</h2><p>这也是一个很少用的类型，略。<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722171825483.png"                      alt="image-20210722171825483"                ></p><h2 id="4-7-指针和自由存储空间"><a href="#4-7-指针和自由存储空间" class="headerlink" title="4.7 指针和自由存储空间"></a>4.7 指针和自由存储空间</h2><p>计算机在存储数据时必须跟踪的3种基本属性：</p><ul><li>信息存储在何处；</li><li>存储的值为多少；</li><li>存储的信息是什么类型。</li></ul><p>C++ 提供了一种策略，可以在程序内部跟踪内存单元，这个策略以指针为基础。C++ 中 <strong>指针是一个变量，其存储的是值的地址，而不是值本身</strong>。</p><p>首先，我们如何找到常规变量的地址？在C&#x2F;C++中只需对变量应用地址运算符 <code>&amp;</code>，就可以获得它的位置；例如，如果 <code>home</code> 是一个变量，则 <code>&amp;home</code> 是它在内存中的地址。</p><p><strong>使用常规变量时，值是指定的量，而地址为派生量</strong>。接下来看看指针策略，它是C++内存管理编程理念的核心。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722232030057.png"                      alt="image-20210722232030057"                ></p><p>指针处理存储数据的新策略刚好相反，<strong>指针将地址视为指定的量，而将值视为派生量</strong>，因此，指针名表示的是地址。<code>*</code> 运算符被称为<strong>间接值（indirect velue）或解除引用 （dereferencing）运算符</strong>，应用于指针得到该地址处所存储的值。例如，假设 <code>manly</code> 是一个指针，则 <code>manly</code> 表示的是一个地址，<code>*manly</code> 表示存储在该地址处的值，即 <code>*manly</code> 和常规变量等效。<strong>变量的指针和变量的值本身本质只不过是一个硬币的两个面</strong>。</p><blockquote><p>变量是编译时分配出来的一个有名称的内存，这是变量的实质。而指针是一个可以通过名称直接访问内存的别名，内存里存储的东西就是变量的值。</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722233255845.png"                      alt="image-20210722233255845"                ></p><h3 id="4-7-1-声明和初始化指针"><a href="#4-7-1-声明和初始化指针" class="headerlink" title="4.7.1 声明和初始化指针"></a>4.7.1 声明和初始化指针</h3><p>不同数据类型存储值时的内存格式不同，所以指针声明时必须 <strong>指定指针指向的数据类型</strong>，声明一个指针的通用方式:</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName *p_name;</span><br></pre></td></tr></table></figure></div><p><code>*</code> 符用于指明该变量是指针，每个指针变量声明时都需要带 <code>*</code>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210722233705755.png"                      alt="image-20210722233705755"                ></p><p>使用指针的时候要注意区分地址是地址，值是值。指针本身也是一种数据类型，它的值是地址，这个地址也有它自己的字节长度（由计算机系统内定），它的长度和它这个地址里存储的数值没有任何关系。指向 int 类型和指向 double 类型或者 string 类型的指针类型的字节长度都是一样的，它们都是地址。</p><h3 id="4-7-2-指针的危险"><a href="#4-7-2-指针的危险" class="headerlink" title="4.7.2 指针的危险"></a>4.7.2 指针的危险</h3><p><strong>创建指针时，计算机将分配用来存储指针这个变量本身的内存，但不会分配指针所指向的数据所需的内存</strong>。为数据提供空间是一个独立的步骤，如果忽略这一步麻烦就大了。如：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> *fellow;       <span class="comment">// 创建一个指向 long 类型的指针</span></span><br><span class="line">*fellow = <span class="number">223323</span>;   <span class="comment">// 指针还不知道指向哪个地址，就强制赋值，大错特错</span></span><br></pre></td></tr></table></figure></div><p>声明时，只是告诉程序 <code>fellow</code> 是一个 <code>long</code> 指针，程序只给 <code>fellow</code> 这个指针变量分配了一个属于 <code>fellow</code> 自己的存储空间，至于它里面要存什么地址值还完全不知道。必须先申请一个存 <code>long</code> 类型的地址空间，然后赋值给 <code>fellow</code>，最后才可以将 223323 赋值过去。 </p><blockquote><p>一定要在对指针应用解除引用运算符 <code>*</code> 之前，将指针初始化为一个确定的、适当的地址，这是关于使用指针的铁律。</p></blockquote><h3 id="4-7-3-指针和数字"><a href="#4-7-3-指针和数字" class="headerlink" title="4.7.3 指针和数字"></a>4.7.3 指针和数字</h3><p>指针不是整型，虽然计算机通常把地址当作整数来处理。在有些平台 中，int 类型是个2字节值，而地址是个4字节值。</p><h3 id="4-7-4-使用new来分配内存"><a href="#4-7-4-使用new来分配内存" class="headerlink" title="4.7.4 使用new来分配内存"></a>4.7.4 使用new来分配内存</h3><p>指针真正的用武之地在于，运行阶段分配未命名的内存用于存储值。C++ 通过 new 运算符为变量分配内存。</p><p>程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长 度正确的内存块，并返回该内存块的地址。程序员的责任是将该地址赋 给一个指针。下面是一个这样的示例：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pn = <span class="keyword">new</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure></div><p><code>new int</code> 告诉程序，需要适合存储 <code>int</code> 的内存。<code>new</code> 运算符根据类型来确定需要多少字节的内存。然后，它找到这样的内存，并返回其地址。 接下来，将地址赋给 <code>pn</code>，<code>pn</code> 是被声明为指向 <code>int</code> 的指针。现在，<code>pn</code> 是地址，而 <code>*pn</code> 是存储在那里的值。</p><p><strong>注意：<code>pn</code> 指向的内存不是变量（那是一个地址，是不变的），内存里存储的东西才是可变的。</strong></p><blockquote><p>这引出了一个问题：pn指向的内存没 有名称，如何称呼它呢？我们说pn指向一个数据对象，这里的“对象”不 是“面向对象编程”中的对象，而是一样“东西”。术语“数据对象”比“变 量”更通用，它指的是为数据项分配的内存块。</p></blockquote><p>为一个数据对象（可以是结构，也可以是基本类型）获得并指定分 配内存的通用格式如下：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName *pointer_name = <span class="keyword">new</span> typeName;</span><br></pre></td></tr></table></figure></div><p>需要指出的另一点是，<code>new</code> 分配的内存块通常与常规变量声明分配的内存块不同。常规变量存储在被称为栈 （stack）的内存区域中，而 <code>new</code> 从被称为堆（heap）或自由存储区（free store）的内存区域分配内存。</p><p>如果内存分配失败，<code>new</code> 运算符将返回空指针（null pointer），其值为 0。</p><h3 id="4-7-5-使用-delete-释放内存"><a href="#4-7-5-使用-delete-释放内存" class="headerlink" title="4.7.5 使用 delete 释放内存"></a>4.7.5 使用 delete 释放内存</h3><p><strong><code>delete</code> 运算符，用于将不再使用的内存归还给内存池</strong>，归还或释放（free）的内存可供程序的其他部分使用。使用 <code>delete</code> 时，后面要加上指向内存块的指针（这些内存块最初是用new分配的）。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ps = <span class="keyword">new</span> <span class="type">int</span>;   <span class="comment">// 声明指针并分配一个可以存 int 类型的内存给指针</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> ps;  <span class="comment">// 归还内存</span></span><br></pre></td></tr></table></figure></div><p>归还 ps 指向的内存，并不会删除指针 ps 本身，它可以继续用来指向新分配的内存。<br><strong><code>new</code> 和 <code>delete</code> 一定要配对使用，否则会导致程序发生内存泄露（memory leak）</strong>，即分配出去的内存拿不回来，无法再使用。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210723144325225.png"                      alt="image-20210723144325225"                ></p><p>另外，不要尝试释放已经释放的内存块，C++标准指出，这样做的结果将是不确定的，这意味着什么情况都可能发生。</p><blockquote><p>一般来说，不要创建两个指向同一个内存块的指针，因为这将增加 错误地删除同一个内存块两次的可能性。</p></blockquote><p>另外，不能使用 <code>delete</code> 释放声明变量所获得的内存，<strong>只能用它释放 <code>new</code> 分配的内存</strong>，这是关键点。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210723105004298.png"                      alt="image-20210723105004298"                ></p><h3 id="4-7-6-使用new来创建动态数组"><a href="#4-7-6-使用new来创建动态数组" class="headerlink" title="4.7.6 使用new来创建动态数组"></a>4.7.6 使用new来创建动态数组</h3><p>对于大型数据（如数组、字符串和结 构），应使用new，这正是new的用武之地。</p><p>在编译时给数组分配内存被称为静态联编（static binding），这就是为什么只能分配固定大小的数组。但使用 <code>new</code> 时，在运行阶段需要数组，则创建它；如果不需 要，则不创建，还可以选择数组的长度，这被称为动态联 编（dynamic binding），意味着数组是在程序运行时创建的。</p><p>1．使用 new 创建动态数组</p><p>创建动态数组很容易；只要将数组的元素类型和元素数 目告诉new即可。必须在类型名后加上方括号，其中包含元素数目。为数组分配内存的通用格式如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName *pointer_name = new typeName [num_elements];</span><br></pre></td></tr></table></figure></div><p>给个例子如：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *psome = <span class="keyword">new</span> <span class="type">int</span> [<span class="number">10</span>];  <span class="comment">// 分配可以存储 10 个 int 的内存块</span></span><br></pre></td></tr></table></figure></div><p><code>new</code> 返回第一个元素的地址，并将该地址被赋给指针 <code>psome</code>。</p><p>释放这一块内存时要这样做：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] psome;</span><br></pre></td></tr></table></figure></div><p>方括号告诉程序，应释放整个数组，而不仅仅是指针指向的元素。 <strong>注意delete和指针之间有方括号</strong>。对于 ANSI&#x2F;ISO标准来说，<code>new</code> 与 <code>delete</code> 的格式要匹配，否则导致的后果是不确定。</p><p>总之，使用new和delete时，应遵守以下规则：</p><ul><li>不要使用 <code>delete</code> 来释放不是 <code>new</code> 分配的内存；</li><li>不要使用 <code>delete</code> 释放同一个内存块两次；</li><li>如果使用 <code>new []</code> 为数组分配内存，则应使用 <code>delete []</code> 来释放；</li><li>如果使用 <code>new []</code> 为一个实体分配内存，则应使用 <code>delete</code>（没有方括 号）来释放(这一点要找例子来理解)；</li><li>对空指针应用 <code>delete</code> 是安全的。</li></ul><p>2．使用动态数组</p><p>创建动态数组后，如何使用它呢？<strong>只需要将指针名当做数组名，然后按照数组的访问方式即可</strong>，C&#x2F;C++ 中数组和指针是基本等价的（但也有实质区别，后续再说）。例子：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *psome = <span class="keyword">new</span> <span class="type">int</span> [<span class="number">10</span>];</span><br></pre></td></tr></table></figure></div><p>对于第1个元素，可以使用 <code>psome[0]</code>，而不是 <code>*psome</code>；对于第2个元 素，可以使用 <code>psome[1]</code>，依此类推。</p><p>程序清单4.18演示了如何使用new来创建动 态数组以及使用数组表示法来访问元素；它还指出了指针和真正的数组名之间的根本差别（注意红框）。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210723111823885.png"                      alt="image-20210723111823885"                ></p><p>将<code>p3</code> 加1导致它指向第2个元素而不是第1个。将它减1后，指针将指向原来的值，这样程序便可以给 <code>delete[]</code> 提供正确的地址。(这叫指针移动)</p><h2 id="4-8-指针、数组和指针算术"><a href="#4-8-指针、数组和指针算术" class="headerlink" title="4.8 指针、数组和指针算术"></a>4.8 指针、数组和指针算术</h2><p>指针算术是有特殊之处的。</p><p><strong>指针和数组基本等价的原因在于指针算术（pointer arithmetic）和 C++ 内部处理数组的方式</strong>。</p><blockquote><p>将整数变量加1 后，其值将增加1；但将指针变量加1后，增加的量等于它指向的类型的 字节数。将指向double的指针加1后，如果系统对double使用8个字节存 储，则数值将增加8；将指向short的指针加1后，如果系统对short使用2 个字节存储，则指针值将增加2。</p></blockquote><h3 id="4-8-1-程序说明"><a href="#4-8-1-程序说明" class="headerlink" title="4.8.1 程序说明"></a>4.8.1 程序说明</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210723112411334.png"                      alt="image-20210723112411334"                ></p><p><strong>将指针变量加1后，其增加的值等于指向的类型占用的字节数</strong>。 也就是跳到下一个存储值的地址上。</p><p>从该程序的输出可知，<code>*（stacks + 1）</code>和 <code>stacks[1]</code> 是等价的。同样， <code>*（stacks + 2）</code>和 <code>stacks[2]</code> 也是等价的。通常，使用数组表示法时，<code>C++</code> 都执行下面的转换：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayname[i] becomes *(arrayname + i)</span><br></pre></td></tr></table></figure></div><p>如果使用的是指针，而不是数组名，则C++也将执行同样的转换：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointername[i] becomes *(pointername + i)</span><br></pre></td></tr></table></figure></div><p>因此，在很多情况下，可以相同的方式使用指针名和数组名。也就是说，使用 <code>new</code> 来创建数组以及使用指针来访问不同的元素时，只要把指针当作数组名对待即可。</p><p><strong>【注意】数组名被解释为其第一个元素的地址，而对数组名应用地址运算符 时，得到的是整个数组的地址，区别很大。</strong></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210723113548998.png"                      alt="image-20210723113548998"                ></p><h3 id="4-8-2-指针小结"><a href="#4-8-2-指针小结" class="headerlink" title="4.8.2 指针小结"></a>4.8.2 指针小结</h3><p>1．声明指针<br>要声明指向特定类型的指针，请使用下面的格式：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeName *pointer_name;</span><br></pre></td></tr></table></figure></div><p>2．给指针赋值</p><p>应将内存地址赋给指针。可以对变量名应用 <code>&amp;</code> 地址运算符，来获得被命名的内存的地址，或 <code>new</code> 运算符返回未命名的内存的地址。</p><p>3．对指针解引用</p><p>对指针解引用意味着获得指针指向的值。<code>*</code> 是指针应用解引用或间接值运算符。</p><p>4．区分指针和指针所指向的值</p><p>如果 <code>pt</code> 是指向int的指针，则 <code>*pt</code> 不是指向 <code>int</code> 的指针，而是完全等同于 一个 <code>int</code> 类型的变量，<code>pt</code> 才是指针。</p><p>5．数组名</p><p>大多数情况下，C++将数组名视为数组的第一个元素的地址。一种例外情况是，将sizeof运算符用于数组名用时，此时将返回整个数组的长度（单位为字节）。</p><p>6．指针算术</p><p>C++允许将指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数，也就是移动到下一个存储值的地址。还可以将一个指针减去另一个指针，获得两个指针的差。后一种运算将得到一个整数，仅当两个指针指向同一个数 组（也可以指向超出结尾的一个位置）时，这种运算才有意义，这将得到两个元素的间隔。</p><p>7．数组的动态联编和静态联编</p><p>使用数组声明来创建数组时，将采用静态联编，即数组的长度在编 译时设置。<br>使用 <code>new[]</code> 运算符创建数组时，将采用动态联编（动态数组），即将在运行时为数组分配空间，其长度也将在运行时设置。使用完这种数组后，应使用 <code>delete []</code> 释放其占用的内存。</p><p>8．数组表示法和指针表示法</p><p>使用方括号数组表示法等同于对指针解引用。数组名和指针变量都是如此，因此对于指针和数组名，既可以使用 指针表示法，也可以使用数组表示法。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210723115130804.png"                      alt="image-20210723115130804"                ></p><h3 id="4-8-3-指针和字符串"><a href="#4-8-3-指针和字符串" class="headerlink" title="4.8.3 指针和字符串"></a>4.8.3 指针和字符串</h3><p>数组和指针的特殊关系可以扩展到C-风格字符串。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> flower[<span class="number">10</span>] = <span class="string">&quot;rose&quot;</span>;</span><br><span class="line">cout &lt;&lt; flower &lt;&lt; <span class="string">&quot;s are red.\n&quot;</span>;</span><br></pre></td></tr></table></figure></div><p>以上代码中，数组名是第一个元素的地址，因此cout语句中的flower是包含字符r 的 char 元素的地址。cout 对象认为 char 的地址是字符串的地址，因此它打 印该地址处的字符，然后继续打印后面的字符，直到遇到空字符 (\0)  为止。总之，如果给cout提供一个字符的地址，则它将从该字符开始打 印，直到遇到空字符为止。</p><p><strong>这意味着可以将指向char的指针变量作为cout的参数，因为它也是 char的地址。</strong><br>在C++中，用引号括起的字符串像数组名一样，也是第一个元素的地 址。这意味着对于数组中的字符串、用引号括起的字符串常量以及指针 所描述的字符串，处理的方式是一样的，都将传递它们的地址。与逐个 传递字符串中的所有字符相比，这样做的工作量确实要少。</p><blockquote><p>在 cout 和多数 C++ 表达式中，<code>char</code> 数组名、<code>char</code> 指针以及用引号括起的字符串常量都被解释为字符串第一个字符的地址。</p></blockquote><p>请不要使用字符串常量或未被初始化的指针来接收输入。为避免这 些问题，也可以使用std::string对象，而不是数组。</p><p>在将字符串读入程序时，应使用已分配的内存地址。该地址可以是数组名，也可以是使用new 初始化过的指针。</p><p>注意这段代码及其输出：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210723122618520.png"                      alt="image-20210723122618520"                ></p><p>一般来说，如果给cout提供一个指针，它将打印地址。但如果指针 的类型为 <code>char *</code>，则 cout将显示指向的字符串。如果要显示的是字符串的 地址，则必须将这种指针强制转换为另一种指针类型，如 <code>int *</code>（上面的 代码就是这样做的）。</p><p>经常需要将字符串放到数组中。初始化数组时，请使用&#x3D;运算符； 否则应使用strcpy( )或strncpy( )。应使用strcpy( )或strncpy( )，而不是赋值运算符来将字符串赋给数组。</p><blockquote><p>这是 C-风格 字符串的操作方式，C++ string 类型则并不需要如此，会简单得多，不用担心字符串会导致数 组越界，并可以使用赋值运算符而不是函数strcpy( )和strncpy( )。</p></blockquote><h3 id="4-8-4-使用-new-创建动态结构体"><a href="#4-8-4-使用-new-创建动态结构体" class="headerlink" title="4.8.4 使用 new 创建动态结构体"></a>4.8.4 使用 new 创建动态结构体</h3><p>在运行时创建数组优于在编译时创建数组，对于结构也是如此。通过使用new，可以创建动态结构。</p><p>将 new 用于结构体由两步组成：创建结构体和访问其成员。要创建结构体，需要同时使用结构体类型和 new。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inflatable *ps = <span class="keyword">new</span> inflatable;</span><br></pre></td></tr></table></figure></div><p>这将把足以存储inflatable结构的一块可用内存的地址赋给ps。这种 句法和C++的内置类型完全相同。</p><p>此时要访问结构体成员，需通过箭头成员运算符 <code>−&gt;</code>，它用于指向结构体的指针，就像点运算符可用于结构体名一样，如 <code>ps-&gt;price</code> 指向了结构体中的 price 成员。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210723134422484.png"                      alt="image-20210723134422484"                ></p><blockquote><p>如果结构标识符是结构名，则使用句点运算符；如果标识符是指向结构 的指针，则使用箭头运算符。</p></blockquote><p>另一种访问结构成员的方法是先对指针解引用。如果 <code>ps</code> 是指向结构的指针，则 <code>*ps</code> 就是被指向的值—结构本身。由于 <code>*ps</code> 是一个结构，因此 <code>(*ps).price</code> 是 该结构的 <code>price</code> 成员。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210723134903499.png"                      alt="image-20210723134903499"                ></p><h3 id="4-8-5-自动存储、静态存储和动态存储"><a href="#4-8-5-自动存储、静态存储和动态存储" class="headerlink" title="4.8.5 自动存储、静态存储和动态存储"></a>4.8.5 自动存储、静态存储和动态存储</h3><p>根据用于分配内存的方法，C++有3种管理数据内存的方式：自动存储、静态存储和动态存储（有时也叫作自由存储空间或堆）。在存在时间的长短方面，以这3种方式分配的数据对象各不相同。</p><ol><li>自动存储</li></ol><p>在函数内部定义的常规变量使用自动存储空间，被称为自动变量 （automatic variable），只在包含它的代码中有效，这意味着它们在所属的函数被调用时自动产生，在该函数结束时消亡。</p><p>自动变量通常存储在栈中。</p><ol start="2"><li>静态存储</li></ol><p>静态存储是整个程序执行期间都存在的存储方式。使变量成为静态 的方式有两种：一种是在函数外面定义它；另一种是在声明变量时使用 关键字 <code>static</code>。</p><ol start="3"><li>动态存储</li></ol><p><code>new</code> 和 <code>delete</code> 运算符提供了一种比自动变量和静态变量更灵活的方法。它们管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap）。该内存池同用于静态变量和自动变量的内存是分开的。</p><h2 id="4-9-类型组合"><a href="#4-9-类型组合" class="headerlink" title="4.9 类型组合"></a>4.9 类型组合</h2><p>指针数组，指向指针的指针，也叫二维指针可以用来创建动态二维数组，类型较为复杂。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210723150508488.png"                      alt="image-20210723150508488"                ></p><h2 id="4-10-数组的替代品"><a href="#4-10-数组的替代品" class="headerlink" title="4.10 数组的替代品"></a>4.10 数组的替代品</h2><p>STL 标准库中的模板类 <code>vector</code> 和 <code>array</code> 是数组的替代品。</p><h3 id="4-10-1-模板类-vector"><a href="#4-10-1-模板类-vector" class="headerlink" title="4.10.1 模板类 vector"></a>4.10.1 模板类 vector</h3><p>模板类 <code>vector</code> 类似于 <code>string</code> 类，也是一种动态数组，创建时要包含头文件 vector 。可以在运行阶段设置 <code>vector</code> 对象的长度，也可在末尾附加新数据，还可以在中间插入新数据，<code>vector</code> 的长度不要求必须设定，因为它会依据插入的数据量自动增长，容量增长的速度是 2 的 <code>n</code> 次方。</p><p>基本上，它是使用 <code>new</code> 创建动态数组的替代品。实际上，<code>vector</code> 类确实使用 <code>new</code> 和<code>delete</code> 来管理内存，但这种工作是自动完成的。</p><p><code>vector</code> 的声明方式：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function">vector&lt;typeName&gt; <span class="title">v_name</span><span class="params">(number)</span></span>;</span><br></pre></td></tr></table></figure></div><p>这样 v_name 就是一个 vector 对象，但 number 不是必须的。</p><p><code>vector</code> 的最完整文档和例子，应参照网站 <a class="link"   href="http://cplusplus.com/reference/vector/vector" >http://cplusplus.com/reference/vector/vector <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 。 </p><h3 id="4-10-2-模板类array（C-11）"><a href="#4-10-2-模板类array（C-11）" class="headerlink" title="4.10.2 模板类array（C++11）"></a>4.10.2 模板类array（C++11）</h3><p><code>vector</code> 类的功能比数组强大，但付出的代价是效率稍低（其实没那么低效）。如果您需 要的是长度固定的数组，使用数组是更佳的选择，但代价是不那么方便 和安全。有鉴于此，C++11 新增了模板类 <code>array</code>，它也位于名称空间 <code>std</code> 中。与数组一样，<code>array</code> 对象的长度也是固定的，也使用栈（静态内存分 配），而不是自由存储区，因此其效率与数组相同，但更方便，更安全。</p><p>要创建array对象，需要包含头文件array。array对象的创建语法与 vector稍有不同：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line">array&lt;typeName, num_element&gt; arr;</span><br></pre></td></tr></table></figure></div><p>与创建 <code>vector</code> 对象不同的是，n_element 不能是变量，必须是固定的常量和普通数组要求一样。</p><blockquote><p>通过 <code>array</code> 模板类创建数组有什么优势？</p></blockquote><p><a class="link"   href="https://cplusplus.com/reference/array/array" >https://cplusplus.com/reference/array/array <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p><h3 id="4-10-3-比较数组、vector-对象和-array-对象"><a href="#4-10-3-比较数组、vector-对象和-array-对象" class="headerlink" title="4.10.3 比较数组、vector 对象和 array 对象"></a>4.10.3 比较数组、vector 对象和 array 对象</h3><p>这三者的异同是什么？</p><p>首先，无论是数组、<code>vector</code> 对象还是 <code>array</code> 对象，都可使用标 准数组表示法来访问各个元素；</p><p>其次，从地址可知，<code>array</code> 对象和数组存 储在相同的内存区域（即栈）中，而<code>vector</code> 对象存储在另一个区域（自由存储区或堆）中；</p><p>第三，<strong>可以将一个 <code>array</code> 对象直接赋给另一个 <code>array</code> 对象，而标准数组，必须逐元素复制数据</strong> (使用 array 模板类的两个好处之一，另一个好处是控制数组超界风险)。</p><p>例子：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210723153517389.png"                      alt="image-20210723153517389"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210723160219245.png"                      alt="image-20210723160219245"                ></p><p>在上面代码中注意一个语句：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1[<span class="number">-2</span>] = <span class="number">20.2</span>;</span><br></pre></td></tr></table></figure></div><p>这是什么意思？这个语句会被转换为：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(a1 - <span class="number">2</span>) = <span class="number">20.2</span>;</span><br></pre></td></tr></table></figure></div><p>含义是：找到a1指向的地方，向前移两个double元素，并将 20.2存储到目的地。也就是说，将信息存储到数组的外面。<strong>与C语言一 样，C++也不检查这种超界错误</strong>，也就是说数组的这种行为是不安全的，C++ 却不禁止，要小心。</p><p><code>vector</code> 和 <code>array</code> 对象能够禁止这种行为吗？如果您让它们禁止，它们 就能禁止。另外，这 些类还让您能够降低意外超界错误的概率。例如，它们包含成员函数 <code>begin()</code> 和 <code>end()</code>，让您能够确定边界，以免无意间超界。</p><h2 id="4-11-总结"><a href="#4-11-总结" class="headerlink" title="4.11 总结"></a>4.11 总结</h2><p>数组、结构体和指针是C++的3种复合类型。</p><p>数组可以在一个数据对 象中存储多个同种类型的值。通过使用索引或下标，可以访问数组中各 个元素。</p><p>结构体可以将多个不同类型的值存储在同一个数据对象中，可以使用成员关系运算符<code>.</code> 来访问其中的成员。使用结构体的第一步是创建结构体模板，它定义结构存储了哪些成员。<strong>模板的名称将成为新类型的标识符，然后就可以声明这种类型的结构变量</strong>。</p><p>指针是被设计用来存储地址的变量，指针指向它存储的地 址。指针声明指出了指针指向的对象的类型。对指针应用解引用运算符 <code>*</code>，将得到指针指向的位置中的值。</p><p>字符串是以空字符为结尾的一系列字符。字符串可用引号括起的字 符串常量表示，其中隐式包含了结尾的空字符。可以将字符串存储在 char数组中，可以用被初始化为指向字符串的char指针表示字符串。</p><p><code>string</code> 对象将根据要存储的字符串自动调整其 大小，用户可以使用赋值运算符来复制字符串。</p><p><code>new</code> 运算符允许在程序运行时为数据对象请求内存。该运算符返回 获得内存的地址，可以将这个地址赋给一个指针，程序将只能使用该指 针来访问这块内存。使用解引用运算符 <code>*</code> 获得其值；如果数据对象是数组，则可以像使用数组名那样使用指针来访问元素；如果数据对象是结构体，则可以用指针解引用运算符 <code>-&gt;</code> 访问其成员。</p><p>指针和数组紧密相关。如果 <code>ar</code> 是数组名，则表达式 <code>ar[i]</code> 被解释为  <code>*(ar + i)</code>（ <code>i</code> 可以是负值，表示指针左移），其中数组名被解释为数组第一个元素的地址。这样，数组名的作用和指针相同。反过来，可以使用数组表示法，通过指针名来访 问new分配的数组中的元素。</p><p>运算符 <code>new</code> 和 <code>delete</code> 允许显式控制何时给数据对象分配内存，何时将内存归还给内存池。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第四章-复合类型&quot;&gt;&lt;a href=&quot;#第四章-复合类型&quot; class=&quot;headerlink&quot; title=&quot;第四章 复合类型&quot;&gt;&lt;/a&gt;第四章 复合类型&lt;/h1&gt;&lt;p&gt;本章很重要（特别是指针部分），需要掌握的内容为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建和使用数组；</summary>
      
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习</title>
    <link href="http://example.com/2023/01/29/C-Primer-Plus-1/chapter03/"/>
    <id>http://example.com/2023/01/29/C-Primer-Plus-1/chapter03/</id>
    <published>2023-01-29T05:45:15.000Z</published>
    <updated>2023-01-30T10:50:47.545Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-处理数据"><a href="#第三章-处理数据" class="headerlink" title="第三章 处理数据"></a>第三章 处理数据</h1><p><strong>面向对象编程（OOP）的本质是设计并扩展自己的数据类型。设计自己的数据类型就是让类型与数据匹配。</strong></p><p>内置的C++类型分两组：基本类型和复合类型。本章将介绍基本类型，即整数和浮点数。似乎只有两种类型，但C++知道，没有任何一种整型和浮点型能够满足所有的编程要求，因此对于这两种数据，它提供 了多种变体。</p><h2 id="3-1-简单变量"><a href="#3-1-简单变量" class="headerlink" title="3.1 简单变量"></a>3.1 简单变量</h2><p>把信息存储在计算机中，程序必须记录3个基本属性：</p><ul><li>信息将存储在哪里； </li><li>要存储什么值； </li><li>存储何种类型的信息。</li></ul><p>实际上，程序将找到一块能够存储整数的内存，将该内存单元标记为braincount，并将5复制到该内存单元中；然 后，您可在程序中使用braincount来访问该内存单元。</p><blockquote><p>可以使用&amp;运算符来检索braincount的内存地址。</p></blockquote><h3 id="3-1-1-变量名"><a href="#3-1-1-变量名" class="headerlink" title="3.1.1 变量名"></a>3.1.1 变量名</h3><p>C++ 提倡使用有一定含义的变量名，并遵循几 种简单的 C++ 命名规则：</p><ul><li>在名称中只能使用字母字符、数字和下划线 ( _ )；</li><li>名称的第一个字符不能是数字；</li><li>区分大写字符与小写字符；</li><li>不能将C++关键字用作名称；</li><li>以<em>两个下划线</em> 或 <em>下划线+大写字母</em> 打头的名称被保留给实现（编译器及其使用的资源）使用；</li><li>以 <em>一个下划线</em> 开头的名称被保留给实现，用作全局标识符；</li></ul><p>C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制。</p><blockquote><p>倒数第二点与前面几点有些不同，因为使用像 __time_stop 或 _Donut 这样的名称不会导致编译器错误，而会导致行为的不确定性。换句话说，不知道结果将是什么。不出现编译器错误的原因是，这样的名称不 是非法的，但要留给实现使用。</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719213322578.png"                      alt="image-20210719213322578"                ></p><p>如果想用两个或更多的单词组成一个名称，通常的做法是用下划线字符将单词分开，如 my_onions (<strong>用这类</strong>)；或者从第二个单词开始将每个单词的第一个字母大写，如 myEyeTooth。</p><p><strong>在 C++ 所有主观的风格中，一致性和精度是最重要的</strong>。请根据自己的需要、喜好和个人风格来使用变量名（或必要时，根据雇主的需要、喜好和个人风格来选择变量名）。</p><h3 id="3-1-2-整型"><a href="#3-1-2-整型" class="headerlink" title="3.1.2 整型"></a>3.1.2 整型</h3><p>不同C++整型使用不同的内存量来存储整数。使用的内存量越大，可以表示的整数值范围也越大。</p><p>C++的基本整型（按宽度递增的顺序排列）分别是char、short、int、long和C++11新增的long long，其中每种类型都有符号版本和无符号版本，因此总共有10种类型可供选择。</p><h3 id="3-1-3-整型short、int、long和long-long"><a href="#3-1-3-整型short、int、long和long-long" class="headerlink" title="3.1.3 整型short、int、long和long long"></a>3.1.3 整型short、int、long和long long</h3><p>C++ 的short、int、long和long long类型通过使用不同数目的位来存储值，最多能够表示4种不同的整数宽度：</p><ul><li>short至少16位；</li><li>int至少与short一样长；</li><li>long 至少32位，且至少与int一样长；</li><li>long long至少64位，且至少与long一样长。</li></ul><blockquote><p>这意味着可以把16位单元设置成65 536个不同的值，把 32位单元设置成4 294 672 296个不同的值，把64位单元设置为18 446 744 073 709 551 616个不同的值。作为比较，unsigned long存储不了地球上当前的人数和银河系的星星数，而long long 能够。</p></blockquote><p>当前很多系统都使用最小长度，即short为16位，long为32位。这仍然为int提供了多种选择，其宽度可以是16位、24位或32位，同时又符合标准；甚至可以是64位，因为long和long long至少长64位。</p><blockquote><p>类型的宽度随实现而异，这可能在将C++程序从一种环境移到另一种环境（包括在同一个系统中使用不同编译器）时引发问题。</p></blockquote><p>首先，sizeof运算符返回类型或变量的长度；其次，头文件climits（在老式实现中为limits.h）中包含了关于整型限制的信息。具体地说，它定义了表示各种限制的符号名称。例如，INT_MAX为int的最大取值，CHAR_BIT为字节的位数。</p><p>在我的 Macbook Air 64位 OS 上，数据类型是这样的: </p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int is 4 bytes.</span><br><span class="line">short is 2 bytes.</span><br><span class="line">long is 8 bytes.</span><br><span class="line">long long is 8 bytes.</span><br><span class="line"></span><br><span class="line">Maximum values:</span><br><span class="line">int: 2147483647</span><br><span class="line">short: 32767</span><br><span class="line">long: 9223372036854775807</span><br><span class="line">long long: 9223372036854775807</span><br><span class="line"></span><br><span class="line">Minimum int value = -2147483648</span><br><span class="line">Bits per byte = 8</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719215348315.png"                      alt="image-20210719215348315"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719215405073.png"                      alt="image-20210719215405073"                ></p><p><strong>赋值与声明合并在一起叫做初始化。</strong>如果知道变量的初始值应该是什么，则应对它进行初始化。</p><p>如果不对函数内部定义的变量进行初始化，该变量的值将是不确定的。这意味着该变量的值 将是它被创建之前，相应内存单元保存的值。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719215954131.png"                      alt="image-20210719215954131"                ></p><h3 id="3-1-4-无符号类型"><a href="#3-1-4-无符号类型" class="headerlink" title="3.1.4 无符号类型"></a>3.1.4 无符号类型</h3><p>要创建无符号版 本的基本整型，只需使用关键字 unsigned 来修改声明即可。注意，unsigned本身是unsigned int的缩写。</p><h3 id="3-1-5-选择整型类型"><a href="#3-1-5-选择整型类型" class="headerlink" title="3.1.5 选择整型类型"></a>3.1.5 选择整型类型</h3><p>通常，int被设置为对 目标计算机而言最为“自然”的长度。自然长度（natural size）指的是计 算机处理起来效率最高的长度。如果没有非常有说服力的理由来选择其 他类型，则应使用int。</p><p>如果知道变量可能表示的整数值大于16位整数的最大可能值，则使用long。即使系统上int为32位，也应这样做。这样，将程序移植到16位系统时，就不会突然无法正常工作（参见图3.2）。如果要存储的值超过20亿，可使用long long。</p><blockquote><p>所以对于基因组数据上的位置信息，最好是 long 类型咯，即便 unsigned int 类型已经足够。（不过我可能还是希望用 unsigned int ）</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719220858422.png"                      alt="image-20210719220858422"                ></p><p>如果short比int小，则使用short可以节省内存。通常，仅当有大型整 型数组时，才有必要使用short。如果只需要一个字节，可使用char。</p><h3 id="3-1-6-整型字面值"><a href="#3-1-6-整型字面值" class="headerlink" title="3.1.6 整型字面值"></a>3.1.6 整型字面值</h3><p>整型字面值（常量）是显式地书写的常量，如212或1776。</p><blockquote><p>诸如cout&lt;&lt;hex;等代码不会在屏幕上显示任何内容，而只是修改 cout显示整数的方式。因此，控制符hex实际上是一条消息，告诉cout采 取何种行为。另外，由于标识符hex位于名称空间std中，而程序使用了 该名称空间，因此不能将hex用作变量名。然而，如果省略编译指令 using，而使用std::cout、std::endl、std::hex和std::oct，则可以将hex用作 变量名。</p></blockquote><h3 id="3-1-7-C-如何确定常量的类型"><a href="#3-1-7-C-如何确定常量的类型" class="headerlink" title="3.1.7 C++如何确定常量的类型"></a>3.1.7 C++如何确定常量的类型</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719221757664.png"                      alt="image-20210719221757664"                ></p><h3 id="3-1-8-char类型：字符和小整数"><a href="#3-1-8-char类型：字符和小整数" class="headerlink" title="3.1.8 char类型：字符和小整数"></a>3.1.8 char类型：字符和小整数</h3><p>char类型是专为存 储字符（如字母和数字）而设计的。</p><p>char类型是另一种整型。实际上，很多系统支持的字符都不超过128个，因此用一个字节就可以表示所有的符号。因此，虽然char最常被用来处理字符，但也可以 将它用做比short更小的整型。</p><p>C++对字符用单引号，对字符串使用双引号。 cout对象能够处理这两种情况，但正如第4章将讨论的，这两者有天壤之别）。</p><p>与int不同的是，char在默认情况下既不是没有符号，也不是有符号。是否有符号由C++实现决定，这样编译器开发人员可以最大限度地将这种类型与硬件属性匹配起来。如果char有某种特定的行为对您来说 非常重要，则可以显式地将类型设置为signed char 或unsigned char。</p><p>如果将char用作数值类型，则unsigned char和signed char之间的差异将非常重要。unsigned char类型的表示范围通常为0～255，而signed char 的表示范围为−128到127。</p><blockquote><p>例如，假设要使用一个char变量来存储像200这样大的值，则在某些系统上可以，而在另一些系统上可能不可以。但 使用unsigned char可以在任何系统上达到这种目的。</p></blockquote><p>如果大型字符 集是实现的基本字符集(如中文日文系统)，则编译器厂商可以将char定义为一个16位的字节或更长的字节。其次，一种实现可以同时支持一个小型基本字符集和 一个较大的扩展字符集。8位char可以表示基本字符集，另一种类型 wchar_t（宽字符类型）可以表示扩展字符集。wchar_t类型是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集。这种类 型与另一种整型（底层（underlying）类型）的长度和符号属性相同。对底层类型的选择取决于实现，因此在一个系统中，它可能是unsigned short，而在另一个系统中，则可能是int。</p><h2 id="3-2-const-限定符"><a href="#3-2-const-限定符" class="headerlink" title="3.2 const 限定符"></a>3.2 const 限定符</h2><p>C++有一种比 <code>#define</code> 更好的处理符号常量的方法，这种方法就是使用 const 关键字来修改变量声明和初始化。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Months = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></div><p>常量（如Months）被初始化后，其值就被固定 了，编译器将不允许再修改该常量的值。如果您这样做，g++将指出程 序试图给一个只读变量赋值。关键字const叫做限定符，因为它限定了声 明的含义。</p><blockquote><p>#define 定义符号常量的方式应抛弃。</p></blockquote><p>一种常见的做法是将名称的首字母大写，以提醒您Months是个常量。这决不是一种通用约定，但在阅读程序时有助于区分常量和变量。另一种约定是将整个名称大写，使用#define创建常量时通常使用这种约定。</p><p><strong>注意：</strong> 如果在声明常量时没有提供值，则该常量的值将是不确定的，且无 法修改。</p><h2 id="3-3-浮点数"><a href="#3-3-浮点数" class="headerlink" title="3.3 浮点数"></a>3.3 浮点数</h2><p>使用浮点类型可以表示诸如2.5、3.14159和122442.32这样的数字，即带小数部分的数字。计算机将这样的值分成两部分存储。一部分表示值，另一部分用于对值进行放大或缩小。下面打个比方。对于数字34.1245和34124.5，它们除了小数点的位置不同外，其他都是相同的。 可以把第一个数表示为0.341245（基准值）和100（缩放因子），而将第二个数表示为0.341245（基准值相同）和10000（缩放因子更大）。缩放因子的作用是移动小数点的位置，术语浮点因此而得名。C++内部表示浮点数的方法与此相同，只不过它基于的是二进制数，因此缩放因 子是2的幂，不是10的幂。</p><h3 id="3-3-1-书写浮点数"><a href="#3-3-1-书写浮点数" class="headerlink" title="3.3.1 书写浮点数"></a>3.3.1 书写浮点数</h3><p>C++有两种书写浮点数的方式：</p><ul><li>第一种是使用常用的标准小数点表示法；</li><li>第二种表示浮点值的方法叫做E表示法，其外观是像这样的： 3.45E6，这指的是3.45与1000000相乘的结果；E6指的是10的6次方，即 1后面6个0。因此，3.45E6表示的是3450000，6被称为指数，3.45被称为 尾数。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719225234354.png"                      alt="image-20210719225234354"                ></p><p>E表示法确保数字以浮点格式存储，即使没有小数点。注意，既可 以使用E也可以使用e，指数可以是正数也可以是负数，不要有空格。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719224852195.png"                      alt="image-20210719224852195"                ></p><blockquote><p>电子的质量是 9.11e-31 kg 表示 0.000000000000000000000000000000911 kg， 而美国报警电话 911 竟然很巧合地与此相同。</p></blockquote><h3 id="3-3-2-浮点类型"><a href="#3-3-2-浮点类型" class="headerlink" title="3.3.2 浮点类型"></a>3.3.2 浮点类型</h3><p>C++也有3种浮点类型：float、double 和 long double。</p><p>事实上，C和C++对于有效位数的要求是，float至少32位，double至少48位，且不少于float，long double至少和double一样多。这三种类型的有效位数可以一样多。然而，通常，float为32位，double为64位， long double为80、96或128位。另外，这3种类型的指数范围至少是−37到37。可以从头文件cfloat或float.h中找到系统的限制。</p><h3 id="3-3-3-浮点常量"><a href="#3-3-3-浮点常量" class="headerlink" title="3.3.3 浮点常量"></a>3.3.3 浮点常量</h3><p>在默认情况下，像8.24和2.4E8这样的浮点常量都属于double类型。如果希望常量为float类型，请使用f或F后缀。对于long double类型，可使用l或L后缀（由于l看起来像数字1，因此L是更好的选择）。</p><h3 id="3-3-4-浮点数的优缺点"><a href="#3-3-4-浮点数的优缺点" class="headerlink" title="3.3.4 浮点数的优缺点"></a>3.3.4 浮点数的优缺点</h3><p>与整数相比，浮点数有两大优点。首先，可以表示整数之间的 值。其次，由于有缩放因子，它们可以表示的范围大得多。另一方面， <strong>浮点运算的速度通常比整数运算慢，且精度将降低</strong>。</p><p>如: 2.34E+22是一个小数点左边有23位的数字。加上1，就 是在第23位加1。但float类型只能表示数字中的前6位或前7位，因此修改第23位对这个值不会有任何影响。</p><h2 id="3-4-C-算术运算符"><a href="#3-4-C-算术运算符" class="headerlink" title="3.4 C++算术运算符"></a>3.4 C++算术运算符</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719230134697.png"                      alt="image-20210719230134697"                ></p><p><code>11.17 + 50.25</code> 应等于61.42，但是输出的却是61.419998。这不是运算问题，而是由于float类型表示有效位数的能力有限。记住，对于float，C++只保证6位有效位。如果将 61.419998四舍五入成6位，将得到61.4200，这是在保证精度下的正确值，如果用double 则精度足够，所以直接可以获得 61.42 的值。</p><blockquote><p>通常来说 double 都比 float 更精准，应尽量使用 double。</p></blockquote><h3 id="3-4-1-运算符优先级和结合性"><a href="#3-4-1-运算符优先级和结合性" class="headerlink" title="3.4.1 运算符优先级和结合性"></a>3.4.1 运算符优先级和结合性</h3><p>算术运算符遵 循通常的代数优先级，先乘除，后加减。</p><h3 id="3-4-2-除法分支"><a href="#3-4-2-除法分支" class="headerlink" title="3.4.2 除法分支"></a>3.4.2 除法分支</h3><p>除法运算符（&#x2F;）的行为取决于操作数的类型。如果两个操作数都 是整数，则C++将执行整数除法。这意味着结果的小数部分将被丢弃， 使得最后的结果是一个整数。<strong>如果其中有一个（或两个）操作数是浮点 值，则小数部分将保留，结果为浮点数</strong>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719230953958.png"                      alt="image-20210719230953958"                ></p><p><strong>浮点常量在默认情况下为 double类型。</strong></p><h3 id="3-4-3-求模运算符"><a href="#3-4-3-求模运算符" class="headerlink" title="3.4.3 求模运算符"></a>3.4.3 求模运算符</h3><p>求模运算符返回整数除法的余数。它与整数除 法相结合，尤其适用于解决要求将一个量分成不同的整数单元的问题。</p><h3 id="3-4-4-类型转换"><a href="#3-4-4-类型转换" class="headerlink" title="3.4.4 类型转换"></a>3.4.4 类型转换</h3><p>由于有11种整型和3种浮点类型，因此计算机需 要处理大量不同的情况，C++自动执行很多类型转换：</p><ul><li>将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进 行转换； </li><li>表达式中包含不同的类型时，C++将对值进行转换；</li><li>将参数传递给函数时，C++将对值进行转换。</li></ul><p>C++允许将一种类型的值赋给另一种类型的变量。这样做时，值将 被转换为接收变量的类型。例如，假设so_long的类型为long，thirty的类 型为short。</p><p>将一个值赋给值取值范围更大的类型通常不会导致什么问题。如，将short值赋给long变量并不会改变这个值，只是占用的字节更多而 已。然而，将一个很大的long值（如2111222333）赋给float变量将降低 精度。因为float只有6位有效数字，因此这个值将被四舍五入为 2.11122E9。因此，有些转换是安全的，有些则会带来麻烦。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719232005071.png"                      alt="image-20210719232005071"                ></p><p>如下的报错是一个可能:</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719232233106.png"                      alt="image-20210719232233106"                ></p><p>将0赋给bool变量时，将被转换为false；而非零值将被转换为true。</p><p>当同一个表达式中包含两种不同的算术类型时，将出现什么情况 呢？在这种情况下，C++将执行两种自动转换：首先，一些类型在出现 时便会自动转换；其次，有些类型在与其他类型同时出现在表达式中时 将被转换。</p><ul><li>在计算表达式时，C++将bool、char、unsigned char、signed char和short值转换为int。具体地说，true被转换为1，false 被转换为0。这些转换被称为整型提升（integral promotion）。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719232513015.png"                      alt="image-20210719232513015"                ></p><blockquote><p>int 是一种最自然的类型，运算速度也最快，要主用。</p></blockquote><ul><li><p>同样，wchar_t被提升成为下列类型中第一个宽度足够存储wchar_t 取值范围的类型：int、unsigned int、long或unsigned long。</p></li><li><p>将不同类型进行算术运算时，也会进行一些转换，例如将int和float 相加时。<strong>当运算涉及两种类型时，较小的类型将被转换为较大的类型。</strong></p></li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719232833549.png"                      alt="image-20210719232833549"                ></p><ul><li>传递参数时的类型转换通常由C++函数原型控制。</li><li>C++还允许通过强制类型转换机制显式地进行类型转换。强制类型转换 的格式有两种。如下：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719233243273.png"                      alt="image-20210719233243273"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719233319788.png"                      alt="image-20210719233319788"                ></p><p><strong>新格式的想法 是，要让强制类型转换就像是函数调用。这样对内置类型的强制类型转换就像是为用户定义的类设计的类型转换。</strong></p><p>更安全的转换方式是使用 <code>static_cast&lt;typeName&gt; (value)</code> 函数。</p><p>Stroustrup认为，C语言式的强制类型转换由于有过多的可能性而极 其危险，这将在第15章更深入地讨论。运算符 <code>static_cast&lt;&gt;</code> 比传统强制 类型转换更严格。</p><h3 id="3-4-5-C-11中的auto声明"><a href="#3-4-5-C-11中的auto声明" class="headerlink" title="3.4.5 C++11中的auto声明"></a>3.4.5 C++11中的auto声明</h3><p>在初始化声明中，如果 使用关键字auto，而不指定变量的类型，编译器将把变量的类型设置成 与初始值相同。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719234008239.png"                      alt="image-20210719234008239"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210719234059088.png"                      alt="image-20210719234059088"                ></p><h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5 总结"></a>3.5 总结</h2><p>C++的基本类型分为两组：一组由存储为整数的值组成，另一组由存储为浮点格式的值组成。整型之间通过存储值时使用的内存量及有无符号来区分。整型从最小到最大依次是：bool、char、signed char、 unsigned char、short、unsigned short、int、unsigned int、long、unsigned long以及C++11新增的long long和unsigned long long。还有一种wchar_t 类型，它在这个序列中的位置取决于实现。C++11新增了类型char16_t 和char32_t，它们的宽度足以分别存储16和32位的字符编码。C++确保了char足够大，能够存储系统基本字符集中的任何成员，而wchar_t则可以存储系统扩展字符集中的任意成员，short至少为16位，而int至少与short一样长，long至少为32位，且至少和int一样长。确切的长度取决于 实现。</p><p>浮点类型可以表示小数值以及比整型能够表示的值大得多的值。3种浮点类型分别是float、double和long double。C++确保float不比double 长，而double不比long double长。通常，float使用32位内存，double使用 64位，long double使用80到128位。</p><p>对变量赋值、在运算中使用不同类型、使用强制类型转换时，C++将把值从一种类型转换为另一种类型。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第三章-处理数据&quot;&gt;&lt;a href=&quot;#第三章-处理数据&quot; class=&quot;headerlink&quot; title=&quot;第三章 处理数据&quot;&gt;&lt;/a&gt;第三章 处理数据&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;面向对象编程（OOP）的本质是设计并扩展自己的数据类型。设计自己的数据类型就</summary>
      
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习</title>
    <link href="http://example.com/2023/01/29/C-Primer-Plus-1/chapter05/"/>
    <id>http://example.com/2023/01/29/C-Primer-Plus-1/chapter05/</id>
    <published>2023-01-29T05:45:15.000Z</published>
    <updated>2023-01-30T10:51:00.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章-循环和关系表达式"><a href="#第五章-循环和关系表达式" class="headerlink" title="第五章 循环和关系表达式"></a>第五章 循环和关系表达式</h1><p>本章内容包括：</p><ul><li>for 循环；</li><li>表达式和语句；</li><li>递增运算符和递减运算符： ++ 和 –；</li><li>组合赋值运算符；</li><li>复合语句（语句块）；</li><li>逗号运算符；</li><li>关系运算符：&gt;、&gt;&#x3D;、&#x3D;&#x3D;、&lt;&#x3D;、&lt; 和 !&#x3D;；</li><li>while 循环；</li><li>typedef 工具；</li><li>do while 循环；</li><li>字符输入方法 get() ；</li><li>文件尾条件；</li><li>嵌套循环和二维数组。</li></ul><h2 id="5-1-for-循环"><a href="#5-1-for-循环" class="headerlink" title="5.1 for 循环"></a>5.1 for 循环</h2><h3 id="5-1-1-for-循环初始化"><a href="#5-1-1-for-循环初始化" class="headerlink" title="5.1.1 for 循环初始化"></a>5.1.1 for 循环初始化</h3><p>for循环为执行重复的操作提供了循序渐进的步骤。组成部分完成下面这些步骤：</p><ul><li>设置初始值；</li><li>执行测试，判断循环是否应当继续进行；</li><li>执行循环操作；</li><li>更新用于测试的值。</li></ul><p>初始化、测试和更 新操作构成了控制部分，这些操作由括号括起。其中每部分都是一个表 达式，彼此由分号隔开。控制部分后面的语句叫作循环体，只要测试表 达式为true，它便被执行：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; test-expression; update-expression)</span><br><span class="line">    body;</span><br></pre></td></tr></table></figure></div><p>循环体如果大于一条语句，需要加花括号：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; test-expression; update-expression) &#123;</span><br><span class="line">    body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>C++语法将整个for看作一条语句—虽然循环体可以包含一条或多条 语句。循环只执行一次初始化。</p><p><code>for</code> 是一个 C++ 关键字，编译器不会将 <code>for</code> 视为一个函 数，这还将防止将函数命名为 <code>for</code>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727003613922.png"                      alt="image-20210727003613922"                ></p><blockquote><p>【编程风格 Tips】C++ 常用的方式是，在 for 和括号之间加上一个空格，但省略函数名与括号之间的空格。</p></blockquote><p>看这个表达式赋值逻辑：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y = z = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div><p><strong>赋值运算符是从右向左结合的</strong>，因此首先将0赋给z，然 后将z &#x3D; 0赋给y，依此类推。</p><p>C++在C循环的基础上添加了一项特性，要求对for循环句法做一些 微妙的调整。</p><p>这是原来的句法：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (expresson; expression; expression)</span><br><span class="line">    statement;</span><br></pre></td></tr></table></figure></div><p>但，C++循环允许像下面这样做：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br></pre></td></tr></table></figure></div><p>也就是说，可以在for循环的初始化部分中声明变量。这很方便，但并不适用于原来的句法，因为声明不是表达式。这个变量的生存时间只存在于for语句中，也就是说，当程序离开循环后，<code>i</code> 这个变量将消失。</p><h3 id="5-1-2-回到for循环"><a href="#5-1-2-回到for循环" class="headerlink" title="5.1.2 回到for循环"></a>5.1.2 回到for循环</h3><p>很简单，略。</p><h3 id="5-1-3-修改步长"><a href="#5-1-3-修改步长" class="headerlink" title="5.1.3 修改步长"></a>5.1.3 修改步长</h3><p>循环示例每一轮循环都将循环计数加1或减1。可以通 过修改更新表达式来修改步长，例如改为表达式 <code>i = i + by</code>，其中 <code>by</code> 是用户选择的步长值。</p><h3 id="5-1-4-使用for循环访问字符串"><a href="#5-1-4-使用for循环访问字符串" class="headerlink" title="5.1.4 使用for循环访问字符串"></a>5.1.4 使用for循环访问字符串</h3><p>很简单，略。</p><h3 id="5-1-5-递增运算符（-）和递减运算符（−−）"><a href="#5-1-5-递增运算符（-）和递减运算符（−−）" class="headerlink" title="5.1.5 递增运算符（++）和递减运算符（−−）"></a>5.1.5 递增运算符（++）和递减运算符（−−）</h3><p>这两个运算符执行两种极其常见 的循环操作：将循环计数加1或减1。这两个运算符都有两种变体。前缀（prefix）版本位于操作数前 面，如++x；后缀（postfix）版本位于操作数后面，如x++。两个版本对操作数的影响是一样的，但是影响的时间不同。这就像对于钱包来说， 清理草坪之前付钱和清理草坪之后付钱的最终结果是一样的，但支付钱 的时间不同。</p><p><strong>粗略地讲，a++意味着使用a的当前值计算表达式，然后将a的值加 1；而++b的意思是先将b的值加1，然后使用新的值来计算表达式。</strong> 递减操作符也同理。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727010134791.png"                      alt="image-20210727010134791"                ></p><h3 id="5-1-6-副作用和顺序点"><a href="#5-1-6-副作用和顺序点" class="headerlink" title="5.1.6 副作用和顺序点"></a>5.1.6 副作用和顺序点</h3><p>C++就递增运算符何时生效的哪些方面做了规 定，哪些方面没有规定。首先，副作用（side effect）指的是在计算表达式时对某些东西（如存储在变量中的值）进行了修改；顺序点 （sequence point）是程序执行过程中的一个点，在这里，进入下一步之 前将确保对所有的副作用都进行了评估。在C++中，<strong>语句中的分号就是 一个顺序点</strong>，这意味着程序处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必须完成。</p><p>另外，任何完整的表达式末尾都是一个顺序点。</p><p>何为完整表达式呢？它是这样一个表达式：不是另一个更大表达式 的子表达式。完整表达式的例子有：表达式语句中的表达式部分以及用 作while循环中检测条件的表达式。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727010733540.png"                      alt="image-20210727010733540"                ></p><h3 id="5-1-7-前缀格式和后缀格式"><a href="#5-1-7-前缀格式和后缀格式" class="headerlink" title="5.1.7 前缀格式和后缀格式"></a>5.1.7 前缀格式和后缀格式</h3><p>如果变量被用于某些目的（如用作函数参数或给变量赋 值），使用前缀格式和后缀格式的结果将不同。</p><p>然而，虽然选择使用前缀格式还是后缀格式对程序的行为没有影 响，但执行速度可能有细微的差别。对于内置类型和当代的编译器而 言，这看似不是什么问题。然而，C++允许您针对类定义这些运算符， 在这种情况下，用户这样定义前缀函数：将值加1，然后返回结果；但后缀版本首先复制一个副本，将其加1，然后将复制的副本返回。因 此，对于类而言，前缀版本的效率比后缀版本高。</p><h3 id="5-1-8-递增-x2F-递减运算符和指针"><a href="#5-1-8-递增-x2F-递减运算符和指针" class="headerlink" title="5.1.8 递增&#x2F;递减运算符和指针"></a>5.1.8 递增&#x2F;递减运算符和指针</h3><p>可以将递增运算符用于指针和基本变量。将递增 运算符用于指针时，将把指针的值增加其指向的数据类型占用的字节数，这种规则适用于对指针递增和递减。</p><p>前缀递增、前缀递减和解引用运算符的优先级相同，以从右到左的方式进行结合。后缀递增和后缀递减的优先级相同，但比前缀运算符的优先级高，这两个运算符以从左到右的方式进行结合。</p><p>前缀运算符的从右到到结合规则意味着 <code>*++pt</code> 的含义如下：现将 <code>++</code> 应用于 <code>pt</code>（因为 <code>++</code> 位于 <code>*</code> 的右边），然后将 <code>*</code> 应用于被递增后的 <code>pt</code>。 另一方面，<code>++*pt</code> 意味着先取得 <code>pt</code> 指向的值，然后将这个值加 1，<code>pt</code> 依然指向原来的地址；</p><p>而这个组合 <code>(*pt)++</code> 圆括号指出，首先对指针解引用，得到值。然后，运算符++将这个值递增 1，但 <code>pt</code> 仍然指在原来的地址。 </p><h3 id="5-1-9-组合赋值运算符"><a href="#5-1-9-组合赋值运算符" class="headerlink" title="5.1.9 组合赋值运算符"></a>5.1.9 组合赋值运算符</h3><p><code>+=</code> 运算符将两个操作数相加，并将结果赋给左边的操作数。这意味着左边的操作数必须能够被赋值，如变量、数组元素、结构体成员或通过对指针解引用来标识的数据。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727012040437.png"                      alt="image-20210727012040437"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727012104165.png"                      alt="image-20210727012104165"                ></p><h3 id="5-1-10-复合语句（语句块）"><a href="#5-1-10-复合语句（语句块）" class="headerlink" title="5.1.10 复合语句（语句块）"></a>5.1.10 复合语句（语句块）</h3><p>只有这个地方要注意：假设对循环体进行了缩进，但省略了花括号，编译器将忽略缩进，因此只有第一条语句位于循环中。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727012230040.png"                      alt="image-20210727012230040"                ></p><h3 id="5-1-11-其他语法技巧—逗号运算符"><a href="#5-1-11-其他语法技巧—逗号运算符" class="headerlink" title="5.1.11 其他语法技巧—逗号运算符"></a>5.1.11 其他语法技巧—逗号运算符</h3><p>语句块允许把两条或更多条语句放到按C++句法 只能放一条语句的地方。逗号运算符对表达式完成同样的任务，允许将 两个表达式放到C++句法只允许放一个表达式的地方。如：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++j, --i你  <span class="comment">// 没有分号，合法，但不能独立运行，要在另外语句中，如 for 里</span></span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727012641834.png"                      alt="image-20210727012641834"                ></p><p>但逗号并不总是逗号运算符。 如：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j; <span class="comment">// 个声明中的逗号将变量列 表中相邻的名称分开</span></span><br></pre></td></tr></table></figure></div><p>到目前为止，逗号运算符最常见的用途是将两个或更多的表达式放 到一个for循环表达式中。不过C++还为这个运算符提供了另外两个特 性。首先，它确保先计算第一个表达式，然后计算第二个表达式（换句 话说，逗号运算符是一个顺序点）。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">20</span>, j = <span class="number">2</span> * i   <span class="comment">// 这是合法的，这里 y 是 40</span></span><br></pre></td></tr></table></figure></div><p>在所有运算符中，逗号运算符的优先级是最低的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727013030988.png"                      alt="image-20210727013030988"                ></p><h3 id="5-1-12-关系表达式"><a href="#5-1-12-关系表达式" class="headerlink" title="5.1.12 关系表达式"></a>5.1.12 关系表达式</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727013059937.png"                      alt="image-20210727013059937"                ></p><h3 id="5-1-13-赋值、比较和可能犯的错误"><a href="#5-1-13-赋值、比较和可能犯的错误" class="headerlink" title="5.1.13 赋值、比较和可能犯的错误"></a>5.1.13 赋值、比较和可能犯的错误</h3><p>很简单，略。</p><h3 id="5-1-14-C-风格字符串的比较"><a href="#5-1-14-C-风格字符串的比较" class="headerlink" title="5.1.14 C-风格字符串的比较"></a>5.1.14 C-风格字符串的比较</h3><p>假设要知道字符数组中的字符串是不是mate。如果word是数组名， 下面的测试可能并不能像我们预想的那样工作：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">word == <span class="string">&quot;mate&quot;</span></span><br></pre></td></tr></table></figure></div><p>请记住，数组名是数组的地址。同样，用引号括起的字符串常量也 是其地址。因此，上面的关系表达式不是判断两个字符串是否相同，而 是查看它们是否存储在相同的地址上。两个字符串的地址是否相同呢？ 回答是否定的，虽然它们包含相同的字符。</p><p>由于C++将C-风格字符串视为地址，因此如果使用关系运算符来比 较它们，将无法得到满意的结果。需要用 C 字符串库中的 strcmp() 函数来比较。 该函数接受两个字符串地址作为参数。这意味着 参数可以是指针、字符串常量或字符数组名。如果两个字符串相同，该 函数将返回零；如果第一个字符串按字母顺序排在第二个字符串之前， 则strcmp( )将返回一个负数值；如果第一个字符串按字母顺序排在第二 个字符串之后，则strcpm( )将返回一个正数值。实际上，“按系统排列顺 序”比“按字母顺序”更准确。这意味着字符是根据字符的系统编码来进 行比较的。例如，使用ASCII码时，所有大写字母的编码都比小写字母 小，所以按排列顺序，大写字母将位于小写字母之前。因此，字符 串“Zoo”在字符串“aviary”之前。</p><p>存储在不同长度的数组 中的字符串彼此不相等。但是C-风格字符串是通过结尾的空值字符定义 的，而不是由其所在数组的长度定义的。这意味着两个字符串即使被存 储在长度不同的数组中，也可能是相同的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727014019373.png"                      alt="image-20210727014019373"                ></p><h3 id="5-1-15-比较string类字符串"><a href="#5-1-15-比较string类字符串" class="headerlink" title="5.1.15 比较string类字符串"></a>5.1.15 比较string类字符串</h3><p>如果使用string类字符串而不是C-风格字符串，比较起来将简单些。直接通过运算符比较：&gt;, &lt;, &#x3D;&#x3D; 等。</p><h2 id="5-2-while-循环"><a href="#5-2-while-循环" class="headerlink" title="5.2 while 循环"></a>5.2 while 循环</h2><p><code>while</code> 循环是一个没有初始化和更新部分的 <code>for</code> 循环，它只有测试条件和循环体，与for循环一样，循环体也由一条语句或两个花括号定义的语句块组成。句法如下：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (test-condition)</span><br><span class="line">    body</span><br></pre></td></tr></table></figure></div><p>如果循环体有多条语句，需要花括号：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (test-condition) &#123;</span><br><span class="line">    body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>首先，程序计算圆括号内的测试条件（test-condition）表达式。如 果该表达式为true，则执行循环体中的语句。执行完循环体后，程序返 回测试条件，对它进行重新评估。如果该条件为非零，则再次执行循环 体。测试和执行将一直进行下去，直到测试条件为false为止。</p><p>while 循环和 for 循环一样，也是一 种入口条件循环。因此，如果测试条件一开始便为false，则程序将不会 执行循环体。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727121115868.png"                      alt="image-20210727121115868"                ></p><h3 id="5-2-1-for-与-while"><a href="#5-2-1-for-与-while" class="headerlink" title="5.2.1 for 与 while"></a>5.2.1 for 与 while</h3><p>在C++中，for 和 while 循环本质上是相同的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727121739245.png"                      alt="image-20210727121739245"                ></p><p>但它们之间存在三个差别：</p><ul><li>在 <code>for</code> 循环中省略了测试条件时，将认为条件为 <code>true</code>；</li><li>在 <code>for</code> 循环中，可使用初始化语句声明一个局部变量，但在 <code>while</code> 循环中不能这样做；</li><li>如果循环体中包括 <code>continue</code> 语句，情况将稍有不同，<code>continue</code> 语句将在第6章讨论。</li></ul><p>通常，程序员使用 <code>for</code> 循环来为循环计数，因为 <code>for</code> 循环格式允许将所有相关的信息—初始值、终止值和更新计数器的方法—放在同一个地方。在无法预先知道循环将执行的次数时，程序员常使用 <code>while</code> 循环。</p><h3 id="5-2-2-等待一段时间：编写延时循环"><a href="#5-2-2-等待一段时间：编写延时循环" class="headerlink" title="5.2.2 等待一段时间：编写延时循环"></a>5.2.2 等待一段时间：编写延时循环</h3><p>函数 <code>clock()</code> 可以返回程序开始执行后所用的系统时间。但，首先，clock( )返回时间的单位不一定是秒；其次，该函数的返回类 型在某些系统上可能是long，在另一些系统上可能是unsigned long或其 他类型。</p><p>头文件 <code>ctime</code> 提供了这些问题的解决方案。首先，它定义了一个符号常量—<code>CLOCKS_PER_SEC</code>，该常量等于 每秒钟包含的系统时间单位数。因此，将系统时间除以这个值，可以得 到秒数。或者将秒数乘以 <code>CLOCK_PER_SEC</code>，可以得到以系统时间单位 为单位的时间。其次，<code>ctime</code> 将 <code>clock_t</code> 作为 <code>clock()</code> 返回类型的别名，这意味着可以将变量声明为 <code>clock_t</code> 类型，编译器将把它转换为long、unsigned int 或适合系统的其他类型。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727133448815.png"                      alt="image-20210727133448815"                ></p><h2 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do while 循环"></a>do while 循环</h2><p>它 不同于另外两种循环，因为它是出口条件（exit condition）循环。这意 味着这种循环将首先执行循环体，然后再判定测试表达式，决定是否应 继续执行循环。如果条件为false，则循环终止；否则，进入新一轮的执 行和测试。这样的循环通常至少执行一次，循环体是一条语句或用括号括起的语句块。句法：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    body</span><br><span class="line">&#125; <span class="keyword">while</span> (test-condition);</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727135803904.png"                      alt="image-20210727135803904"                ></p><h2 id="5-4-基于范围的for循环（C-11）"><a href="#5-4-基于范围的for循环（C-11）" class="headerlink" title="5.4 基于范围的for循环（C++11）"></a>5.4 基于范围的for循环（C++11）</h2><p>C++11新增了一种循环：基于范围（range-based）的for循环。这简化了一种常见的循环任务：对数组（或容器类，如vector和array）的每 个元素执行相同的操作。</p><h2 id="5-5-循环和文本输入"><a href="#5-5-循环和文本输入" class="headerlink" title="5.5 循环和文本输入"></a>5.5 循环和文本输入</h2><h3 id="5-5-1-使用原始的cin进行输入"><a href="#5-5-1-使用原始的cin进行输入" class="headerlink" title="5.5.1 使用原始的cin进行输入"></a>5.5.1 使用原始的cin进行输入</h3><p>为什么程序在输出时省略了空格呢？原因 在cin。读取char值时，与读取其他基本类型一样，cin将忽略空格和换行 符。因此输入中的空格没有被回显，也没有被包括在计数内。</p><p>更为复杂的是，发送给cin的输入被缓冲。这意味着只有在用户按 下回车键后，他输入的内容才会被发送给程序。这就是在运行该程序 时，可以在#后面输入字符的原因。按下回车键后，整个字符序列将被 发送给程序，但程序在遇到#字符后将结束对输入的处理。</p><h3 id="5-5-2-使用cin-get-char-进行补救"><a href="#5-5-2-使用cin-get-char-进行补救" class="headerlink" title="5.5.2 使用cin.get(char)进行补救"></a>5.5.2 使用cin.get(char)进行补救</h3><p>通常，逐个字符读取输入的程序需要检查每个字符，包括空格、制 表符和换行符。<code>cin</code> 所属的 <code>istream</code> 类（在 <code>iostream</code> 中定义）中包含一个能 够满足这种要求的成员函数。具体地说，成员函数cin.get(ch)读取输入 中的下一个字符（即使它是空格），并将其赋给变量ch。使用这个函数 调用替换cin&gt;&gt;ch，可以修补程序清单5.16的问题。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727161504704.png"                      alt="image-20210727161504704"                ></p><blockquote><p>在C语言中， 要修改变量的值，必须将变量的地址传递给函数。但程序清单5.17调用 cin.get( )时，传递的是ch，而不是&amp;ch。在C语言中，这样的代码无效， 但在C++中有效，只要函数将参数声明为引用即可。引用是C++在C语 言的基础上新增的一种类型。头文件iostream将cin.get(ch)的参数声明为 引用类型，因此该函数可以修改其参数的值。</p></blockquote><h3 id="5-5-3-使用哪一个cin-get"><a href="#5-5-3-使用哪一个cin-get" class="headerlink" title="5.5.3 使用哪一个cin.get( )"></a>5.5.3 使用哪一个cin.get( )</h3><p>函数重载允许创建多个同名函数，条件是它们 的参数列表不同。例如，如果在C++中使用 <code>cin.get(name，ArSize)</code>， 则编译器将找到使用 <code>char*</code> 和 <code>int</code> 作为参数的 <code>cin.get()</code> 版本；如果使用 <code>cin.get(ch)</code>，则编译器将使用接受一个 <code>char</code> 参数的版本；如果没有提 供参数，则编译器将使用不接受任何参数的<code>cin.get()</code> 版本。函数重载允 许对多个相关的函数使用相同的名称，这些函数以不同方式或针对不同类型执行相同的基本任务。</p><h3 id="5-5-4-文件尾条件"><a href="#5-5-4-文件尾条件" class="headerlink" title="5.5.4 文件尾条件"></a>5.5.4 文件尾条件</h3><p>如果输入来自于文件，则可以使用一种功能更强大的技 术—检测文件尾（EOF）。C++输入工具和操作系统协同工作，来检测文件尾并将这种信息告知程序。</p><p>检测到EOF后，cin将两位（eofbit和failbit）都设置为1。可以通过 成员函数eof( )来查看eofbit是否被设置；如果检测到EOF，则cin.eof( )将 返回bool值true，否则返回false。同样，如果eofbit或failbit被设置为1， 则fail( )成员函数返回true，否则返回false。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727162259773.png"                      alt="image-20210727162259773"                ></p><h3 id="5-5-5-另一个cin-get-版本"><a href="#5-5-5-另一个cin-get-版本" class="headerlink" title="5.5.5 另一个cin.get( )版本"></a>5.5.5 另一个cin.get( )版本</h3><p>为成功地使用cin.get( )，需要知道其如何处理EOF条件。当该函数 到达EOF时，将没有可返回的字符。相反，cin.get( )将返回一个用符号 常量EOF表示的特殊值。该常量是在头文件iostream中定义的。EOF值 必须不同于任何有效的字符值，以便程序不会将EOF与常规字符混淆。 通常，EOF被定义为值−1，因为没有ASCII码为−1的字符，但并不需要知道实际的值，而只需在程序中使用EOF即可。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727162823543.png"                      alt="image-20210727162823543"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727163014040.png"                      alt="image-20210727163014040"                ></p><p>另一方面，使用cin.get(ch)（有一个参数）进行输入时，将不会导 致任何类型方面的问题。前面讲过，cin.get(char)函数在到达EOF时，不 会将一个特殊值赋给ch。事实上，在这种情况下，它不会将任何值赋给 ch。ch不会被用来存储非char值。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727163117901.png"                      alt="image-20210727163117901"                ></p><p>那么应使用cin.get( )还是cin.get(char)呢？使用字符参数的版本更符 合对象方式，因为其返回值是istream对象。这意味着可以将它们拼接起 来。例如，下面的代码将输入中的下一个字符读入到ch1中，并将接下 来的一个字符读入到ch2中:</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">get</span>(ch1).<span class="built_in">get</span>(ch2);</span><br></pre></td></tr></table></figure></div><h2 id="5-6-嵌套循环和二维数组"><a href="#5-6-嵌套循环和二维数组" class="headerlink" title="5.6 嵌套循环和二维数组"></a>5.6 嵌套循环和二维数组</h2><p>C++没有提供二维数组类型，但用户可以创建每个元素本身都是数 组的数组。可以这样声明数组：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> maxtemps[<span class="number">4</span>][<span class="number">5</span>];</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727163540362.png"                      alt="image-20210727163540362"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727163623327.png"                      alt="image-20210727163623327"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210727163905902.png"                      alt="image-20210727163905902"                ></p><p>假设要打印数组所有的内容，可以用一个for循环来改变行，用另一 个被嵌套的for循环来改变列：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> row = <span class="number">0</span>; row &lt; <span class="number">4</span>; ++row) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> col=<span class="number">0</span>; col &lt; <span class="number">5</span>; ++col) &#123;</span><br><span class="line">        cout &lt;&lt; maxtemps[row][col] &lt;&lt; <span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><blockquote><p>实际上，我更喜欢用 vector 来创建动态二维数据，只要创建 vector 的vector 就行，用起来更简单。</p></blockquote><h2 id="5-7-总结"><a href="#5-7-总结" class="headerlink" title="5.7 总结"></a>5.7 总结</h2><p>C++提供了3种循环：for循环、while循环和do while循环。如果循环 测试条件为true或非零，则循环将重复执行一组指令；如果测试条件为 false或0，则结束循环。for循环和while循环都是入口条件循环，这意味 着程序将在执行循环体中的语句之前检查测试条件。do while循环是出 口条件循环，这意味着其将在执行循环体中的语句之后检查条件。</p><p>关系表达式对两个值进行比较，常被用作循环测试条件。关系表达 式是通过使用6种关系运算符之一构成的：<code>&lt;</code>、<code>&lt;=</code>、<code>==</code>、<code>&gt;=</code>、<code>&gt;</code> 或 <code>!=</code>。 关系表达式的结果为bool类型，值为true或false。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第五章-循环和关系表达式&quot;&gt;&lt;a href=&quot;#第五章-循环和关系表达式&quot; class=&quot;headerlink&quot; title=&quot;第五章 循环和关系表达式&quot;&gt;&lt;/a&gt;第五章 循环和关系表达式&lt;/h1&gt;&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;for 循环；&lt;/</summary>
      
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习</title>
    <link href="http://example.com/2023/01/29/C-Primer-Plus-1/chapter06/"/>
    <id>http://example.com/2023/01/29/C-Primer-Plus-1/chapter06/</id>
    <published>2023-01-29T05:45:15.000Z</published>
    <updated>2023-01-30T10:51:08.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六章-分支语句和逻辑运算符"><a href="#第六章-分支语句和逻辑运算符" class="headerlink" title="第六章 分支语句和逻辑运算符"></a>第六章 分支语句和逻辑运算符</h1><p>本章的内容包括：</p><ul><li><code>if</code> 语句；</li><li><code>if else</code> 语句；</li><li>逻辑运算符：<code>&amp;&amp;</code>、<code>||</code> 和 <code>!</code>；</li><li><code>cctype</code> 字符函数库；</li><li>条件运算符：<code>?:</code>；</li><li><code>switch</code> 语句；</li><li><code>continue</code> 和 <code>break</code> 语句；</li><li>读取数字的循环；</li><li>基本文件输入&#x2F;输出。</li></ul><h2 id="6-1-if-语句"><a href="#6-1-if-语句" class="headerlink" title="6.1 if 语句"></a>6.1 <code>if</code> 语句</h2><p>如果测试条件为 <code>true</code>， 则 <code>if</code> 语句将引导程序执行语句或语句块；如果条件是<code>false</code>，程序将跳过 这条语句或语句块。因此，<code>if</code> 语句让程序能够决定是否应执行特定的语句。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728225254330.png"                      alt="image-20210728225254330"                ></p><h3 id="6-1-1-if-else-语句"><a href="#6-1-1-if-else-语句" class="headerlink" title="6.1.1 if else 语句"></a>6.1.1 <code>if else</code> 语句</h3><p><code>if</code> 语句让程序决定是否执行特定的语句或语句块，而<code>if else</code>语句则让程序决定执行两条语句或语句块中的哪一条，这种语句对于选择其中一 种操作很有用。</p><p><code>if else</code> 语句的通用格式如下：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728225544934.png"                      alt="image-20210728225544934"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728225606236.png"                      alt="image-20210728225606236"                ></p><h3 id="6-1-2-格式化-if-else-语句"><a href="#6-1-2-格式化-if-else-语句" class="headerlink" title="6.1.2 格式化 if else 语句"></a>6.1.2 格式化 <code>if else</code> 语句</h3><p><code>if else</code> 中的两种操作都必须是一条语句。如果需要多条语句，需要 用大括号将它们括起来，组成一个块语句。</p><h3 id="6-1-3-if-else-if-else-结构"><a href="#6-1-3-if-else-if-else-结构" class="headerlink" title="6.1.3  if- else if- else 结构"></a>6.1.3  <code>if</code>- <code>else if</code>- <code>else</code> 结构</h3><p>计算机程序也可能提供两个以上的 选择。可以将<code>C++</code>的 <code>if else</code> 语句进行扩展来满足这种需求。正如读者知 道的，<code>else</code> 之后应是一条语句，也可以是语句块。由于 <code>if else</code> 语句本身是 一条语句，所以可以放在 <code>else</code> 的后面。</p><h2 id="6-2-逻辑表达式"><a href="#6-2-逻辑表达式" class="headerlink" title="6.2 逻辑表达式"></a>6.2 逻辑表达式</h2><p>C++ 提供了3种逻辑运算符，来组合或修改已有的表达式。这些运算符分别是逻 辑 <code>OR (||)</code>、逻辑 <code>AND (&amp;&amp;)</code>和逻辑 <code>NOT (!)</code>。</p><h3 id="6-2-1-逻辑OR运算符："><a href="#6-2-1-逻辑OR运算符：" class="headerlink" title="6.2.1 逻辑OR运算符：||"></a>6.2.1 逻辑OR运算符：<code>||</code></h3><p>C++可以采用逻辑OR运算 符 <code>||</code>，将两个表达式组合在一起。如果原来表达式中的任何一个或 全部都为 <code>true</code>（或非零），则得到的表达式的值为 <code>true</code>；否则，表达式的值为 <code>false</code>。</p><p>C++ 规定 <code>||</code> 运算符是个顺序点（sequence point）。也是说，先修改左侧的值，再对右侧的值进行判定（C++11的说法是，运算符左边的子表达式先于右边的子表达式）。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728230438579.png"                      alt="image-20210728230438579"                ></p><h3 id="6-2-2-逻辑AND运算符：-amp-amp"><a href="#6-2-2-逻辑AND运算符：-amp-amp" class="headerlink" title="6.2.2 逻辑AND运算符：&amp;&amp;"></a>6.2.2 逻辑AND运算符：<code>&amp;&amp;</code></h3><p>逻辑AND运算符 <code>&amp;&amp;</code>，也是将两个表达式组合成一个表达式。 仅当原来的两个表达式都为 <code>true</code> 时，得到的表达式的值才为 <code>true</code>。</p><p><code>&amp;&amp;</code> 运算符也是顺序点，因此将首先判定左侧， 并且在右侧被判定之前产生所有的副作用。如果左侧为 <code>false</code>，则整个逻 辑表达式必定为 <code>false</code>，在这种情况下，C++ 将不会再对右侧进行判定。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728230605370.png"                      alt="image-20210728230605370"                ></p><h3 id="6-2-3-用-amp-amp-来设置取值范围"><a href="#6-2-3-用-amp-amp-来设置取值范围" class="headerlink" title="6.2.3 用 &amp;&amp; 来设置取值范围"></a>6.2.3 用 <code>&amp;&amp;</code> 来设置取值范围</h3><p><code>&amp;&amp;</code> 运算符还允许建立一系列<code>if</code> <code>else if</code> <code>else</code>语句，其中每种选择都对 应于一个特定的取值范围。</p><h3 id="6-2-4-逻辑NOT运算符："><a href="#6-2-4-逻辑NOT运算符：" class="headerlink" title="6.2.4 逻辑NOT运算符：!"></a>6.2.4 逻辑NOT运算符：<code>!</code></h3><p><code>!</code> 运算符将它后面的表达式的真值取反。也是说，如果 <code>expression</code> 为 <code>true</code>，则 <code>!expression</code> 是 <code>false</code>；如果 <code>expression</code> 为 <code>false</code>，则 <code>!expression</code>是 <code>true</code>。更准确地说，如果 <code>expression</code> 为 <code>true</code> 或非零，则 <code>!expression</code> 为 <code>false</code>。</p><p>然而，<code>!</code> 运算符对于返回 <code>true-false</code> 值或可以被解释为 <code>true-false</code> 值的函数来说很有用。例如，如果C-风格字符串 <code>s1</code> 和 <code>s2</code> 不同，则 <code>strcmp(s1,s2)</code> 将返回非零<code>true</code>值，否则返回 <code>0</code>。这意味着如果这两个字符串相同， 则 <code>!strcmp(s1,s2)</code> 为 <code>true</code>。</p><h3 id="6-2-5-逻辑运算符细节"><a href="#6-2-5-逻辑运算符细节" class="headerlink" title="6.2.5 逻辑运算符细节"></a>6.2.5 逻辑运算符细节</h3><p><code>!</code> 运算符的优先级高于所有的关系运算符和算术运算符。因此，要对表达式求反，必须用括号将其括起。</p><h3 id="6-2-6-其他表示方式"><a href="#6-2-6-其他表示方式" class="headerlink" title="6.2.6 其他表示方式"></a>6.2.6 其他表示方式</h3><p>并不是所有的键盘都提供了用作逻辑运算符的符号，因此C++标准 提供了另一种表示方式，如表6.3所示。标识符<code>and</code>、<code>or</code>和<code>not</code>都是C++保 留字，这意味着不能将它们用作变量名等。它们不是关键字，因为它们 都是已有语言特性的另一种表示方式。另外，它们并不是C语言中的保 留字，但C语言程序可以将它们用作运算符，只要在程序中包含了头文 件 <code>iso646.h</code>。C++不要求使用头文件。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728232023659.png"                      alt="image-20210728232023659"                ></p><h2 id="6-3-字符函数库-cctype"><a href="#6-3-字符函数库-cctype" class="headerlink" title="6.3 字符函数库 cctype"></a>6.3 字符函数库 <code>cctype</code></h2><p>C++ 从 C 语言继承了一个与字符相关的、非常方便的函数软件包， 它可以简化诸如确定字符是否为大写字母、数字、标点符号等工作，这 些函数的原型是在头文件<code>cctype</code>（老式的风格中为 <code>ctype.h</code>）中定义的。 例如，如果 <code>ch</code> 是一个字母，则 <code>isalpha(ch)</code> 函数返回一个非零值，否则返回 <code>0</code>。同样，如果 <code>ch</code> 是标点符号（如逗号或句号），函数 <code>ispunct(ch)</code> 将返回 <code>true</code>。（<strong>注意这些函数的返回类型为 <code>int</code>，而不是 <code>bool</code>， 但通常 <code>bool</code> 转换能够将它们视为<code>bool</code> 类型</strong>）</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728232352198.png"                      alt="image-20210728232352198"                ></p><p><code>isalpha()</code> 不仅更容易使用，而且更通用。例子中用AND&#x2F;OR格式假设A-Z的字符编码是连续的，其他字符的编码不在这个范围内。这种假设对于ASCII码来说是成立的，但也并非总是如此。</p><p>具体地说：</p><ul><li><code>isalpha()</code> 用来检查字符是否为字母字符；</li><li><code>isdigit()</code> 用来测试字符是否为数字字符（0~9），如 3；</li><li><code>isspace()</code> 用来测试字符是否为空白，包括换行符、空格和制表符；</li><li><code>ispunct()</code> 用来测试字符是否为标点符号。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728232647223.png"                      alt="image-20210728232647223"                ></p><p>总结一下这个函数包：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728232856482.png"                      alt="image-20210728232856482"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728232930054.png"                      alt="image-20210728232930054"                ></p><h2 id="6-4-运算符"><a href="#6-4-运算符" class="headerlink" title="6.4 ?: 运算符"></a>6.4 <code>?:</code> 运算符</h2><p>C++有一个常被用来代替 <code>if else</code> 语句的运算符，这个运算符被称为条件运算符 <code>?:</code>，它是C++中唯一一个需要3个操作数的运算符，也叫<strong>三目运算符</strong>。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expression1 ? expression2 : expression3</span><br></pre></td></tr></table></figure></div><p>如果 <code>expression1</code> 为 <code>true</code>，则整个条件表达式的值为 <code>expression2</code> 的值； 否则，整个表达式的值为 <code>expression3</code> 的值。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728233356197.png"                      alt="image-20210728233356197"                ></p><h2 id="6-5-switch语句"><a href="#6-5-switch语句" class="headerlink" title="6.5 switch语句"></a>6.5 <code>switch</code>语句</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728234430665.png"                      alt="image-20210728234430665"                ></p><p><code>switch</code> 语句与 Pascal 等语言中类似的语句之间存在重大的差别。 C++中的 <code>case</code> 标签只是行标签，而不是选项之间的界线。也是说，程序跳到 <code>switch</code> 中特定代码行后，将依次执行之后的所有语句，除非有明确的其他指示。程序不会在执行到下一个 <code>case</code> 处自动停止，<strong>要让程序执行 完一组特定语句后停止，必须使用<code>break</code> 语句</strong>。这将导致程序跳到 <code>switch</code> 后面的语句处执行。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728234458366.png"                      alt="image-20210728234458366"                ></p><h3 id="6-5-1-将枚举量用作标签"><a href="#6-5-1-将枚举量用作标签" class="headerlink" title="6.5.1 将枚举量用作标签"></a>6.5.1 将枚举量用作标签</h3><p>通常，<code>cin</code> 无法识别枚举类型（它不知道程序员是如 何定义它们的），因此该程序要求用户选择选项时输入一个整数。当 <code>switch</code> 语句将 <code>int</code> 值和枚举量标签进行比较时，将枚举量提升为 <code>int</code>。另 外，在 <code>while</code> 循环测试条件中，也会将枚举量提升为 <code>int</code> 类型。</p><h3 id="6-5-2-switch-和-if-else"><a href="#6-5-2-switch-和-if-else" class="headerlink" title="6.5.2 switch 和 if else"></a>6.5.2 <code>switch</code> 和 <code>if else</code></h3><p><code>switch</code>语句和<code>if else</code>语句都允许程序从选项中进行选择。相比之下， <code>if else</code>更通用，例如，它可以处理取值范围。</p><p>然而，<code>switch</code>并不是为处理取值范围而设计的。<code>switch</code>语句中的每 一个<code>case</code>标签都必须是一个单独的值。另外，这个值必须是整数（包括 <code>char</code>），因此 <code>switch</code> 无法处理浮点测试。另外 <code>case</code> 标签值还必须是常量。 如果选项涉及取值范围、浮点测试或两个变量的比较，则应使用 <code>if else</code> 语句。</p><h2 id="6-6-break-和-continue-语句"><a href="#6-6-break-和-continue-语句" class="headerlink" title="6.6 break 和 continue 语句"></a>6.6 <code>break</code> 和 <code>continue</code> 语句</h2><p><code>break</code>和 <code>continue</code>语句都使程序能够跳过部分代码。可以在 <code>switch</code>语句或任何循环中使用 <code>break</code> 语句，使程序跳到 <code>switch</code> 或循环后面的语句处执行。<code>continue</code> 语句用于循环中，让程序跳过循环体中余下的代码，并开始新一轮循环。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728235538853.png"                      alt="image-20210728235538853"                ></p><h2 id="6-7-读取数字的循环"><a href="#6-7-读取数字的循环" class="headerlink" title="6.7 读取数字的循环"></a>6.7 读取数字的循环</h2><p>假设要编写一个将一系列数字读入到数组中的程序，并允许用户在 数组填满之前结束输入，一种方法是利用cin。看下面的代码：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br></pre></td></tr></table></figure></div><p>如果用户输入一个单词，而不是一个数字，发生这种类型不匹配的情况时，将发生4种情况：</p><ul><li><code>n</code> 的值保持不变；</li><li>不匹配的输入将被留在输入队列中；</li><li><code>cin</code> 对象中的一个错误标记被设置；</li><li>对 <code>cin</code> 方法的调用将返回 <code>false</code>（如果被转换为 <code>bool</code> 类型）。</li></ul><p><strong>方法返回 <code>false</code> 意味着可以用非数字输入来结束读取数字的循环</strong>。当用户输入的不是数字时，该程序将不再读取输入。非数字输入设置错误标记意味着<strong>必须重置该标记，程序才能继续读取输 入</strong>。<code>clear()</code> 方法重置错误输入标记，同时也重置文件尾（<code>EOF</code>条件，参见第5章）。输入错误和 <code>EOF</code> 都将导致<code>cin</code>返回 <code>false</code>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210729001427328.png"                      alt="image-20210729001427328"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210729001350955.png"                      alt="image-20210729001350955"                ></p><p>如果用户输入非数字输入，程序将拒绝，并要求用户继续输入数字。可以看到，可以使用 <code>cin</code> 输入表达式的值来检测输入是不是数字。 程序发现用户输入了错误内容时，应采取3个步骤：</p><ul><li>重置 <code>cin</code> 以接受新的输入；</li><li>删除错误输入；</li><li>提示用户再输入。</li></ul><p>请注意，程序必须先重置cin，然后才能删除错误输入。如下程序清单 6.14演示了如何完成这些工作。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Max = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="comment">// get data</span></span><br><span class="line">    <span class="type">int</span> golf[Max];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Please enter your golf scores.\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;You must enter &quot;</span> &lt;&lt; Max &lt;&lt; <span class="string">&quot; rounds.\n&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Max; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;round #&quot;</span> &lt;&lt; i+<span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!(cin &gt;&gt; golf[i])) &#123;</span><br><span class="line">            cin.<span class="built_in">clear</span>();     <span class="comment">// reset input</span></span><br><span class="line">            <span class="keyword">while</span> (cin.<span class="built_in">get</span>() != <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                <span class="keyword">continue</span>;    <span class="comment">// get rid of bad input</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Please enter a number: &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// calculate average</span></span><br><span class="line">    <span class="type">double</span> total = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; Max; i++)</span><br><span class="line">        total += golf[i];</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// report results</span></span><br><span class="line">    cout &lt;&lt; total / Max &lt;&lt; <span class="string">&quot; = average score &quot;</span></span><br><span class="line">         &lt;&lt; Max &lt;&lt; <span class="string">&quot; rounds\n&quot;</span>;</span><br><span class="line">    <span class="comment">// cin.get();</span></span><br><span class="line">    <span class="comment">// cin.get();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210729165001482.png"                      alt="image-20210729165001482"                ></p><blockquote><p>如果用户输入 88，则 <code>cin</code> 表达式将为 <code>true</code>，因此将一个值放到数组中；而表达式 <code>!(cin &gt;&gt; golf [i])</code> 为 <code>false</code>，因此结束内部循环。然而，如果用户输入 <code>must i?</code>，则 <code>cin</code> 表达式将为 <code>false</code>，因此不会将任何值放到数组 中；而表达式 <code>!(cin &gt;&gt; golf [i])</code> 将为 <code>true</code>，因此进入内部的 <code>while</code> 循环。该循环的第一条语句使用 <code>clear()</code> 方法重置输入，如果省略这条语句，程序将拒绝继续读取输入。接下来，程序在 <code>while</code> 循环中使用 <code>cin.get()</code> 来读取 行尾之前的所有输入，从而删除这一行中的错误输入。另一种方法是读取到下一个空白字符，这样将每次删除一个单词，而不是一次删除整 行。最后，程序告诉用户，应输入一个数字。</p></blockquote><h2 id="6-8-简单文件输入-x2F-输出"><a href="#6-8-简单文件输入-x2F-输出" class="headerlink" title="6.8 简单文件输入&#x2F;输出"></a>6.8 简单文件输入&#x2F;输出</h2><h3 id="6-8-1-文本I-x2F-O和文本文件"><a href="#6-8-1-文本I-x2F-O和文本文件" class="headerlink" title="6.8.1 文本I&#x2F;O和文本文件"></a>6.8.1 文本I&#x2F;O和文本文件</h3><h3 id="6-8-2-写入到文本文件中"><a href="#6-8-2-写入到文本文件中" class="headerlink" title="6.8.2 写入到文本文件中"></a>6.8.2 写入到文本文件中</h3><p>文件输出：</p><ul><li>必须包含头文件 <code>fstream</code>；</li><li>头文件 <code>fstream</code> 定义了一个用于处理输出的 <code>ofstream</code> 类；</li><li>需要声明一个或多个 <code>ofstream</code> 变量（对象），并以自己喜欢的方式 对其进行命名，条件是遵守常用的命名规则；</li><li>必须指明名称空间 <code>std</code>。例如，为引用元素 <code>ofstream</code>，必须使用编译指令<code>using</code> 或前缀 <code>std::</code>；</li><li>需要将 <code>ofstream</code> 对象与文件关联起来。为此，方法之一是使用 <code>open()</code> 方法；</li><li>使用完文件后，应使用方法 <code>close()</code> 将其关闭；</li><li>可结合使用 <code>ofstream</code> 对象和运算符 <code>&lt;&lt;</code> 来输出各种类型的数据。</li></ul><p>虽然头文件 <code>iostream</code> 提供了一个预先定义好的名为 <code>cout</code> 的 <code>ostream</code> 对象，但您必须声明自己的 <code>ofstream</code> 对象，为其命名，并将其同文件关联起来。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210729232741786.png"                      alt="image-20210729232741786"                ></p><p>注意，方法<code>open()</code> 只接受C-风格字符串作为参数，这可以是一个 字面字符串，也可以是存储在数组中的字符串。</p><p>重要的是，声明一个<code>ofstream</code>对象并将其同文件关联起来后，便可以像使用cout那样使用它。所有可用于cout的操作和方法（如&lt;&lt;、endl 和setf( )）都可用于ofstream对象（如前述示例中的outFile和fout）。</p><p>总之，使用文件输出的主要步骤如下：</p><ul><li>包含头文件 <code>fstream</code>；</li><li>创建一个 <code>ofstream</code> 对象；</li><li>将该 <code>ofstream</code> 对象同一个文件关联起来；</li><li>就像使用 <code>cout</code> 那样使用该 <code>ofstream</code> 对象;</li><li>调用 <code>close()</code> 成员函数，关闭文件。</li></ul><blockquote><p>默认情况下，<code>open()</code> 的将首先截断该文件，即将其长度截短到零——丢弃原有的内容，然后将新的输出加入到该文件中。</p></blockquote><h3 id="6-8-3-读取文本文件"><a href="#6-8-3-读取文本文件" class="headerlink" title="6.8.3 读取文本文件"></a>6.8.3 读取文本文件</h3><p>接下来介绍文本文件输入，它是基于控制台输入的。控制台输入涉 及多个方面，下面首先总结这些方面：</p><ul><li>必须包含头文件 <code>fstream</code>；</li><li>头文件 <code>fstream</code> 定义了一个用于处理输入的 <code>ifstream</code> 类；</li><li>需要声明一个或多个 <code>ifstream</code> 变量（对象），并以自己喜欢的方式对其进行命名，条件是遵守常用的命名规则；</li><li>必须指明名称空间 <code>std</code>；例如，为引用元素 <code>ifstream</code>，必须使用编译指令<code>using</code>或前缀<code>std::</code>；</li><li>需要将 <code>ifstream</code> 对象与文件关联起来。为此，方法之一是使用 <code>open()</code> 方法；</li><li>使用完文件后，应使用 <code>close()</code> 方法将其关闭；</li><li>可结合使用 <code>ifstream</code> 对象和运算符 <code>&gt;&gt;</code> 来读取各种类型的数据；</li><li>可以使用 <code>ifstream</code> 对象和 <code>get()</code> 方法来读取一个字符，使用 <code>ifstream</code> 对象和 <code>getline()</code> 来读取一行字符；</li><li>可以结合使用 <code>ifstream</code> 和 <code>eof()</code>、<code>fail()</code> 等方法来判断输入是否成功；</li><li><code>ifstream</code> 对象本身被用作测试条件时，如果最后一个读取操作成 功，它将被转换为布尔值 <code>true</code>，否则被转换为 <code>false</code>。</li></ul><p>如果试图打开一个不存在的文件用于输入，情况将如何呢？这种错误将导致后面使用<code>ifstream</code> 对象进行输入时失败。检查文件是否被成功打开的首选方法是使用<code>is_open()</code>，为此，可以使用类似于下面的代码：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inFile.<span class="built_in">open</span>(<span class="string">&quot;b.txt&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!inFile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FEAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>如果文件被成功地打开，方法 <code>is_open()</code> 将返回 <code>true</code>；因此如果文件没有被打开，表达式 <code>!inFile.is_open()</code> 将为 <code>true</code>。函数 <code>exit()</code> 的原型是在头文件 <code>cstdlib</code> 中定义的，在该头文件中，还定义了一个用于同操作系统通信的参数值 <code>EXIT_FAILURE</code>。函数 <code>exit()</code> 终止程序。</p><blockquote><p>方法 <code>is_open()</code> 是C++中相对较新的内容。如果读者的编译器不支持它，可使用较老的方法 <code>good()</code> 来代替。</p></blockquote><p>程序例子：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210730001839791.png"                      alt="image-20210730001839791"                ><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210730001922821.png"                      alt="image-20210730001922821"                ></p><p>假设该文件名为scores.txt，包含的内容如下：</p><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18 19 18.5 13.5</span><br><span class="line">16 19.5 18.5</span><br><span class="line">17.5</span><br></pre></td></tr></table></figure></div><blockquote><p>检查文件是否被成功打开至关重要。</p></blockquote><p>读取文件时，有 几点需要检查。首先，程序读取文件时不应超过 EOF。如果最后一次读取数据时遇到 <code>EOF</code>，方法 <code>eof()</code> 将返回 <code>true</code>。其次，程序可能遇到类型不 匹配的情况。例如，程序清单6.16期望文件中只包含数字。如果最后一次读取操作中发生了类型不匹配的情况，方法 <code>fail()</code> 将返回 <code>true</code>（如果遇到了 <code>EOF</code>，该方法也将返回 <code>true</code>）。最后，可能出现意外的问题，如文 件受损或硬件故障。如果最后一次读取文件时发生了这样的问题，方法 <code>bad()</code> 将返回 <code>true</code>。不要分别检查这些情况，一种更简单的方法是使用 <code>good()</code> 方法，该方法在没有发生任何错误时返回 <code>true</code>：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (inFile.<span class="built_in">good</span>()) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>方法 <code>good()</code> 指出最后一次读取输入的操作是否成功，这一点至关重要。这意味着应该在执行读取输入的操作后，立刻应用这种测试。为此，一种标准方法是，在循环之前（首次执行循环测试前）放置一条输 入语句，并在循环的末尾（下次执行循环测试之前）放置另一条输入语句：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// standard file-reading loop design</span></span><br><span class="line">inFile &gt;&gt; value;         <span class="comment">// get first value</span></span><br><span class="line"><span class="keyword">while</span> (inFile.<span class="built_in">good</span>()) &#123;  <span class="comment">// while uput good and not at EOF</span></span><br><span class="line">    <span class="comment">//loop body goes here</span></span><br><span class="line">    inFile &gt;&gt; value;     <span class="comment">// get next value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>鉴于以下事实，可以对上述代码进行精简：表达式 <code>inFile &gt;&gt; value</code> 的结果为<code>inFile</code>，而在需要一个 <code>bool</code> 值的情况下，<code>inFile</code> 的结果为 <code>inFile.good()</code>，即 <code>true</code> 或 <code>false</code>。</p><p>因此，可以将两条输入语句用一条用作循环测试的输入语句代替。 也就是说，可以将上述循环结构替换为如下循环结构：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// omit pre-loop input</span></span><br><span class="line"><span class="keyword">while</span> (inFile &gt;&gt; value) &#123;  <span class="comment">// read and test for success</span></span><br><span class="line">    <span class="comment">// loop body goes here</span></span><br><span class="line">    <span class="comment">// omit end-of-loop input</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210730002759125.png"                      alt="image-20210730002759125"                ></p><p>这些代码紧跟在循环的后面，用于判断循环为何终止。由于 <code>eof()</code> 只能判断是否到达 <code>EOF</code>，而 <code>fail()</code> 可用于检查 <code>EOF</code> 和类型不匹配，因此上述 代码首先判断是否到达 <code>EOF</code>。这样，如果执行到了 <code>else if</code> 测试，便可排除 <code>EOF</code>，因此，如果 <code>fail()</code> 返回 <code>true</code>，便可断定导致循环终止的原因是类型不匹配。</p><p>这种设计仍然遵循了在测试之前进行读取的规则，因为要计算表达式 <code>inFile &gt;&gt; value</code> 的值，程序必须首先试图将一个数字读取到 <code>value</code> 中。</p><p>以上仅是对文件 I&#x2F;O 的初步介绍。</p><h2 id="6-9-总结"><a href="#6-9-总结" class="headerlink" title="6.9 总结"></a>6.9 总结</h2><p>C++提供了 <code>if</code> 语句、<code>if-else</code> 语句和 <code>switch</code> 语句来管理选项。<br>C++还提供了帮助决策的运算符。通过使用逻辑运算符（<code>&amp;&amp;</code>、<code>||</code> 和 <code>!</code>），可以组合或修改关系表达式，创建更细致的测试。条件运算符 <code>(?:)</code> 提供了一种选择两个值之一 的简洁方式。</p><p><code>cctype</code> 字符函数库提供了一组方便的、功能强大的工具，可用于分析字符输入。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728232856482.png"                      alt="image-20210728232856482"                ><br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/07/image-20210728232930054.png"                      alt="image-20210728232930054"                ></p><p>文件 I&#x2F;O 与控制台 I&#x2F;O 极其相似。声明 ifstream 和 ofstream 对象，并将它们同文件关联起来后，便可以像使用 cin 和 cout 那样使用这些对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第六章-分支语句和逻辑运算符&quot;&gt;&lt;a href=&quot;#第六章-分支语句和逻辑运算符&quot; class=&quot;headerlink&quot; title=&quot;第六章 分支语句和逻辑运算符&quot;&gt;&lt;/a&gt;第六章 分支语句和逻辑运算符&lt;/h1&gt;&lt;p&gt;本章的内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习</title>
    <link href="http://example.com/2023/01/29/C-Primer-Plus-1/chapter08/"/>
    <id>http://example.com/2023/01/29/C-Primer-Plus-1/chapter08/</id>
    <published>2023-01-29T05:45:15.000Z</published>
    <updated>2023-01-30T10:51:20.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八章-函数探幽"><a href="#第八章-函数探幽" class="headerlink" title="第八章 函数探幽"></a>第八章 函数探幽</h1><p>本章内容：</p><ul><li>内联函数；</li><li>引用变量；</li><li>如何按引用传递函数参数；</li><li>默认参数；</li><li>函数重载；</li><li>函数模板；</li><li>函数模板具体化。</li></ul><h2 id="8-1-C-内联函数"><a href="#8-1-C-内联函数" class="headerlink" title="8.1 C++ 内联函数"></a>8.1 C++ 内联函数</h2><p>内联函数是C++为提高程序运行速度所做的一项改进。常规函数和内联函数之间的主要区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。 常规函数调用也使程序跳到另一个地址（函数的地址），并在函数结束时返回。</p><p>C++内联函数提供了另一种选择。内联函数的编译代码与其他程序代码“内联”起来了。也就是说，<strong>编译器将使用相应的函数代码替换函数调用</strong>。对于内联代码，程序无需跳到另一个位置处执行代码，再跳回来。因此，内联函数的运行速度比常规函数稍快，但代价是需要占用更多内存。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210805155012304.png"                      alt="image-20210805155012304"                ></p><p>要使用这项特性，必须采取下述措施之一：</p><ul><li>在函数声明前加上关键字 inline；</li><li>在函数定义前加上关键字 inline；</li></ul><p>内联函数最好都是一些很简单、行数少的函数。</p><h2 id="8-2-引用变量"><a href="#8-2-引用变量" class="headerlink" title="8.2 引用变量"></a>8.2 引用变量</h2><p>C++新增了一种复合类型——引用变量。<strong>引用是已定义的变量的别名（另一个名称）</strong>。</p><h3 id="8-2-1-创建引用变量"><a href="#8-2-1-创建引用变量" class="headerlink" title="8.2.1 创建引用变量"></a>8.2.1 创建引用变量</h3><p>C++给<code>&amp;</code>符号赋予另一个含义，将其用来声明引用。例如，要将 <code>rodents</code>作为<code>rats</code>变量的别名，可以这样做：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rats;</span><br><span class="line"><span class="type">int</span> &amp;rodents = rats;  <span class="comment">// makes rodents an alias for rats</span></span><br></pre></td></tr></table></figure></div><p>其中，**<code>&amp;</code> 不是地址运算符，而是类型标识符的一部分**。就像声明中的 <code>char*</code> 指的是指向 <code>char</code> 的指针一样，<code>int &amp;</code> 指的是指向 <code>int</code> 的引用。</p><p>将 <code>rodents</code> 加1将影响这两个变量。更准确地说， <code>rodents++</code> 操作将一共有两个名称的变量加1。</p><p>引用看上去很像伪装表示的指针（其中，<code>*</code> 解除引用运算符被隐式理解）。实际上，引用还是不同于指针的。除了表示法不同外，还有其他的差别。例如，差别之一是， 必须在声明引用时将其初始化，而不能像指针那样，先声明，再赋值。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210805160617225.png"                      alt="image-20210805160617225"                ></p><p>引用更接近const指针，必须在创建时进行初始化，一旦与某个变量关联起来，就将一直效忠于它。也就是说：<strong>某个变量的引用是不可更改的</strong>。</p><blockquote><p><strong>引用是别名。</strong></p></blockquote><h3 id="8-2-2-将引用用作函数参数"><a href="#8-2-2-将引用用作函数参数" class="headerlink" title="8.2.2 将引用用作函数参数"></a>8.2.2 将引用用作函数参数</h3><p><strong>引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法称为按引用传递</strong>。按引用传递允许被调用的函数能够访问调用函数中的变量。<strong>C++新增的这项特性是对C语言的超越，C语言只能按值传递</strong>。按值传递导致被调用函数使用调用程序的值的拷贝（参见图8.2）。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210805161500948.png"                      alt="image-20210805161500948"                ></p><p>交换函数必须能够修改调用程序中的变量的值。这意味着按值传递变量将不管用，因为函数将交换原始变量副本的内容，而不是变量本身的内容。但传递引用时，函数将可以使用原始数据。另一种方法是，传递指针来访问原始数据。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210805162214166.png"                      alt="image-20210805162214166"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210805162432252.png"                      alt="image-20210805162432252"                ></p><h3 id="8-2-3-引用的属性和特别之处"><a href="#8-2-3-引用的属性和特别之处" class="headerlink" title="8.2.3 引用的属性和特别之处"></a>8.2.3 引用的属性和特别之处</h3><p><code>refcube()</code> 函数修改了 <code>main()</code> 中的 <code>x</code> 值，而 <code>cube()</code> 没有，这提醒我们为何通常按值传递。变量 <code>a</code> 位于 <code>cube()</code> 中，它被初始化为 <code>x</code> 的值，但修改 <code>a</code> 并不会影响 <code>x</code>。但由于 <code>refcube()</code> 使用了引用参数，因此修改 <code>ra</code> 实际上就是修改 <code>x</code>。如果只是让函数使用传递给它的信息，而不对这些信息进行修改，同时又想使用引用，则应使用常量引用。</p><p>例如，在这个例子中，应在函数原型和函数头中使用<code>const</code>：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">refcube</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;ra)</span></span>;</span><br></pre></td></tr></table></figure></div><p>如果要编写类似于上述示例的函数（即使用基本数值 类型），应采用按值传递的方式，而不要采用按引用传递的方式。当数据比较大（如结构和类）时，引用参数将很有用。</p><blockquote><p>函数中应尽可能将引用形参声明为 const，这样好处有三个：</p><ul><li>const 可以避免无意中修改数据，从而导致编程错误；</li><li>const 使函数能够处理 const 和非 const 实参，否则只能接受非 const 数据；</li><li>const 引用使函数能够正确生成并使用临时变量。</li></ul></blockquote><h3 id="8-2-4-将引用用于结构体"><a href="#8-2-4-将引用用于结构体" class="headerlink" title="8.2.4 将引用用于结构体"></a>8.2.4 将引用用于结构体</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210805164836645.png"                      alt="image-20210805164836645"                ></p><p>2．为何要返回引用</p><p>下面更深入地讨论返回引用与传统返回机制的不同之处。传统返回机制与按值传递函数参数类似：计算关键字return后面的表达式，并将结果返回给调用函数。从概念上说，这个值被复制到一个临时位置，而 调用程序将使用这个值。</p><blockquote><p>返回引用的函数实际上是被引用的变量的别名。</p></blockquote><p>3．返回引用时需要注意的问题</p><p>返回引用时最重要的一点是，应避免返回函数终止时不再存在的内存单元引用。应<strong>避免</strong>编写如下代码：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210805165912018.png"                      alt="image-20210805165912018"                ></p><p><strong>该函数返回一个指向临时变量（newguy）的引用，函数运行完毕后 它将不再存在。同样，也应避免返回 指向临时变量的指针。</strong></p><p>为避免这种问题，最简单的方法是，返回一个作为参数传递给函数 的引用。作为参数的引用将指向调用函数使用的数据，因此返回的引用 也将指向这些数据。</p><p>4．为何将const用于引用返回类型</p><h3 id="8-2-5-将引用用于类对象"><a href="#8-2-5-将引用用于类对象" class="headerlink" title="8.2.5 将引用用于类对象"></a>8.2.5 将引用用于类对象</h3><p>将类对象传递给函数时，C++通常的做法是使用引用。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210805171059802.png"                      alt="image-20210805171059802"                ></p><h3 id="8-2-6-对象、继承和引用"><a href="#8-2-6-对象、继承和引用" class="headerlink" title="8.2.6 对象、继承和引用"></a>8.2.6 对象、继承和引用</h3><h3 id="8-2-7-何时使用引用参数"><a href="#8-2-7-何时使用引用参数" class="headerlink" title="8.2.7 何时使用引用参数"></a>8.2.7 何时使用引用参数</h3><p>使用引用参数的主要原因有两个:</p><ul><li>能够修改调用函数中的数据对象;</li><li>通过传递引用而不是整个数据对象，可以提高程序的运行速度。</li></ul><p>当数据对象较大时（如结构和类对象），第二个原因最重要。这些也是使用指针参数的原因。这是有道理的，因为引用参数实际上是基于指针的代码的另一个接口。</p><p><strong>以下总结使用引用的原则</strong>：</p><ul><li>如果数据对象很小。如内置数据类型或者小型数据结构，则按值传递；</li><li>如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为指向 const 的指针；</li><li>如果数据对象是较大的结构体，则使用 const 指针或者 const 引用，以便提升程序的效率。这样可以节省复制结构体所需的时间和空间；</li><li>如果数据对象是类对象，则使用 const 引用。类设计的语义常常要求使用引用，<strong>这是C++新增这项特性的主要原因。因此，传递类对象参数的标准方式是按引用传递</strong>。</li></ul><p>对于修改调用函数中数据的函数：</p><ul><li>如果数据对象是内置数据类型，则使用指针（不使用引用）。看到诸如：<code>fixit(&amp;x)</code> 这样的代码（x是int），则很明显，该函数将要修改x；</li><li>如果数据对象是数组，则只能使用指针；</li><li>如果数据对象是结构体，则可以使用引用或者指针；</li><li>如果数据对象是类对象，则（首选）使用引用。</li></ul><h2 id="8-3-默认参数"><a href="#8-3-默认参数" class="headerlink" title="8.3 默认参数"></a>8.3 默认参数</h2><p>默认参数指的是当函数调用中省略了实参时自动使用的一个值。例如：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">left</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> n=<span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure></div><p><strong>对于带参数列表的函数，必须从右向左添加默认值</strong>。也就是说，要为某个参数设置默认值，<strong>则必须为它右边的所有参数提供默认值</strong>：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">harpo</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m=<span class="number">4</span>, <span class="type">int</span> j=<span class="number">5</span>)</span></span>;      <span class="comment">// Valid</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chico</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m=<span class="number">6</span>, <span class="type">int</span> j)</span></span>;        <span class="comment">// IN-Valid</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">groucho</span><span class="params">(<span class="type">int</span> k=<span class="number">1</span>, <span class="type">int</span> m=<span class="number">2</span>, <span class="type">int</span> n=<span class="number">3</span>)</span></span>;  <span class="comment">// Valid</span></span><br></pre></td></tr></table></figure></div><p>实参按从左到右的顺序依次被赋给相应的形参，而不能跳过任何参数。</p><p><em><strong>默认参数只在声明函数的时候给出，定义函数时，则不需要给出</strong></em>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210807220518596.png"                      alt="image-20210807220518596"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210807220537984.png"                      alt="image-20210807220537984"                ></p><h2 id="8-4-函数重载"><a href="#8-4-函数重载" class="headerlink" title="8.4 函数重载"></a>8.4 函数重载</h2><p>函数多态是C++在C语言的基础上新增的功能。默认参数让我们能够使用不同数目的参数调用同一个函数，而函数多态（函数重载）让我们能够使用多个同名的函数，这称为函数重载，它们完成相同的工作，但使用不同的参数列表。</p><p><strong>函数重载的关键是函数的参数列表——也称为函数特征标 （function signature）</strong>。</p><p>如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。 C++允许定义名称相同的函数，条件是它们的特征标不同。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210807221358552.png"                      alt="image-20210807221358552"                ></p><p>一些看起来彼此不同的特征标是不能共存的。例如，请看下面的两 个原型：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span> x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">cube</span><span class="params">(<span class="type">double</span> &amp;x)</span></span>;</span><br></pre></td></tr></table></figure></div><p>可能认为可以在此处使用函数重载，因为它们的特征标看起来不同。然而，请从编译器的角度来考虑这个问题。假设有下面这样的代码：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">cube</span>(x);</span><br></pre></td></tr></table></figure></div><p>参数 <code>x</code> 与 <code>double x</code> 原型和 <code>double &amp;x</code> 原型都匹配，因此编译器无法确定究竟应使用哪个原型。为避免这种混乱，<strong>编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标</strong>。</p><p>请记住，<strong>是特征标(即，函数特征列表)，而不是函数返回类型使得可以对函数进行重载</strong>。 例 如，下面的两个声明是互斥的：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">gronk</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span> m)</span></span>;    <span class="comment">// same signatures,</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">gronk</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span> m)</span></span>;  <span class="comment">// hence not allowed</span></span><br></pre></td></tr></table></figure></div><p>因此，C++不允许以这种方式重载gronk( )。<strong>返回类型可以不同，但特征标也必须不同</strong>。</p><p>匹配函数时，并不区分<code>const</code>和非<code>const</code>变量（这就要小心了）。看下面的原型：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dribble</span><span class="params">(<span class="type">char</span> *bits)</span></span>;         <span class="comment">// overloaded</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dribble</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cbits)</span></span>;  <span class="comment">// overloaded</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dabble</span><span class="params">(<span class="type">char</span> *bits)</span></span>;          <span class="comment">// not overloaded</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">drivel</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *bits)</span></span>;    <span class="comment">// not overloaded</span></span><br></pre></td></tr></table></figure></div><h3 id="8-4-1-函数重载示例"><a href="#8-4-1-函数重载示例" class="headerlink" title="8.4.1 函数重载示例"></a>8.4.1 函数重载示例</h3><h3 id="8-4-2-何时使用函数重载"><a href="#8-4-2-何时使用函数重载" class="headerlink" title="8.4.2 何时使用函数重载"></a>8.4.2 何时使用函数重载</h3><p><strong>虽然函数重载很吸引人，但也不要滥用。仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载</strong>。</p><h2 id="8-5-函数模板"><a href="#8-5-函数模板" class="headerlink" title="8.5 函数模板"></a>8.5 函数模板</h2><p>现在的C++编译器实现了C++的另一个新增特性——函数模板。函数模板是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用具体的类型（如<code>int</code>或<code>double</code>）替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。由于模板允许以泛型（而不是具体类型）的方式编写程序，因此有时也被称为通用编程。由于类型是用参数表示的，因此模板特性有时也被称为参数化类型（parameterized types）。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210807224625424.png"                      alt="image-20210807224625424"                ></p><p>第一行指出，要建立一个模板，并将类型命名为 <code>AnyType</code>。关键字 <code>template</code>和 <code>typename</code> 是必需的，除非可以使用关键字 <code>class</code> 代替 <code>typename</code>。 另外，<strong>必须使用尖括号</strong>。类型名可以任意选择（这里为 <code>AnyType</code>），只要遵守C++命名规则即可；许多程序员都使用简单的名称，如 <code>T</code>。</p><p>模板并不创建任何函数，而只是告诉编译器如何定义函数。需要交换<code>int</code>的函数时，编译器将按模板 模式创建这样的函数，并用<code>int</code>代替<code>AnyType</code>。同样，需要交换<code>double</code>的函数时，编译器将按模板模式创建这样的函数，并用<code>double</code>代替 <code>AnyType</code>。</p><p>最终 的代码不包含任何模板，而只包含了为程序生成的实际函数。使用模板 的好处是，它使生成多个函数定义更简单、更可靠。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210807225139508.png"                      alt="image-20210807225139508"                ></p><p><code>typename</code>关键字使得参数<code>AnyType</code>表示类型这一点更为明显；然而，有大量代码库是使用关键字class开发的。在这种上下文中，<strong>这两个关键字是等价的</strong>。</p><p>需要多个对不同类型使用同一种算法的函数时，可使用模板。</p><h3 id="8-5-2-模板的局限"><a href="#8-5-2-模板的局限" class="headerlink" title="8.5.2 模板的局限"></a>8.5.2 模板的局限</h3><ul><li>下面的代码假定定义了赋 值，但如果T为数组，这种假设将不成立；</li><li>下面的语句假设定义了 <code>&lt;</code>，但如果T为结构，该假设便不成立；另外，为数组名定义了运算符 <code>&gt;</code>，但由于数组名为地址，因此它比较的是数组的地址，而这可能不是您希望的。</li></ul><p>总之，编写的模板函数很可能无法处理某些类型。另一方面，有时 候通用化是有意义的，但C++语法不允许这样做。</p><h3 id="8-5-3-显式具体化"><a href="#8-5-3-显式具体化" class="headerlink" title="8.5.3 显式具体化"></a>8.5.3 显式具体化</h3><blockquote><p>由于C++允许将一个结构赋给另一个结构，因此即使T是一个<code>job</code>结构，上述代码也适用。然而，假设只想交换 <code>salary</code> 和 <code>floor</code> 成员，而不交 换 <code>name</code> 成员，则需要使用不同的代码，但 <code>Swap()</code> 的参数将保持不变 （两个 <code>job</code> 结构的引用），因此无法使用模板重载来提供其他的代码。</p></blockquote><ul><li>对于给定的函数名，可以有非模板函数、模板函数和显式具体化模 板函数以及它们的重载版本；</li><li>显式具体化的原型和定义应以 <code>template&lt;&gt;</code> 打头，并通过名称来指出 类型；</li><li>具体化优先于常规模板，而非模板函数优先于具体化和常规模板。</li></ul><p>如果有多个原型，则编译器在选择原型时，<strong>非模板版本优先于显式具体化和模板版本，而显式具体化优先于使用模板生成的版本</strong>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210808001952681.png"                      alt="image-20210808001952681"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210808002201785.png"                      alt="image-20210808002201785"                ></p><h3 id="8-5-4-实例化和具体化"><a href="#8-5-4-实例化和具体化" class="headerlink" title="8.5.4 实例化和具体化"></a>8.5.4 实例化和具体化</h3><p>为进一步了解模板，必须理解术语实例化和具体化。记住，在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例（instantiation）。</p><p>函数调用<code>Swap(i,j</code>)导致编译器生成<code>Swap()</code>的一个实例，该实例使用<code>int</code>类型。<strong>模板并非函数定 义，但使用int的模板实例是函数定义</strong>。这种实例化方式被称为隐式实例 化（implicit instantiation），因为编译器之所以知道需要进行定义，是 由于程序调用Swap( )函数时提供了int参数。</p><p>最初，编译器只能通过隐式实例化，来使用模板生成函数定义，但现在C++还允许显式实例化（explicit instantiation）。这意味着可以直接 命令编译器创建特定的实例，如<code>Swap&lt;int&gt;()</code>。其语法是，声明所需的种类——用<code>&lt;&gt;</code>符号指示类型，并在声明前加上关键字 <code>template</code>：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="type">void</span> <span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// explicit instantiation</span></span><br></pre></td></tr></table></figure></div><p>实现了这种特性的编译器看到上述声明后，将使用<code>Swap()</code>模板生成 一个使用<code>int</code>类型的实例。也就是说，该声明的意思是“使用<code>Swap()</code>模板生成<code>int</code>类型的函数定义“。</p><p>与显式实例化不同的是，显式具体化使用下面两个等价的声明之 一：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> <span class="built_in">Swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> &amp;, <span class="type">int</span> &amp;);</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span> &amp;, <span class="type">int</span> &amp;)</span></span>;</span><br></pre></td></tr></table></figure></div><p>区别在于，这些声明的意思是“不要使用 <code>Swap()</code> 模板来生成函数定 义，而应使用专门为 <code>int</code> 类型显式地定义的函数定义”。这些原型必须有自己的函数定义。<strong>显式具体化声明在关键字 <code>template</code> 后包含 <code>&lt;&gt;</code>，而显式实例化没有</strong>。</p><p>隐式实例化、显式实例化和显式具体化统称为具体化 （specialization）。它们的相同之处在于，它们表示的都是使用具体类 型的函数定义，而不是通用描述。</p><p>引入显式实例化后，必须使用新的语法——在声明中使用前缀<code>template</code>和<code>template &lt;&gt;</code>，以区分显式实例化和显式具体化。通常，功能 越多，语法规则也越多。下面的代码片段总结了这些概念：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210808202129389.png"                      alt="image-20210808202129389"                ></p><h3 id="8-5-5-编译器选择使用哪个函数版本"><a href="#8-5-5-编译器选择使用哪个函数版本" class="headerlink" title="8.5.5 编译器选择使用哪个函数版本"></a>8.5.5 编译器选择使用哪个函数版本</h3><p>对于函数重载、函数模板和函数模板重载，C++需要（且有）一个 定义良好的策略，来决定为函数调用使用哪一个函数定义，尤其是有多 个参数时。这个过程称为重载解析（overloading resolution）: </p><ul><li>第1步：创建候选函数列表。其中包含与被调用函数的名称相同的函数和模板函数。</li><li>第2步：使用候选函数列表创建可行函数列表。这些都是参数数目 正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应 的形参类型完全匹配的情况。例如，使用float参数的函数调用可以 将该参数转换为double，从而与double形参匹配，而模板可以为 float生成一个实例;</li><li>第3步：确定是否有最佳的可行函数。如果有，则使用它，否则该 函数调用出错。</li></ul><p>接下来，编译器必须确定哪个可行函数是最佳的。它查看为使函数 调用参数与可行的候选函数的参数匹配所需要进行的转换。通常，从最 佳到最差的顺序如下所述：</p><ul><li>完全匹配，但常规函数优先于模板；</li><li>提升转换（例如，char和shorts自动转换为int，float自动转换为 double）；</li><li>标准转换（例如，int转换为char，long转换为double）；</li><li>用户定义的转换，如类声明中定义的转换。</li></ul><h3 id="8-5-6-模板函数的发展"><a href="#8-5-6-模板函数的发展" class="headerlink" title="8.5.6 模板函数的发展"></a>8.5.6 模板函数的发展</h3><h2 id="8-6-总结"><a href="#8-6-总结" class="headerlink" title="8.6 总结"></a>8.6 总结</h2><p>C++扩展了C语言的函数功能。通过将 inline 关键字用于函数定义， 并在首次调用该函数前提供其函数定义，可以使得C++编译器将该函数视为内联函数。也就是说，编译器不是让程序跳到独立的代码段，以执行函数，而是用相应的代码替换函数调用（相当于复制进去）。只有在函数很短时才能采用内联方式。</p><p>引用变量是一种伪装指针，它允许为变量创建别名（另一个名称）。引用变量主要被用作处理结构和类对象的函数的参数。</p><p>C++原型让您能够定义参数的默认值。如果函数调用省略了相应的参数，则程序将使用默认值；如果函数调用提供了参数值，则程序将使用这个值（而不是默认值）。只能在参数列表中从右到左提供默认参数。</p><p>函数的特征标是其参数列表。程序员可以定义两个同名函数，只要其特征标不同。这被称为函数多态或函数重载。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第八章-函数探幽&quot;&gt;&lt;a href=&quot;#第八章-函数探幽&quot; class=&quot;headerlink&quot; title=&quot;第八章 函数探幽&quot;&gt;&lt;/a&gt;第八章 函数探幽&lt;/h1&gt;&lt;p&gt;本章内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内联函数；&lt;/li&gt;
&lt;li&gt;引用变量；&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习</title>
    <link href="http://example.com/2023/01/29/C-Primer-Plus-1/chapter07/"/>
    <id>http://example.com/2023/01/29/C-Primer-Plus-1/chapter07/</id>
    <published>2023-01-29T05:45:15.000Z</published>
    <updated>2023-01-30T10:51:14.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-函数——C-的编程模块"><a href="#第七章-函数——C-的编程模块" class="headerlink" title="第七章 函数——C++的编程模块"></a>第七章 函数——C++的编程模块</h1><p>本周内容包括：</p><ul><li>函数基本知识；</li><li>函数原型；</li><li>按值传递函数参数；</li><li>设计处理数据的函数；</li><li>使用 <code>const</code> 指针参数；</li><li>设计处理文本字符串的函数；</li><li>设计处理结构的函数；</li><li>设计处理 <code>string</code> 对象的函数；</li><li>调用自身的函数（递归）；</li><li>指向函数的指数。</li></ul><h2 id="7-1-函数基本知识"><a href="#7-1-函数基本知识" class="headerlink" title="7.1 函数基本知识"></a>7.1 函数基本知识</h2><p>自定义函数三要素：</p><ul><li>函数定义；</li><li>函数原型；</li><li>调用函数。</li></ul><h3 id="7-1-1-定义函数"><a href="#7-1-1-定义函数" class="headerlink" title="7.1.1 定义函数"></a>7.1.1 定义函数</h3><p>函数有两类：没有返回值的函数和有返回值的函数。</p><p>函数定义通用格式：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionName</span><span class="params">(parameterList)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">statement</span>(s);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>C++ 对于返回值的类型有一定的限制：<strong>不能是数组</strong>，但可以是其他任何类型——整数、浮点数、指针，甚至可以是结构体和对象。</p><p><strong>C++ 函数返回值的原理是什么？</strong><br>首先，函数将返回值复制到指定的CPU寄存器或内存单元中将值返回；随后，调用程序将查看该内存单元。<strong>返回函数和调用函数必须就该内存单元中存储的数据的类型达成一致</strong>。函数原型将返回值类型告知调用程序，而函数定义命令被调用函数应返回什么类型的数据。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804133448677.png"                      alt="image-20210804133448677"                ></p><h3 id="7-1-2-函数原型和函数调用"><a href="#7-1-2-函数原型和函数调用" class="headerlink" title="7.1.2 函数原型和函数调用"></a>7.1.2 函数原型和函数调用</h3><ol><li>为什么需要函数原型</li></ol><p>原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型（如果有的话）以及参数的类型和数量告诉编译器。举个例子：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> volume = <span class="built_in">cube</span>(side);</span><br></pre></td></tr></table></figure></div><p>首先，原型告诉编译器，<code>cube()</code> 有一个 double 参数。如果程序没有 提供这样的参数，原型将让编译器能够捕获这种错误。其次，<code>cube()</code> 函数完成计算后，将把返回值放置在指定的位置——可能是 CPU 寄存器， 也可能是内存中。然后调用函数（这里为 <code>main()</code>）将从这个位置取得返回值。由于原型指出了 <code>cube()</code> 的类型为 double，因此编译器知道应检索多少个字节以及如何解释它们。如果没有这些信息，编译器将只能进行猜测，而编译器是不会这样做的。</p><p>为何编译器需要原型，它就不能在文件中进一步查找，以了解函数是如何定义的吗？这种方法的一个问题是效率不高。编译器在搜索文件的剩余部分时必须停止对 <code>main()</code> 的编译。一个更严重的问题是，函数甚至可能并不在文件中。C++ 允许将一个程序放 在多个文件中，单独编译这些文件，然后再将它们组合起来。在这种情况下，编译器在编译 <code>main()</code> 时，可能无权访问函数代码。如果函数位于库中，情况也将如此。避免使用函数原型的唯一方法是，在首次使用函数之前定义它，但这并不总是可行的。</p><ol start="2"><li>原型的语法</li></ol><p>函数原型是一条语句，因此必须以分号结束。获得原型最简单的方 法是，复制函数定义中的函数头，并添加分号。<br>函数原型不要求提供变量名，有类型列表就足够了。<strong>通常，在原型的参数列表中，可以包括变量名，也可以不包括。原 型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。</strong></p><ol start="3"><li>原型的功能</li></ol><p>它们可以极大地降低程序出错的几率。具体来说，原型 确保以下几点：</p><ul><li>编译器正确处理函数返回值；</li><li>编译器检查使用的参数数目是否正确；</li><li>编译器检查使用的参数类型是否正确，如果不正确，则转换为正确的类型。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804144730761.png"                      alt="image-20210804144730761"                ></p><p>仅当有意义时，原型化才会导致类型转换。例如，原型不会将整数转换为结构或指针。</p><p>在编译阶段进行的原型化被称为静态类型检查（static type checking）。</p><h2 id="7-2-函数参数和按值传递"><a href="#7-2-函数参数和按值传递" class="headerlink" title="7.2 函数参数和按值传递"></a>7.2 函数参数和按值传递</h2><p>C++通常按值传递参数，这意味着将 数值参数传递给函数，而后者将其赋给一个新的变量。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> volume = <span class="built_in">cube</span>(side);</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804145401521.png"                      alt="image-20210804145401521"                ></p><p>side 是一个变量，被调用时，该函数将创建一个新的名为x的double变量，并将其初 始化为5。这样，cube( )执行的操作将不会影响main( )中的数据，因为 cube( )使用的是side的副本，而不是原来的数据。</p><p><strong>在函数中声明的变量（包括参数）是该函数私有的。在函数被调用 时，计算机将为这些变量分配内存；在函数结束时，计算机将释放这些 变量使用的内存</strong>。这样的变量被称为局部变量，因为它们被限制在函数中。前面提到过，这样做有助于确保数据的完整性。这还意 味着，如果在main( )中声明了一个名为x的变量，同时在另一个函数中 也声明了一个名为x的变量，则它们将是两个完全不同的、毫无关系的变量。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804145526933.png"                      alt="image-20210804145526933"                ></p><h3 id="7-2-1-多个参数"><a href="#7-2-1-多个参数" class="headerlink" title="7.2.1 多个参数"></a>7.2.1 多个参数</h3><p>函数可以有多个参数。在调用函数时，只需使用逗号将这些参数分开即可。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804150422862.png"                      alt="image-20210804150422862"                ></p><p>它使用<code>cin&gt;&gt;ch</code>，而不是<code>cin.get(ch)</code>或<code>ch = cin.get()</code>来读取一个字符。这样做是有原因的。前面讲过，这两个<code>cin.get()</code> 函数读取所有的输入字符，包括空格和换行符，而 <code>cin&gt;&gt;</code> 跳过空格和换行符。当用户对程序提示作出响应时，必须在每行的最后按 <code>Enter</code> 键，以生成换行符。<code>cin&gt;&gt;ch</code> 方法可以轻松地<strong>跳过这些换行符</strong>，但当输入的下一个字符为数字时，<code>cin.get()</code> 将读取后面的换行符，虽然可以通过编程来避开这种麻烦，但比较简便的方法是像该程序那样使用 <code>cin</code>。</p><h2 id="7-3-函数和数"><a href="#7-3-函数和数" class="headerlink" title="7.3 函数和数"></a>7.3 函数和数</h2><p>需要将数组名作为参数传递给它，为使函数通用，而不限于特定长度的数组，还需要传递数组长度。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum_arr</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></div><p>方括号指出 <code>arr</code> 是一个数组，而方括号为空则表明，可以将任何长度的数组传递给该函数。但实际情况并非如此：<code>arr</code>实际上并不是数组，<strong>而是一个指针</strong>，好消息是，在编写函数的其余部分时，可以将 <code>arr</code> 看作是数组。</p><h3 id="7-3-1-函数如何使用指针来处理数组"><a href="#7-3-1-函数如何使用指针来处理数组" class="headerlink" title="7.3.1 函数如何使用指针来处理数组"></a>7.3.1 函数如何使用指针来处理数组</h3><p>在大多数情况下，C++和C语言一样，也将数组名视为指针。C++将数组名解释为其第一个元素的地址：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookies == &amp;cookies[<span class="number">0</span>];   <span class="comment">// array name is the address of first element</span></span><br></pre></td></tr></table></figure></div><p>首先，数组声明使用数组名来标记存储位置； 其次，对数组名使用sizeof将得到整个数组的长度（以字节为单位）； 第三，正如第4章指出的，将地址运算符&amp;用于数组名时，将返回整个数组的地址。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804152348446.png"                      alt="image-20210804152348446"                ></p><blockquote><p>当且仅当在函数头中或者函数原型中，<code>int *arr</code> 和 <code>int arr[]</code> 的含义是相同的。它们都指 arr 是一个 int 指针。</p></blockquote><p>对于数组，以下两个语句是恒等的：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[i] == *(arr+i);  <span class="comment">// values in two notations</span></span><br><span class="line">&amp;arr[i] == arr + i;  <span class="comment">// addresses in two notations</span></span><br></pre></td></tr></table></figure></div><h3 id="7-3-2-将数组作为参数意味着什么"><a href="#7-3-2-将数组作为参数意味着什么" class="headerlink" title="7.3.2 将数组作为参数意味着什么"></a>7.3.2 将数组作为参数意味着什么</h3><p>传递常规变量时，函数将使用该变量的拷贝；<strong>但传递数组时，函数将使用原来的数组（传地址）</strong>。实际上，这种区别并不违反C++按值传递的方法，<code>sum_arr()</code> 函数仍传递了一个值，这个值被赋给 一个新变量，但这个值是一个地址，而不是数组的内容。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804154353723.png"                      alt="image-20210804154353723"                ></p><p><strong>将数组地址作为参数可以节省复制整个数组所需的时间和内存</strong>。如果数组很大，则使用拷贝的系统开销将非常大；程序不仅需要更多的计算机内存，还需要花费时间来复制大块的数据。<strong>但另一方面，使用原始数据增加了破坏数据的风险</strong>。</p><p><code>sum_arr(cookies+4, 4)</code> 和 <code>sum_arr(&amp;cookies[4], 4)</code> 是等效的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804155245012.png"                      alt="image-20210804155245012"                ></p><h3 id="7-3-3-更多数组函数示"><a href="#7-3-3-更多数组函数示" class="headerlink" title="7.3.3 更多数组函数示"></a>7.3.3 更多数组函数示</h3><p>1．填充数组</p><p>2．显示数组及用const保护数组</p><p>创建显示数组内容的函数很简单。只需将数组名和填充的元素数目传递给函数，然后该函数使用循环来显示每个元素。然而，还有另一个问题——确保显示函数不修改原始数组。除非函数的目的就是修改传递给它的数据，否则应避免发生这种情况。使用普通参数时，这种保护将自动实现，这是由于C++按值传递数据，函数使用数据的副本。然而，接受数组名的函数将使用原始数据。为防止函数无意中修改数组的内容，可在声明形参时 使用关键字<code>const</code>：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show_array</span><span class="params">(<span class="type">const</span> <span class="type">double</span> arr[], <span class="type">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></div><p><code>show_array()</code> 将数组视为只读数据。</p><p>3．修改数组</p><p>在这个例子中，对数组进行的第三项操作是将每个元素与同一个重新评估因子相乘。需要给函数传递3个参数：因子、数组和元素数目。 该<strong>函数不需要返回值</strong>，因此其代码如下：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">revalue</span><span class="params">(<span class="type">double</span> r, <span class="type">double</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        arr[i] *= r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>由于这个函数将修改数组的值，因此在声明 <code>arr</code> 时，不能使用 <code>const</code>。</p><p>4．将上述代码组合起来</p><p>前面已经讨论了与该示例相关的重要编程细节，因此这里回顾一下 整个过程。<strong>我们首先考虑的是通过数据类型和设计适当的函数来处理数据，然后将这些函数组合成一个程序。有时也称为自下而上的程序设计 （bottom-up programming），因为设计过程从组件到整体进行。这种方 法非常适合于OOP——它首先强调的是数据表示和操纵</strong>。而传统的过程性编程倾向于从上而下的程序设计（top-down programming），首先指定模块化设计方案，然后再研究细节。这两种方法都很有用，最终的产品都是模块化程序。</p><p>6．数组处理函数的常用编写方式</p><p>假设要编写一个处理double数组的函数。如果该函数要修改数组， 其原型可能类似于下面这样：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f_modfiy</span><span class="params">(<span class="type">double</span> arr[], <span class="type">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure></div><p>如果函数不修改数组，其原型可能类似于下面这样：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _f_no_change(<span class="type">const</span> <span class="type">double</span> arr[], <span class="type">int</span> n);</span><br></pre></td></tr></table></figure></div><h3 id="7-3-4-使用数组区间的函数"><a href="#7-3-4-使用数组区间的函数" class="headerlink" title="7.3.4 使用数组区间的函数"></a>7.3.4 使用数组区间的函数</h3><p>对于处理数组的C++函数，必须将数组中的数据种类、数组的起始位置和数组中元素数量提交给它；传统的C&#x2F;C++方法是，将指向数组起始处的指针作为一个参数，将数组长度作为第二个参数（指针指出数组的位置和数据类型），这样便给函数提供找到所有数据所需的信息。</p><p>还有另一种给函数提供所需信息的方法，即指定元素区间 （range），这可以通过传递两个指针来完成：<strong>一个指针标识数组的开头，另一个指针标识数组的尾部</strong>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804170600111.png"                      alt="image-20210804170600111"                ></p><p>它将 <code>pt</code> 设置为指向要处理的第一个元素（<code>begin</code>指向的元素）的指针，并将<code>*pt</code>（元素的值）加入到 <code>total</code> 中。然后，循环通过递增操作来更新 <code>pt</code>，使之指向下一个元素。只要 <code>pt</code> 不等于 <code>end</code>，这一过程就将继续下去。当 <code>pt</code> 等于 <code>end</code> 时，它将指向区间中最后一个元素后面的一个位置，此时循环将结束。</p><h3 id="7-3-5-指针和-const"><a href="#7-3-5-指针和-const" class="headerlink" title="7.3.5 指针和 const"></a>7.3.5 指针和 <code>const</code></h3><p>将 <code>const</code> 用于指针有一些很微妙的地方，可以用两种不同的方式将 <code>const</code> 关键字用于指针。<strong>第一种方法是让指针指向一个常量对象</strong>，防止使用该指针来修改所指向的值，<strong>第二种方法是将指针本身声明为常量</strong>，这样可以防止改变指针指向的位置。</p><p>首先看一个指向常量的指针：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804171314723.png"                      alt="image-20210804171314723"                ></p><p>这里要求 <code>pt</code> 指向的是一个 <code>const int</code>，所以，赋值之后我们是不能用 <code>*pt</code> 来修改 age 的值的。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804171334907.png"                      alt="image-20210804171334907"                ></p><p>现在来看一个微妙的问题。pt的声明并不限定着它指向的值就必须得是一个常量，只是对pt来说，这个值是常量。例如，pt指向age，但age不是const。我们是可以直接通过 age 变量来修改 age 的值的，但不能使用 pt 指针来修改它。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804171429933.png"                      alt="image-20210804171429933"                ></p><blockquote><p>我觉得这类指针可以称为：<strong>只读指针</strong>。这个指针可以移动，但是它只能读出它所指向地址的内容，但是无法通过这个指针修改其中的数据。</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804171526205.png"                      alt="image-20210804171526205"                ></p><p>C++禁止第二种情况的原因很简单——如果将 <code>g_moon</code> 的地 址赋给 <code>pm</code>，那么就可以用 <code>pm</code> 来修改 <code>g_moon</code> 的值，这使得 <code>g_moon</code> 的 <code>const</code> 状态很荒谬，因此, <strong>C++禁止将 const 的地址赋给非 const 指针</strong>。</p><p><strong>假设有一个由 <code>const</code> 数据组成的数组则禁止将常量数组的地址赋给非常量指针将意味着不能将数组名作为参数传递给使用非常量形参的函数。</strong></p><p>只要条件允许，则应将指针形参声明为指向 <code>const</code> 的指针。</p><blockquote><p><strong>尽可能使用 const</strong>:<br>将指针参数声明为指向常量数据的指针有两个优点：</p><ul><li>避免由于无意间修改数据而导致的编程错误；</li><li>使用 <code>const</code> 使得函数能够处理 <code>const</code> 和非 <code>const</code> 实参，否则将只能接受非 <code>const</code> 数据。</li></ul></blockquote><p><code>const</code> 只能防止修改 <code>pt</code> 指向的值（这里为39），而不能防止修改 <code>pt</code> 的值。也就是说，可以将一个新地址赋给 <code>pt</code>。</p><p>第二种使用 <code>const</code> 的方式使得无法修改指针的值：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804172355209.png"                      alt="image-20210804172355209"                ></p><blockquote><p>这样的指针，我想将其称为：<strong>静止指针</strong>。指针本身定死在一个地址上了，但是地址里的内容是可以通过这个指针随便修改的。</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804172525799.png"                      alt="image-20210804172525799"                ></p><p>通常，将指针作为函数参数来传递时，可以使用指向<code>const</code>的指针来保护数据。</p><p>在该声明中使用 <code>const</code> 意味着 <code>show_array()</code> 不能修改传递给它的数组中的值。只要只有一层间接关系，就可以使用这种技术。例如，这里的数组元素是基本类型，但如果它们是指针或指向指针的指针，则不能使用 <code>const</code>。</p><h2 id="7-4-函数和二维数组"><a href="#7-4-函数和二维数组" class="headerlink" title="7.4 函数和二维数组"></a>7.4 函数和二维数组</h2><p>数组名被视为其地 址，因此，相应的形参是一个指针，就像一维数组一样。</p><p><code>Data</code> 是一个数组名，该数组有3个元素。第一个元素本身是一个数组，由4个 <code>int</code> 值组成。因此 <code>data</code> 的类型是指向由4个 <code>int</code> 组成的数组的指针，因此正确的原型如下：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> (*ar2)[<span class="number">4</span>], <span class="type">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure></div><p>还有另外一种格式，这种格式与上述原型的含义完全相同，但可读性更强：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> ar2[][<span class="number">4</span>], <span class="type">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure></div><p>对于二维数据，必须对指针 <code>ar2</code> 执行两次解除引用，才能得到数据。最简单的方法是使用方括号两次：<code>ar2[r][c]</code>。然而，如果不考虑难看的话，也可以使用运算符<code>*</code>两次：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar2[r][c] == *(*(ar2+r)+c);   <span class="comment">// 等效</span></span><br></pre></td></tr></table></figure></div><h2 id="7-5-函数和C-风格字符串"><a href="#7-5-函数和C-风格字符串" class="headerlink" title="7.5 函数和C-风格字符串"></a>7.5 函数和C-风格字符串</h2><p>C-风格字符串由一系列字符组成，以空值字符（<code>\0</code>）结尾。</p><h3 id="7-5-1-将C-风格字符串作为参数的函数"><a href="#7-5-1-将C-风格字符串作为参数的函数" class="headerlink" title="7.5.1 将C-风格字符串作为参数的函数"></a>7.5.1 将C-风格字符串作为参数的函数</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804204604444.png"                      alt="image-20210804204604444"                ></p><p>假设要将字符串作为参数传递给函数，则表示字符串的方式有三 种：</p><ul><li><code>char</code> 数组；</li><li>用引号括起的字符串常量（也称字符串字面值）；</li><li>被设置为字符串的地址的<code>char</code>指针。</li></ul><p>但上述3种选择的类型都是<code>char</code>指针（准确地说是<code>char*</code>），因此可 以将其作为字符串处理函数的参数。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210804214230755.png"                      alt="image-20210804214230755"                ></p><p>可以说是将字符串作为参数来传递，<strong>但实际传递的是字符串第一个字符的地址</strong>。这意味着字符串函数原型应将其表示字符串的形参声明为 <code>char *</code> 类型。</p><p>C-风格字符串与常规 <code>char</code> 数组之间的一个重要区别是，字符串有内置的结束字符。这意味着不必将字符串长度作为参数传递给函数，而函数可以使用循环依次检查字符串中的每个字符，直到遇到结尾的空值字符为止。</p><blockquote><p>不以空值字符结尾的char数组只是数组，而不是字符串。</p></blockquote><h3 id="7-5-2-返回C-风格字符串的函数"><a href="#7-5-2-返回C-风格字符串的函数" class="headerlink" title="7.5.2 返回C-风格字符串的函数"></a>7.5.2 返回C-风格字符串的函数</h3><p>函数无法返回一 个字符串，但可以返回字符串的地址，这样做的效率更高。这种设计（让函数返回一个指针，该指针指向 <code>new</code> 分配的内存）的缺点是，程序员必须记住使用 <code>delete</code>。</p><h2 id="7-6-函数和结构体"><a href="#7-6-函数和结构体" class="headerlink" title="7.6 函数和结构体"></a>7.6 函数和结构体</h2><p><strong>结构体变量的行为更接近于基本的单值变量</strong>。也就是说，与数组不同，结构体将其数据组合成单个实体或数据对象，该实体被视为一个整体。前面讲过，可以将一个结构体赋给另外一个结构体。同样，也<strong>可以按值传递结构体，就像普通变量那样</strong>。在这种情况下，函数将使用原始结构体的副本。另外，函数也可以返回结构体。**与数组名就是数组第一个元素的地址不同的是，结构体名只是结构体的名称，要获得结构的地址，必须使用地址运算符 <code>&amp;</code>**。</p><p>使用结构编程时，最直接的方式是像处理基本类型那样来处理结构体；也就是说，将结构体作为参数传递，并在需要时将结构体用作返回值使用。</p><h3 id="7-6-1-传递和返回结构体"><a href="#7-6-1-传递和返回结构体" class="headerlink" title="7.6.1 传递和返回结构体"></a>7.6.1 传递和返回结构体</h3><p>当结构体比较小时，按值传递结构体最合理。</p><h3 id="7-6-2-另一个处理结构的函数示例"><a href="#7-6-2-另一个处理结构的函数示例" class="headerlink" title="7.6.2 另一个处理结构的函数示例"></a>7.6.2 另一个处理结构的函数示例</h3><h3 id="7-6-3-传递结构体的地址"><a href="#7-6-3-传递结构体的地址" class="headerlink" title="7.6.3 传递结构体的地址"></a>7.6.3 传递结构体的地址</h3><p>假设要传递结构的地址而不是整个结构以节省时间和空间，则需要 重新编写前面的函数，使用指向结构的指针。首先来看一看如何重新编写 <code>show_polar()</code> 函数。需要修改三个地方：</p><ul><li>调用函数时，将结构的地址（<code>&amp;pplace</code>）而不是结构本身（<code>pplace</code>） 传递给它；</li><li>将形参声明为指向 <code>polar</code> 的指针，即<code>polar *</code>类型。由于函数不应该修改结构，因此使用了 <code>const</code> 修饰符；</li><li>由于形参是指针而不是结构，因此应间接成员运算符（<code>-&gt;</code>），而不是成员运算符（句点）。</li></ul><h2 id="7-7-函数和-string-对象"><a href="#7-7-函数和-string-对象" class="headerlink" title="7.7 函数和 string 对象"></a>7.7 函数和 <code>string</code> 对象</h2><p>可以将对象作为完整的实体进行传递，如果需要多个字符串，可以声明一个<code>string</code> 对象数组，而不是二维 <code>char</code> 数组。</p><h2 id="7-8-函数与-array-对象"><a href="#7-8-函数与-array-对象" class="headerlink" title="7.8 函数与 array 对象"></a>7.8 函数与 <code>array</code> 对象</h2><h2 id="7-9-递归"><a href="#7-9-递归" class="headerlink" title="7.9 递归"></a>7.9 递归</h2><p>C++函数有一种有趣的特点——可 以调用自己，但不允许main()调用自己，这种功能称为递归。</p><blockquote><p>我不喜欢递归，太耗资源，可读性还差。</p></blockquote><h3 id="7-9-1-包含一个递归调用的递归"><a href="#7-9-1-包含一个递归调用的递归" class="headerlink" title="7.9.1 包含一个递归调用的递归"></a>7.9.1 包含一个递归调用的递归</h3><h3 id="7-9-2-包含多个递归调用的递归"><a href="#7-9-2-包含多个递归调用的递归" class="headerlink" title="7.9.2 包含多个递归调用的递归"></a>7.9.2 包含多个递归调用的递归</h3><h2 id="7-10-函数指针"><a href="#7-10-函数指针" class="headerlink" title="7.10 函数指针"></a>7.10 函数指针</h2><p>与数据项相似，函数也有地址。函数的地址是存储其机器语言代码 的内存的开始地址。对程序而言很有用，可以编写以另一个函数的地址作为参数的函数。</p><p>这样第一个函数就可以找到第二个函数，并运行它。与直接调用另一个函数相比，这种方法很笨拙，但它允许在不同的情况下传递不同函数的地址，这意味着可以在不同的时间使用不同的函数。</p><h3 id="7-10-1-函数指针的基础知识"><a href="#7-10-1-函数指针的基础知识" class="headerlink" title="7.10.1 函数指针的基础知识"></a>7.10.1 函数指针的基础知识</h3><p>1．获取函数的地址<br>获取函数的地址很简单：只要<strong>使用函数名（后面不跟参数）即可</strong>。要将函数作为参数进行传递，必须传递函数名，要区分传递的是函数的地址还是函数的返回值。</p><p>2．声明函数指针</p><p>声明指向函数的指针时，必须指定指针指向的函数类型。意味着声明应指定函数的返回类型以及函数的特征标（参数列表）。也就是说，声明应像函数原型那样指出有关函数的信息：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210805084458826.png"                      alt="image-20210805084458826"                ></p><p>3．使用指针来调用函数</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210805084920592.png"                      alt="image-20210805084920592"                ></p><blockquote><p>为何pf和<code>(*pf</code>等价呢？一种学派认为，由于pf是函数指针，而 <code>*pf</code> 是函数，因此应将<code>(*pf)()</code>用作函数调用。另一种学派认为，由于函数名是指向该函数的指 针，指向函数的指针的行为应与函数名相似，因此应将pf( )用作函数调用使用。C++进行了折 衷——这2种方式都是正确的，或者至少是允许的，虽然它们在逻辑上是互相冲突的。在认为 这种折衷粗糙之前，应该想到，容忍逻辑上无法自圆其说的观点正是人类思维活动的特点。</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210805085227934.png"                      alt="image-20210805085227934"                ></p><p>可能看起来比较深奥，但指向函数指针数组的指针并不少见。实际上，类的虚方法实现通常都采用了这种技术（参见第13章）。</p><h3 id="7-10-4-使用typedef进行简化"><a href="#7-10-4-使用typedef进行简化" class="headerlink" title="7.10.4 使用typedef进行简化"></a>7.10.4 使用typedef进行简化</h3><p>这里采用的方法是，将别名当做标识符进行声明，并在开头使用关键字 <code>typedef</code>。<br>使用typedef可减少输入量，让您编写代码时不容易犯错，并让程序 更容易理解。</p><h3 id="7-11-总结"><a href="#7-11-总结" class="headerlink" title="7.11 总结"></a>7.11 总结</h3><p>函数是C++的编程模块。要使用函数，必须提供定义和原型，并调 用该函数。函数定义是实现函数功能的代码；函数原型描述了函数的接 口：传递给函数的值的数目和种类以及函数的返回类型。函数调用使得 程序将参数传递给函数，并执行函数的代码。</p><p>C++提供了3种表示C-风格字符串的方法：字符数组、字符串常量 和字符串指针。它们的类型都是<code>char*</code>（<code>char</code>指针），因此被作为<code>char*</code>类型参数传递给函数。C++使用空值字符 <code>\0</code> 来结束字符串，因此字符 串函数检测空值字符来确定字符串的结尾。</p><p>C++处理结构体的方式与基本类型完全相同，这意味着可以按值传递结构体，并将其用作函数返回类型。然而，如果结构体非常大，则传递结构体指针的效率将更高，同时函数能够使用原始数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第七章-函数——C-的编程模块&quot;&gt;&lt;a href=&quot;#第七章-函数——C-的编程模块&quot; class=&quot;headerlink&quot; title=&quot;第七章 函数——C++的编程模块&quot;&gt;&lt;/a&gt;第七章 函数——C++的编程模块&lt;/h1&gt;&lt;p&gt;本周内容包括：&lt;/p&gt;
&lt;ul&gt;</summary>
      
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习</title>
    <link href="http://example.com/2023/01/29/C-Primer-Plus-1/chapter09/"/>
    <id>http://example.com/2023/01/29/C-Primer-Plus-1/chapter09/</id>
    <published>2023-01-29T05:45:15.000Z</published>
    <updated>2023-01-30T10:51:25.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-内存模型和名称空间"><a href="#第九章-内存模型和名称空间" class="headerlink" title="第九章 内存模型和名称空间"></a>第九章 内存模型和名称空间</h1><p>本章内容包括：</p><ul><li>单独编译；</li><li>存储持续性、作用域和链接性；</li><li>定位（placement）new运算符；</li><li>名称空间。</li></ul><h2 id="9-1-单独编译"><a href="#9-1-单独编译" class="headerlink" title="9.1 单独编译"></a>9.1 单独编译</h2><p>第1章介绍过，可以单独编译文件，然后将它们链接成可执行的程序。通常，C++编译器既编译程序，也管理链接器。如果只修改了一个文件，则可以只重新编译该文件，然后将它与其他文件的编译版本链接，这使得大程序的管理更便捷。</p><p>例如，UNIX和Linux系统都具有make程 序，可以跟踪程序依赖的文件以及这些文件的最后修改时间。运行make 时，如果它检测到上次编译后修改了源文件，make将记住重新构建程序 所需的步骤。</p><p>例如但需要将一个结构体在多个文件中复用时，与其将结构体声明加入到每一个文件 中，不如将其放在头文件中，然后在每一个源代码文件中包含该头文件。这样，要修改结构体声明时，只需在头文件中做一次改动即可。另外，也可以将函数原型放在头文件中。因此，可以将原来的程序分成三 部分。</p><ul><li>头文件：包含结构体声明和使用这些结构体的函数的声明；</li><li>源代码文件：包含与结构体有关的函数代码；</li><li>源代码文件：包含调用与结构体相关的函数代码；</li></ul><p>这是一种非常有用的组织程序的策略。例如，如果编写另一个程序 时，也需要使用这些函数，则只需包含头文件，并将函数文件添加到项 目列表或make列表中即可。另外，这种组织方式也与OOP方法一致。<strong>一个文件（头文件）包含了用户定义类型的定义；另一个文件包含操纵用 户定义类型的函数的代码。这两个文件组成了一个软件包，可用于各种程序中</strong>。</p><p><strong>不要将函数定义或变量声明放到头文件中</strong>。这样做通常会引来麻烦，因为，如果在头文件包含了一个函数的定义，然后在（同一个程序的）另外两个文件中分别包含了该头文件，那么同一个程序中将包含同一个函数的两个定义，除非函数是内联的，否则这将出错。</p><p>头文件常包含的内容：</p><ul><li>函数原型（也叫函数声明）；</li><li>使用<code>#define</code>或<code>const</code>定义的符号常量；</li><li>结构体声明；</li><li>类声明；</li><li>模板声明；</li><li>内联函数。</li></ul><p>将结构体声明放在头文件中是可以的，因为它们不创建变量，而只是在源代码文件中声明结构体变量时，告诉编译器如何创建该结构体变量。同样，模板声明也不是将被编译的代码，它们指示编译器如何生成与源代码中函数调用相匹配的函数定义。被声明为<code>const</code>的常量和内联函数有特殊的链接属性（稍后将介绍），因此可以将其放在头文件中，而不会引 起问题。</p><p>在包含头文件时，我们使 用<code>&quot;coordin.h&quot;</code>，而不是 <code>&lt;coodin.h&gt;</code>。如果文件名包含在尖括号中，则 C++编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号中，<strong>则编译器将首先查找当前的工作目录或源代码目录（取决于编译器）</strong>，如果没有找到， 则将在标准位置查找。<strong>因此在包含自己的头文件时，应使用引号而不是 尖括号</strong>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210810163533843.png"                      alt="image-20210810163533843"                ></p><blockquote><p>在同一个文件中只能将同一个头文件包含一次。记住这个规则很容易，但很可能在不知 情的情况下将头文件包含多次。例如，可能使用包含了另外一个头文件的头文件。有一种标准的C&#x2F;C++技术可以避免多次包含同一个头文件。它是基于预处理器编译指令#ifndef（即if not defined）的。<code>#ifndef-#define-#endif</code> 语句的这种方法<strong>并不能防止编译器将文件包含两次，而只是让它忽略除第一次包含之外的所有内容</strong>。大多数标准C和C++头文件都使用这种防护 （guarding）方案。否则，可能在一个文件中定义同一个结构体、函数、类等两次，这将导致编译错误。</p></blockquote><h2 id="9-2-存储持续性、作用域和链接性"><a href="#9-2-存储持续性、作用域和链接性" class="headerlink" title="9.2 存储持续性、作用域和链接性"></a>9.2 存储持续性、作用域和链接性</h2><p>存储类别如何影响信息在文件间的共享？</p><ul><li>自动存储持续性：在<strong>函数定义中声明的变量</strong>（包括函数参数）的存 储持续性为自动的。在程序开始执行其所属的函数或代码块时 被创建，在执行完函数或代码块时，它们使用的内存被释放；</li><li>静态存储持续性：在函数<strong>定义外</strong>定义的变量和使用关键字<code>static</code>定义 的变量的存储持续性都为静态。它们在程序整个运行过程中都存在；</li><li>线程存储持续性（C++11）：如果变量是使用关键字<code>thread_local</code>声明的，则其生命 周期与所属的线程一样长；</li><li>动态存储持续性：用<code>new</code>运算符分配的内存将一直存在，直到使用 <code>delete</code>运算符将其释放或程序结束为止。这种内存的存储持续性为动态，有时被称为自由存储（free store）或堆（heap）。</li></ul><h3 id="9-2-1-作用域和链接"><a href="#9-2-1-作用域和链接" class="headerlink" title="9.2.1 作用域和链接"></a>9.2.1 作用域和链接</h3><p>作用域（scope）描述了名称在文件（翻译单元）的多大范围内可见。链接性（linkage）描述了名称如何在不同单元间共享。链接性为外部的 名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共 享。自动变量的名称没有链接性，因为它们不能共享。</p><p>作用域为局部的变量只在定义它的代码 块中可用。<strong>代码块是由花括号括起的一系列语句</strong>。例如函数体就是代码块，但可以在函数体中嵌入其他代码块。作用域为全局（也叫文件作用域）的变量在定义位置到文件结尾之间都可用。自动变量的作用域为局部，静态变量的作用域是全局还是局部取决于它是如何被定义的。在函数原型作用域（function prototype scope）中使用的名称只在包含参数列表的括号内可用（<strong>这就是为什么这些名称是什么以及是否出现都不重要的原因</strong>）。在类中声明的成员的作用域为整个类。在名 称空间中声明的变量的作用域为整个名称空间</p><h3 id="9-2-2-自动存储持续性"><a href="#9-2-2-自动存储持续性" class="headerlink" title="9.2.2 自动存储持续性"></a>9.2.2 自动存储持续性</h3><p>在默认情况下，在函数中声明的函数参数和变量的存储持续性为自 动，作用域为局部，没有链接性。</p><p>如果在代码块中定义了变量，则该变量的存在时间和作用域将被限 制在该代码块内。例子：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811100416035.png"                      alt="image-20210811100416035"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811100534389.png"                      alt="image-20210811100534389"                ></p><p>1．自动变量的初始化<br>2．自动变量和栈</p><p>由于自动变量的数目随函数的开始和结束而增减，因此程序必须 在运行时对自动变量进行管理。常用的方法是留出一段内存，并将其视为栈，以管理变量的增减。之所以被称为栈，是由于新数据被象征性地放在原有数据的上面（也就是说，在相邻的内存单元中，而不是在同一 个内存单元中），当程序使用完后，将其从栈中删除。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811110310770.png"                      alt="image-20210811110310770"                ></p><p>3．寄存器变量<br>这旨在提高访问变量的速度。</p><h3 id="9-2-3-静态持续变量"><a href="#9-2-3-静态持续变量" class="headerlink" title="9.2.3 静态持续变量"></a>9.2.3 静态持续变量</h3><p>要想创建链接性为外部的静态持续变量，必须在代码块的外面声明它；<br>要创建链接性为内部的静态持续变量，必须在代码块的外面声明它，并使用 <code>static</code> 限定符；<br>要创建没有链接性的静态持续变量，必须在代码块内声明它，并使用 <code>static</code> 限定符。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811110632232.png"                      alt="image-20210811110632232"                ></p><p>正如前面指出的，所有静态持续变量（上述示例中的<code>global</code>、 <code>one_file</code>和 <code>count</code>）在整个程序执行期间都存在。在 <code>funct1()</code> 中声明的变量 <code>count</code> 的作用域为局部，没有链接性，这意味着只能在<code>funct1()</code> 函数中使用它，就像自动变量 <code>llama</code> 一样。然而，与<code>llama</code> 不同的是，即使在 <code>funct1()</code> 函数没有被执行时，<code>count</code> 也留在内存中。<code>global</code> 和 <code>one_file</code> 的作用域都为整个文件，即在从声明位置到文件结尾的范围内都可以被使 用。具体地说，可以在 <code>main()</code>、<code>funct1()</code> 和 <code>funct2()</code> 中使用它们。由于<code> one_file</code> 的链接性为内部，因此只能在包含上述代码的文件中使用它； 由于 <code>global</code> 的链接性为外部，因此可以在程序的其他文件中使用它。</p><blockquote><p>应少用静态外部变量，如使用最好都声明为内部连接性的静态变量。</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811111319645.png"                      alt="image-20210811111319645"                ></p><h3 id="9-2-4-静态持续性、外部链接性"><a href="#9-2-4-静态持续性、外部链接性" class="headerlink" title="9.2.4 静态持续性、外部链接性"></a>9.2.4 静态持续性、外部链接性</h3><p>链接性为外部的变量通常简称为外部变量，它们的存储持续性为静 态，作用域为整个文件。外部变量是在函数外部定义的，因此对所有函 数而言都是外部的。</p><p>1．单定义规则<br>C++有“单定义规则”（One Definition Rule，ODR），该规则指出， 变量只能有一次定义。请注意，单定义规则并非意味着不能有多个变量的名称相同。例 如，在不同函数中声明的同名自动变量是彼此独立的，它们都有自己的 地址。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811111827133.png"                      alt="image-20210811111827133"                ></p><h3 id="9-2-5-静态持续性、内部链接性"><a href="#9-2-5-静态持续性、内部链接性" class="headerlink" title="9.2.5 静态持续性、内部链接性"></a>9.2.5 静态持续性、内部链接性</h3><p>将static限定符用于作用域为整个文件的变量时，该变量的链接性将 为内部的。在多文件程序中，内部链接性和外部链接性之间的差别很有 意义。链接性为内部的变量只能在其所属的文件中使用；但常规外部变 量都具有外部链接性，即可以在其他文件中使用。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811112129019.png"                      alt="image-20210811112129019"                ></p><blockquote><p>在多文件程序中，可以在一个文件（且只能在一个文件）中定义一个外部变量。使用该变量的其他文件必须使用关键字 <code>extern</code> 声明它。</p></blockquote><p>可使用外部变量在多文件程序的不同部分之间共享数据；可使用链接性为内部的静态变量在同一个文件中的多个函数之间共享数据（名称空间提供了另外一种共享数据的方法）。另外，如果将作用域为整个文 件的变量变为静态的，就不必担心其名称与其他文件中的作用域为整个 文件的变量发生冲突。</p><h3 id="9-2-6-静态存储持续性、无链接性"><a href="#9-2-6-静态存储持续性、无链接性" class="headerlink" title="9.2.6 静态存储持续性、无链接性"></a>9.2.6 静态存储持续性、无链接性</h3><p>这种变量是这样创建的，将static限定符用于在代码块中定义的变 量。在代码块中使用static时，将导致局部变量的存储持续性为静态的。 这意味着虽然该变量只在该代码块中可用，但它在该代码块不处于活动 状态时仍然存在。因此在两次函数调用之间，静态局部变量的值将保持 不变。（静态变量适用于再生——可以用它们将瑞士银行的秘密账号传 递到下一个要去的地方）。另外，如果初始化了静态局部变量，则程序 只在启动时进行一次初始化。以后再调用函数时，将不会像自动变量那样再次被初始化。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// static.cpp -- using a static local variable</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// constants</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ArSize = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// function prototype</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strcount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="type">char</span> input[ArSize];</span><br><span class="line">    <span class="type">char</span> next;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a line:\n&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">get</span>(input, ArSize);</span><br><span class="line">    <span class="keyword">while</span> (cin)</span><br><span class="line">    &#123;</span><br><span class="line">        cin.<span class="built_in">get</span>(next);</span><br><span class="line">        <span class="keyword">while</span> (next != <span class="string">&#x27;\n&#x27;</span>)    <span class="comment">// string didn&#x27;t fit!</span></span><br><span class="line">            cin.<span class="built_in">get</span>(next);      <span class="comment">// dispose of remainder</span></span><br><span class="line">        <span class="built_in">strcount</span>(input);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Enter next line (empty line to quit):\n&quot;</span>;</span><br><span class="line">        cin.<span class="built_in">get</span>(input, ArSize);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Bye\n&quot;</span>;</span><br><span class="line"><span class="comment">// code to keep window open for MSVC++</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cin.clear();</span></span><br><span class="line"><span class="comment">    while (cin.get() != &#x27;\n&#x27;)</span></span><br><span class="line"><span class="comment">        continue;</span></span><br><span class="line"><span class="comment">    cin.get();</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">strcount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> total = <span class="number">0</span>;        <span class="comment">// static local variable</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;               <span class="comment">// automatic local variable</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt;<span class="string">&quot;\&quot; contains &quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (*str++)               <span class="comment">// go to end of string</span></span><br><span class="line">        count++;</span><br><span class="line">    total += count;</span><br><span class="line">    cout &lt;&lt; count &lt;&lt; <span class="string">&quot; characters\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; total &lt;&lt; <span class="string">&quot; characters total\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811112939105.png"                      alt="image-20210811112939105"                ></p><p>注意，在这个程序中，由于数组长度为10，因此程序从每行读取的字符数都不超过 9个。另外还需要注意的是，每次函数被调用时，自动变量count都被重 置为0。然而，静态变量total只在程序运行时被设置为0，以后在两次函 数调用之间，其值将保持不变，因此能够记录读取的字符总数。</p><h3 id="9-2-7-说明符和限定符"><a href="#9-2-7-说明符和限定符" class="headerlink" title="9.2.7 说明符和限定符"></a>9.2.7 说明符和限定符</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811113430209.png"                      alt="image-20210811113430209"                ></p><ol start="3"><li>再谈const</li></ol><p>在C++（但不是在C语言）中，<code>const</code>限定符对默认存储类型稍有影响。在默认情况下全局变量的链接性为外部的，<strong>但<code>const</code>全局变量的链接性为内部的</strong>。也就是说，在C++看来，全局 <code>const</code> 定义就像使用了 <code>static</code> 说明符一样。</p><p>C++修改了常量类型的规则，让程序员更轻松。例如，假设将一组 常量放在头文件中，并在同一个程序的多个文件中使用该头文件。那 么，预处理器将头文件的内容包含到每个源文件中后，所有的源文件都 将包含类似下面这样的定义：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> fingers = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *waring = <span class="string">&quot;wak!&quot;</span>;</span><br></pre></td></tr></table></figure></div><p>如果全局const声明的链接性像常规变量那样是外部的，则根据单定 义规则，这将出错（幸亏不是）。</p><p>由于外部定义的<code>const</code>数据的链接性为内部的，因此可以在所有文件中使用相同的声明。</p><h3 id="9-2-8-函数和链接性"><a href="#9-2-8-函数和链接性" class="headerlink" title="9.2.8 函数和链接性"></a>9.2.8 函数和链接性</h3><p>和变量一样，函数也有链接性，虽然可选择的范围比变量小。和C 语言一样，C++不允许在一个函数中定义另外一个函数，因此所有函数 的存储持续性都自动为静态的，即在整个程序执行期间都一直存在。在 默认情况下，函数的链接性为外部的，即可以在文件间共享。实际上， 可以在函数原型中使用关键字extern来指出函数是在另一个文件中定义 的，不过这是可选的。<strong>还可以使用关键字<code>static</code>将函数的链接性设置为内部的，使之只能在一个文件中使用</strong>，但必须同时在原型和函数定义中使用该关键字。</p><h3 id="9-2-9-语言链接性"><a href="#9-2-9-语言链接性" class="headerlink" title="9.2.9 语言链接性"></a>9.2.9 语言链接性</h3><p>在 C++中，同一个名称可能对应多个函数，必须将这些函数翻译为不同的 符号名称。因此，C++编译器执行名称矫正或名称修饰（参见第8 章），为重载函数生成不同的符号名称。例如，可能将<code>spiff(int)</code>转换 为 <code>_spoff_i</code>，而将 <code>spiff(double，double)</code> 转换为 <code>_spiff_d_d</code>。这种方法被称为C++语言链接（C++ language linkage）。</p><h3 id="9-2-10-存储方案和动态分配"><a href="#9-2-10-存储方案和动态分配" class="headerlink" title="9.2.10 存储方案和动态分配"></a>9.2.10 存储方案和动态分配</h3><p>动态内存由运算符 <code>new</code> 和 <code>delete</code> 控制，而不是由作用域和链接性规则控制。因此，<strong>可以在一个函数中分配动态内存，而在另一个函数中将其释放</strong>。与自动内存不同，动态内存不是LIFO，其分配和释放顺序要取决于 <code>new</code> 和 <code>delete</code> 在何时以何种方式被使用。通常，编译器使用三块独立的内存：一块用 于静态变量（可能再细分），一块用于自动变量，另外一块用于动态存 储。</p><h2 id="9-3-名称空间"><a href="#9-3-名称空间" class="headerlink" title="9.3 名称空间"></a>9.3 名称空间</h2><p>名称可以是变量、函数、结构体、枚举、类以及类和结构体的成员。C++标准提供了名称空间工具，以便更好地控制名称的作用域。</p><h3 id="9-3-1-传统的C-名称空间"><a href="#9-3-1-传统的C-名称空间" class="headerlink" title="9.3.1 传统的C++名称空间"></a>9.3.1 传统的C++名称空间</h3><p>C++关于全局变量和局部变量的规则定义了一种名称空间层次。每 个声明区域都可以声明名称，这些名称独立于在其他声明区域中声明的 名称。在一个函数中声明的局部变量不会与在另一个函数中声明的局部 变量发生冲突。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811114957087.png"                      alt="image-20210811114957087"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811115021641.png"                      alt="image-20210811115021641"                ></p><h3 id="9-3-2-新的名称空间特性"><a href="#9-3-2-新的名称空间特性" class="headerlink" title="9.3.2 新的名称空间特性"></a>9.3.2 新的名称空间特性</h3><p>C++新增了这样一种功能，即通过定义一种新的声明区域来创建命 名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名 称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允 许程序的其他部分使用该名称空间中声明的东西。</p><p>名称空间可以是全局的，也可以位于另一个名称空间中，<strong>但不能位于代码块中</strong>。因此，在默认情况下，在名称空间中声明的名称的链接性 为外部的（除非它引用了常量）。</p><p>1．using声明和using编译指令</p><p>using声明由被限定的名称和它前面的关键字using组成：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Jill::fetch;        <span class="comment">// a using declaration</span></span><br></pre></td></tr></table></figure></div><p><code>using</code> 声明将特定的名称添加到它所属的声明区域中。例如 <code>main()</code> 中的 <code>using</code> 声明 <code>Jill::fetch</code> 将 <code>fetch</code> 添加到 <code>main()</code> 定义的声明区域中。完成该声明后，便可以使用名称 <code>fetch</code> 代替 <code>Jill::fetch</code>。</p><p>using声明使一个名称可用，而using编译指令使所有的名称都可 用。using编译指令由名称空间名和它前面的关键字using namespace组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符。在全局声明区域中使用using编译指令，将使该名称空间的名称全局可用。</p><p>2．using编译指令和using声明之比较</p><p>一般说来，使用<code>using</code>声明比使用<code>using</code>编译指令更安全，这是由于它只导入指定的名称。如果该名称与局部名称发生冲突，编译器将发出 指示。<code>using</code> 编译指令导入所有名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。</p><p>3．名称空间的其他特性<br>可以将名称空间声明进行嵌套。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811135518193.png"                      alt="image-20210811135518193"                ></p><p>这里，flame指的是element::fire::flame。同样，可以使用下面的 using编译指令使内部的名称可用。</p><p>4．未命名的名称空间</p><p>可以通过省略名称空间的名称来创建未命名的名称空间。</p><p>该名称空间中声明的名称的潜在作用域为：从声明点到该声明区域末尾，这与全局变量相似。然而，这种名称空间没有名称，因此不能显式地使用 <code>using</code> 编译指令或 <code>using</code> 声明来使它在其他位置都可用。也就是说，不能在未命名名称空间所属文件之外的其他文件中，使用该名称空间中的名称。这相当于是一个链接性为内部的静态变量的替代品。</p><h3 id="9-3-4-名称空间及其前途"><a href="#9-3-4-名称空间及其前途" class="headerlink" title="9.3.4 名称空间及其前途"></a>9.3.4 名称空间及其前途</h3><p>使用名称空间的原则：</p><ul><li>使用在已命名的名称空间中声明的变量，而不是使用外部全局变量；</li><li>使用在已命名的名称空间中声明的变量，而不是使用静态全局变量；</li><li>如果开发了一个函数库或类库，将其放在一个名称空间中；</li><li>仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计；</li><li>不要在头文件中使用 <code>using</code> 编译指令。首先，这样做掩盖了要让哪些名称可用；另外，包含头文件的顺序可能影响程序的行为。如果非要使用编译指令 <code>using</code>，应将其放在所有预处理器编译指令 <code>#include</code> 之后；</li><li>导入名称时，首选使用作用域解析运算符或using声明的方法；</li><li>对于using声明，首选将其作用域设置为局部而不是全局。</li></ul><h2 id="9-4-总结"><a href="#9-4-总结" class="headerlink" title="9.4 总结"></a>9.4 总结</h2><p>C++提倡在开发程序时使用多个文件。一种有效的组织策略 是，使用头文件来定义用户类型，为操纵用户类型的函数提供函数原 型；并将函数定义放在一个独立的源代码文件中。头文件和源代码文件 一起定义和实现了用户定义的类型及其使用方式。</p><p>C++的存储方案决定了变量保留在内存中的时间（储存持续性）以 及程序的哪一部分可以访问它（作用域和链接性）。</p><p>动态内存分配和释放是使用new和delete进行的，它使用自由存储区 或堆来存储数据。调用new占用内存，而调用delete释放内存。程序使用 指针来跟踪这些内存单元。</p><p>名称空间允许定义一个可在其中声明标识符的命名区域。这样做的 目的是减少名称冲突，尤其当程序非常大，并使用多个厂商的代码时。可以通过使用作用域解析运算符、using声明或using编译指令，来使名 称空间中的标识符可用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第九章-内存模型和名称空间&quot;&gt;&lt;a href=&quot;#第九章-内存模型和名称空间&quot; class=&quot;headerlink&quot; title=&quot;第九章 内存模型和名称空间&quot;&gt;&lt;/a&gt;第九章 内存模型和名称空间&lt;/h1&gt;&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单独编译；</summary>
      
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习</title>
    <link href="http://example.com/2023/01/29/C-Primer-Plus-1/chapter10/"/>
    <id>http://example.com/2023/01/29/C-Primer-Plus-1/chapter10/</id>
    <published>2023-01-29T05:45:15.000Z</published>
    <updated>2023-01-30T10:51:29.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十章-对象和类"><a href="#第十章-对象和类" class="headerlink" title="第十章 对象和类"></a>第十章 对象和类</h1><p>本章内容包括：</p><ul><li>过程性编程和面向对象编程；</li><li>类概念；</li><li>如何定义和实现类；</li><li>公有类访问和私有类访问；</li><li>类的数据成员；</li><li>类方法（类成员函数）；</li><li>创建和使用类对象；</li><li>类的构造函数和析构函数；</li><li>const 成员函数；</li><li>this 指针；</li><li>创建对象数组；</li><li>类作用域；</li><li>抽象数据类型。</li></ul><p>面向对象编程（OOP）是一种特殊的、设计程序的概念性方法，OOP的最终特性是：</p><ul><li>抽象；</li><li>封装和数据隐藏；</li><li>多态；</li><li>继承；</li><li>代码的可重用性。</li></ul><p>为了实现这些特性并将它们组合在一起，C++所做的最重要的改进 是提供了类。</p><h2 id="10-1-过程性编程和面向对象编程"><a href="#10-1-过程性编程和面向对象编程" class="headerlink" title="10.1 过程性编程和面向对象编程"></a>10.1 过程性编程和面向对象编程</h2><p>采用过程性编程方法时，首先考虑要遵循的步骤，然后考虑 如何表示这些数据。<br>如果换成一位OOP程序员，又将如何呢？首先考虑数据——不仅要 考虑如何表示数据，还要考虑如何使用数据。<br>用户与数据交互的方式有三种：初始化、更新和报告——这就是用户接口。</p><p>总之，采用OOP方法时，首先从用户的角度考虑对象——描述对象 所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述 后，需要确定如何实现接口和数据存储。最后，使用新的设计方案创建 出程序。</p><h2 id="10-2-抽象和类"><a href="#10-2-抽象和类" class="headerlink" title="10.2 抽象和类"></a>10.2 抽象和类</h2><p>生活中充满复杂性，处理复杂性的方法之一是简化和抽象。</p><h3 id="10-2-1-类型是什么"><a href="#10-2-1-类型是什么" class="headerlink" title="10.2.1 类型是什么"></a>10.2.1 类型是什么</h3><p>首先，倾向于根 据数据的外观（在内存中如何存储）来考虑数据类型。但是稍加思索就会 发现，也可以根据要对它执行的操作来定义数据类型。总之，指定基本类型完成了三项工作：</p><ul><li>决定数据对象需要的内存数量；</li><li>决定如何解释内存中的位（<code>long</code> 和 <code>float</code>在内存中占用的位数相同，但将它们转换为数值的方法不同）；</li><li>决定可使用数据对象执行的操作或方法。</li></ul><h3 id="10-2-2-C-中的类"><a href="#10-2-2-C-中的类" class="headerlink" title="10.2.2 C++中的类"></a>10.2.2 C++中的类</h3><p>类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和 操纵数据的方法组合成一个整洁的包。</p><p>定义类时，一般来说，类规范由两个部分组成：</p><ul><li>类声明：以数据成员的方式描述数据部分，以成员函数（称为方法）的方式描述共有接口；</li><li>类方法定义：描述如何类成员函数。</li></ul><p>简单地说，类声明提供了类的蓝图，而方法定义则提供了细节。例子：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stock00.h -- Stock class interface</span></span><br><span class="line"><span class="comment">// version 00</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STOCK00_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STOCK00_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span>  <span class="comment">// class declaration</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string company;</span><br><span class="line">    <span class="type">long</span> shares;</span><br><span class="line">    <span class="type">double</span> share_val;</span><br><span class="line">    <span class="type">double</span> total_val;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123; total_val = shares * share_val; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">acquire</span><span class="params">(<span class="type">const</span> std::string &amp; co, <span class="type">long</span> n, <span class="type">double</span> pr)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buy</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sell</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;    <span class="comment">// note semicolon at the end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div><p>首先， C++关键字class指出这些代码定义了一个类设计。</p><p>1．访问控制</p><p>关键字 <code>private</code> 和 <code>public</code> 也是新的，它们描述了对类成员的访问控制。使用类对象的程序都可以直接访问公有部分，但只能通过公有成员 函数（或友元函数，参见第11章）来访问对象的私有成员。</p><p>因此，公有成员函 数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏（参见图10.1）。C++还提 供了第三个访问控制关键字protected，第13章介绍类继承时将讨论该关 键字。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811220839703.png"                      alt="image-20210811220839703"                ></p><p>类设计尽可能将公有接口与实现细节分开。公有接口表示设计的抽 象组件。<strong>将实现细节放在一起并将它们与抽象分开被称为封装。</strong>数据隐藏（将数据放在类的私有部分中）是一种封装，将实现的细节隐藏在私 有部分中，就像<code>Stock</code>类对<code>set_tot()</code> 所做的那样，也是一种封装。封装的 另一个例子是，将类函数定义和类声明放在不同的文件中。</p><blockquote><p>OOP是一种编程风格，从某种程度说，它用于任何一种语言中。</p></blockquote><p>数据隐藏不仅可以防止直接访问数据，还让开发者（类的用户）无需了解数据是如何被表示的。从使用类的角度看，使用哪种方 法没有什么区别。所需要知道的只是各种成员函数的功能；也就是说，需要知道成员函数接受什么样的参数以及返回什么类型的值。原则是将实现细节从接口设计中分离出来。如果以后找到了更好的、实现数据表 示或成员函数细节的方法，可以对这些细节进行修改，而无需修改程序接口，这使程序维护起来更容易。</p><p>2．控制对成员的访问：公有还是私有</p><p>无论类成员是数据成员还是成员函数，都可以在类的公有部分或私 有部分中声明它。但由于隐藏数据是OOP主要的目标之一，因此数据项 通常放在私有部分，组成类接口的成员函数放在公有部分；否则，就无 法从程序中调用这些函数。</p><h3 id="10-2-3-实现类成员函数"><a href="#10-2-3-实现类成员函数" class="headerlink" title="10.2.3 实现类成员函数"></a>10.2.3 实现类成员函数</h3><p>还需要创建类描述的第二部分：为那些由类声明中的原型表示的成 员函数提供代码。成员函数定义与常规函数定义非常相似，它们有函数 头和函数体，也可以有返回类型和参数。但是它们还有两个特殊的特征：</p><ul><li>定义成员函数时，使用作用域解析运算符 <code>::</code> 来标识函数所属的类；</li><li>类方法可以访问类的 <code>private</code> 组件。</li></ul><p>例如：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::update</span><span class="params">(<span class="type">double</span> price)</span> </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>作用域解析运算符确定了方法定义对应的类的身份。</p><p>类方法的第二个特点是，方法可以直接访问类的私有成员，<strong>如同访问一个已经声明好的常用变量一样</strong>。例如，show( ) 方法可以使用这样的代码：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stock::show</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Company: &quot;</span> &lt;&lt; company</span><br><span class="line">              &lt;&lt; <span class="string">&quot;  Shares: &quot;</span> &lt;&lt; shares &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;  Share Price: $&quot;</span> &lt;&lt; share_val</span><br><span class="line">              &lt;&lt; <span class="string">&quot;  Total Worth: $&quot;</span> &lt;&lt; total_val &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>其中，company、shares等都是Stock类的私有数据成员。</p><p>另外，类声明常将短小的成员函数作为内联函数在头文件中随类声明一起定义。</p><blockquote><p>内联函数的特殊规则要求在每个使用它们的文件中都对其进行定 义。确保内联定义对多文件程序中的所有文件都可用的、最简便的方法是：<strong>将内联定义放在定义类的头文件中</strong>。</p></blockquote><p><strong>所创建的每个新对象都有自己的存储空间，用于存储其内部变量和 类成员；但同一个类的所有对象共享同一组类方法，即每种方法只有一 个副本</strong>。例如，假设 <code>kate</code> 和 <code>joe</code> 都是 <code>Stock</code> 对象，则 <code>kate.shares</code> 将占据一个 内存块，而 <code>joe.shares</code> 占用另一个内存块，但<code>kate.show()</code> 和 <code>joe.show()</code> 都调用同一个方法，也就是说，<strong>它们将执行同一个代码块</strong>，只是将这些代码用于不同的数据。在OOP中，调用成员函数被称为发送消息，因此将 同样的消息发送给两个不同的对象将调用同一个方法，但该方法被用于两个不同的对象。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811222542618.png"                      alt="image-20210811222542618"                ></p><h3 id="10-2-4-使用类"><a href="#10-2-4-使用类" class="headerlink" title="10.2.4 使用类"></a>10.2.4 使用类</h3><p>使用类与使用基本的内置类型（如int和char）尽可能相同。要创建类对象，可以声明类变量，也可以使用 <code>new</code> 为类对象分配存储空间。可以将对象作为函数的参数和返回值，也可以将一个对象赋给另一个。</p><p>要使用新类型，最关键的是要了解成员函数的功能，而不必考虑 其实现细节。</p><h3 id="10-2-5-修改实现"><a href="#10-2-5-修改实现" class="headerlink" title="10.2.5 修改实现"></a>10.2.5 修改实现</h3><h3 id="10-2-6-小结"><a href="#10-2-6-小结" class="headerlink" title="10.2.6 小结"></a>10.2.6 小结</h3><p>指定类设计的第一步是提供类声明。类声明类似结构声明，可以包 括数据成员和函数成员。声明有私有部分，在其中声明的成员只能通过 成员函数进行访问；声明还具有公有部分，在其中声明的成员可被使用 类对象的程序直接访问。通常，数据成员被放在私有部分中，成员函数 被放在公有部分中，因此典型的类声明的格式如下：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811223153090.png"                      alt="image-20210811223153090"                ></p><h2 id="10-3-类的构造函数和析构函数"><a href="#10-3-类的构造函数和析构函数" class="headerlink" title="10.3 类的构造函数和析构函数"></a>10.3 类的构造函数和析构函数</h2><p>C++的目标之一是让使用类对象就像使用标准类型一样。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811223501009.png"                      alt="image-20210811223501009"                ></p><p>一般来说，最好是在创建对象时对它进行初始化。</p><p>就Stock类当前的实现而言，gift对象的company成员是没有值的。 类设计假设用户在调用任何其他成员函数之前调用acquire( )，但无法强 加这种假设。避开这种问题的方法之一是在创建对象时，自动对它进行 初始化。为此，C++提供了一个特殊的成员函数——类构造函数，专门 用于构造新对象、将值赋给它们的数据成员。名称与类名相同。例如，Stock类一个可能的构造函数是名为Stock( )的成员函 数。<strong>构造函数的原型和函数头有一个有趣的特征——虽然没有返回值， 但没有被声明为void类型。实际上，构造函数没有声明类型</strong>。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stock10.h &lt;96&gt; Stock class declaration with constructors, destructor added</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STOCK1_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STOCK1_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stock</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string company;</span><br><span class="line">    <span class="type">long</span> shares;</span><br><span class="line">    <span class="type">double</span> share_val;</span><br><span class="line">    <span class="type">double</span> total_val;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123; total_val = shares * share_val; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Stock</span>();        <span class="comment">// default constructor</span></span><br><span class="line">    <span class="built_in">Stock</span>(<span class="type">const</span> std::string &amp; co, <span class="type">long</span> n = <span class="number">0</span>, <span class="type">double</span> pr = <span class="number">0.0</span>);  <span class="comment">// reload constructor;</span></span><br><span class="line">    ~<span class="built_in">Stock</span>();       <span class="comment">// noisy destructor</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">buy</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sell</span><span class="params">(<span class="type">long</span> num, <span class="type">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">double</span> price)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div><p>程序声明对 象时，将自动调用构造函数。</p><h3 id="10-3-1-声明和定义构造函数"><a href="#10-3-1-声明和定义构造函数" class="headerlink" title="10.3.1 声明和定义构造函数"></a>10.3.1 声明和定义构造函数</h3><p>通常定义两个构造函数：一个默认空参数，在未提供显式初始值时，用来创建对象；另一个则提供对私有变量做初始化的参数。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stock1.cpp &lt;96&gt; Stock class implementation with constructors, destructor added</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stock10.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// constructors (verbose versions)</span></span><br><span class="line">Stock::<span class="built_in">Stock</span>()        <span class="comment">// default constructor</span></span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default constructor called\n&quot;</span>;</span><br><span class="line">    company = <span class="string">&quot;no name&quot;</span>;</span><br><span class="line">    shares = <span class="number">0</span>;</span><br><span class="line">    share_val = <span class="number">0.0</span>;</span><br><span class="line">    total_val = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stock::<span class="built_in">Stock</span>(<span class="type">const</span> std::string &amp; co, <span class="type">long</span> n, <span class="type">double</span> pr)</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Constructor using &quot;</span> &lt;&lt; co &lt;&lt; <span class="string">&quot; called\n&quot;</span>;</span><br><span class="line">    company = co;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Number of shares can&#x27;t be negative; &quot;</span></span><br><span class="line">                   &lt;&lt; company &lt;&lt; <span class="string">&quot; shares set to 0.\n&quot;</span>;</span><br><span class="line">        shares = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        shares = n;</span><br><span class="line">    share_val = pr;</span><br><span class="line">    <span class="built_in">set_tot</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="10-3-2-使用构造函数"><a href="#10-3-2-使用构造函数" class="headerlink" title="10.3.2 使用构造函数"></a>10.3.2 使用构造函数</h3><p>C++提供了两种使用构造函数来初始化对象的方式。第一种方式是 显式地调用构造函数：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Stock food = <span class="built_in">Stock</span>(<span class="string">&quot;World Cabbage&quot;</span>, <span class="number">250</span>, <span class="number">1.25</span>);</span><br></pre></td></tr></table></figure></div><p>另一种方式是隐式地调用构造函数：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stock <span class="title">garment</span><span class="params">(<span class="string">&quot;Furry Mason&quot;</span>, <span class="number">50</span>, <span class="number">2.5</span>)</span></span>;</span><br></pre></td></tr></table></figure></div><p>这种格式更紧凑，它与下面的显式调用等价。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock garment = <span class="built_in">Stock</span>(<span class="string">&quot;Furry Mason&quot;</span>, <span class="number">50</span>, <span class="number">2.5</span>);</span><br></pre></td></tr></table></figure></div><p>每次创建类对象（包括使用 <code>new</code> 动态分配内存）时，C++都使用类构造函数。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock *pstock = <span class="keyword">new</span> <span class="built_in">Stock</span>(<span class="string">&quot;Electrosgock Games&quot;</span>, <span class="number">18.</span> <span class="number">19.0</span>);</span><br></pre></td></tr></table></figure></div><p>这条语句创建一个Stock对象，将其初始化为参数提供的值，并将 该对象的地址赋给pstock指针</p><p><strong>但无法使用对象来调用构造函数，因为在构造函数构造出对象之 前，对象是不存在的</strong>。因此构造函数被用来创建对象，而不能通过对象来调用。</p><h3 id="10-3-3-默认构造函数"><a href="#10-3-3-默认构造函数" class="headerlink" title="10.3.3 默认构造函数"></a>10.3.3 默认构造函数</h3><p>默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。如果没有提供任何构造函数，则C++将自动提供默认构造函数。它是默认构造函 数的隐式版本，不做任何工作。对于Stock类来说，默认构造函数可能 如下：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock::<span class="built_in">Stock</span>() &#123;&#125;;</span><br></pre></td></tr></table></figure></div><p>当且仅当没有定义任何构造函数时，编译器才会提供默 认构造函数。为类定义了构造函数后，程序员就必须为它提供默认构造 函数。如果提供了非默认构造函数（如Stock(const char * co, int n, double pr)），但没有提供默认构造函数，则下面的声明将出错：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock stock1;   <span class="comment">// 没有合适的构造函数用于构造对象</span></span><br></pre></td></tr></table></figure></div><p>定义默认构造函数的方式有两种。一种是给已有构造函数的所 有参数提供默认值：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stock</span>(<span class="type">const</span> string &amp;co = <span class="string">&quot;Error&quot;</span>, <span class="type">int</span> n=<span class="number">0</span>, <span class="type">double</span> pr=<span class="number">0</span>);</span><br></pre></td></tr></table></figure></div><p>另一种方式是通过函数重载来定义另一个构造函数——一个没有参 数的构造函数：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Stock</span>();</span><br></pre></td></tr></table></figure></div><p>用户定义的默认构造函数通常给所有成员提供隐式初始值。</p><h3 id="10-3-4-析构函数"><a href="#10-3-4-析构函数" class="headerlink" title="10.3.4 析构函数"></a>10.3.4 析构函数</h3><p>用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。 对象过期时，程序将自动调用一个特殊的成员函数，该函数称为析构函数。析构函数很有用，用于对象过期时的完成清理工作。例 如，如果构造函数使用new来分配内存，则析构函数将使用delete来释放 这些内存。Stock的构造函数没有使用new，因此析构函数实际上没有需 要完成的任务。在这种情况下，只需让编译器生成一个什么要不做的隐式析构函数即可。</p><p>析构函数的名称很特殊：在类名前加上<code>~</code>。</p><p>因此，<code>Stock</code> 类的析构函数为 <code>~Stock()</code>。另外，和构造函数一样，<strong>析构函数也可以没有返回值和声明类型。与构造函数不同的是，析构函数没有参数</strong>，因此 <code>Stock</code> 析构函数的原型 <strong>必须</strong> 是这样的：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">Stock</span>();</span><br></pre></td></tr></table></figure></div><p>什么时候应调用析构函数呢？这由编译器决定，通常不应在代码中 显式地调用析构函数。如果创建的是静态存储类对象，则其析构函数将在程序结束 时自动被调用。如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时（该对象是在其中定义 的）自动被调用。如果对象是通过new创建的，则它将驻留在栈内存或 自由存储区中，当使用delete来释放内存时，其析构函数将自动被调 用。最后，程序可以创建临时对象来完成特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。</p><h3 id="10-3-5-改进-Stock-类"><a href="#10-3-5-改进-Stock-类" class="headerlink" title="10.3.5 改进 Stock 类"></a>10.3.5 改进 <code>Stock</code> 类</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usestok1.cpp -- using the Stock class</span></span><br><span class="line"><span class="comment">// compile with stock10.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stock10.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Using constructors to create new objects\n&quot;</span>;</span><br><span class="line">    <span class="function">Stock <span class="title">stock1</span><span class="params">(<span class="string">&quot;NanoSmart&quot;</span>, <span class="number">12</span>, <span class="number">20.0</span>)</span></span>;            <span class="comment">// syntax 1</span></span><br><span class="line">    stock1.<span class="built_in">show</span>();</span><br><span class="line">    Stock stock2 = <span class="built_in">Stock</span> (<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">2</span>, <span class="number">2.0</span>); <span class="comment">// syntax 2</span></span><br><span class="line">    stock2.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Assigning stock1 to stock2:\n&quot;</span>;</span><br><span class="line">    stock2 = stock1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Listing stock1 and stock2:\n&quot;</span>;</span><br><span class="line">    stock1.<span class="built_in">show</span>();</span><br><span class="line">    stock2.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Using a constructor to reset an object\n&quot;</span>;</span><br><span class="line">    stock1 = <span class="built_in">Stock</span>(<span class="string">&quot;Nifty Foods&quot;</span>, <span class="number">10</span>, <span class="number">50.0</span>);    <span class="comment">// temp object</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Revised stock1:\n&quot;</span>;</span><br><span class="line">    stock1.<span class="built_in">show</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Done\n&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// std::cin.get();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>下面的语句表明可以将一个对象赋给同类型的另一个对象：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock2 = stock1;</span><br></pre></td></tr></table></figure></div><p>在默认情况下，<strong>将一个对象赋给同类型的另一个对象时，C++将源对象的每个数据成员的内容复制到目标对象中相应的数据成员中</strong>。</p><p>构造函数不仅仅可用于初始化新对象。例如，该程序的<code>main( )</code> 中包含下面的语句：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stock1 = <span class="built_in">Stock</span>(<span class="string">&quot;Nifty Foods&quot;</span>, <span class="number">10</span>, <span class="number">50.0</span>);</span><br></pre></td></tr></table></figure></div><p>stock1对象已经存在，因此这条语句不是对stock1进行初始化，而 是将新值赋给它。这是通过让构造程序创建一个新的、临时的对象，然后将其内容复制给 <code>stock1</code> 来实现的。临时对象复制完成之后，程序调用析构函数，删除该临时对象。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811230556935.png"                      alt="image-20210811230556935"                ></p><p>输出表明，下面两条语句有根本性的差别：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stock stock2 = <span class="built_in">Stock</span>(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">2</span>, <span class="number">2.0</span>);</span><br><span class="line">stock1 = <span class="built_in">Stock</span>(<span class="string">&quot;Nifty Foods&quot;</span>, <span class="number">10</span>, <span class="number">50.0</span>);</span><br></pre></td></tr></table></figure></div><p><strong>第一条语句是初始化，它创建有指定值的对象，可能会创建临时对象（也可能不会）；第二条语句是赋值。像这样在赋值语句中使用构造函数总会导致在赋值前创建一个临时对象</strong>。</p><blockquote><p>如果既可以通过初始化，也可以通过赋值来设置对象的值，则应采用初始化方式。通常这种 方式的效率更高。</p></blockquote><p>6．<code>const</code> 成员函数</p><p>请看下面的代码片段：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Stock land = <span class="built_in">Stock</span>(<span class="string">&quot;KP&quot;</span>, <span class="number">0</span>, <span class="number">0.0</span>);</span><br><span class="line">land.<span class="built_in">show</span>();</span><br></pre></td></tr></table></figure></div><p>对于当前的C++来说，编译器将拒绝第二行。这是什么原因呢？因为 <code>show()</code> 的代码无法确保调用对象不被修改。</p><p>我们以前通过将函数参数声明为 <code>const</code> 引用或指向 <code>const</code> 的指针来解决这种问题。但这里存在语法问题：<code>show()</code> 方法没有任何参数。相反，它所使用的对象是由方法调用隐式地提供。</p><p>需要一种新的语法来保证函数不会修改调用对象。<strong>C++的解决方法是将 <code>const</code> 关键字放在函数的括号后面</strong>。也就是说，<code>show()</code> 声明应像这样：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="type">const</span></span>;         <span class="comment">// promise not to change invoking object</span></span><br></pre></td></tr></table></figure></div><p>同样，函数定义的开头应像这样：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">stock::show</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong>以这种方式声明和定义的类函数被称为 <code>const</code> 成员函数</strong>，从而确保函数内不会修改调用对象。</p><h3 id="10-3-6-构造函数和析构函数小结"><a href="#10-3-6-构造函数和析构函数小结" class="headerlink" title="10.3.6 构造函数和析构函数小结"></a>10.3.6 构造函数和析构函数小结</h3><p>构造函数是一种特殊的类成员函数，在创建类对象时被调用。构造 函数的名称和类名相同，但通过函数重载，可以创建多个同名的构造函 数，条件是每个函数的特征标（参数列表）都不同。另外，构造函数没 有声明类型。通常，构造函数用于初始化类对象的成员，初始化应与构 造函数的参数列表匹配。</p><p>默认构造函数没有参数，因此如果创建对象时没有进行显式地初始 化，则将调用默认构造函数。如果程序中没有提供任何构造函数，则编 译器会为程序定义一个默认构造函数；否则，必须自己提供默认构造函 数。默认构造函数可以没有任何参数；如果有，则必须给所有参数都提供默认值。</p><p>当对象被删除时，程 序将调用析构函数。每个类都只能有一个析构函数。析构函数没有返回 类型（连 <code>void</code> 都没有），也没有参数，其名称为类名称前加上 <code>~</code>。</p><p>如果构造函数使用了 <code>new</code>，则必须提供使用 <code>delete</code> 的析构函数。</p><h2 id="10-4-this-指针"><a href="#10-4-this-指针" class="headerlink" title="10.4 this 指针"></a>10.4 this 指针</h2><p>有时候类方法可能涉及到两个对象，在这种情况下需要使用 <code>this</code> 指针。</p><p>如何将方法的答案传回给调用程序呢？最直接的方法是让方法返回一个引用，该引用指向股价总值较高的对象。因此，用于比较的类方法 <code>topval</code> 的原型如下：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Stock &amp; <span class="title">topval</span><span class="params">(<span class="type">const</span> Stock &amp;s)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure></div><p>该函数隐式地访问一个对象，而显式地访问另一个对象，并返回其 中一个对象的引用。括号中的<code>const</code> 表明，该函数不会修改被显式地访问的对象；而括号后的 <code>const</code> 表明，该函数不会修改被隐式地访问的对象。 由于该函数返回了两个 <code>const</code> 对象之一的引用，因此返回类型也应为 <code>const</code> 引用。</p><p>比较之后，返回引用时有一个问题需要解决：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811232755584.png"                      alt="image-20210811232755584"                ></p><p>C++解决这种问题的方法是：使用被称为 <code>this</code> 的特殊指针。<code>this</code> 指针指向用来调用成员函数的对象（<code>this</code>被作为隐藏参数传递给方法）。这样，函数调用 <code>stock1.topval(stock2)</code> 将 <code>this</code> 设置为 <code>stock1</code> 对象的地址，使得这个指针可用于 <code>topval()</code> 方法。</p><p>一般来说，所有的类方法都将 <code>this</code> 指针设置为调用它的对象的地址。而 <code>topval()</code> 中的 <code>total_val</code> 只不过是 <code>this-&gt;total_val</code> 的简写。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811233043535.png"                      alt="image-20210811233043535"                ></p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> Stock &amp; <span class="title">Stock::topval</span><span class="params">(<span class="type">const</span> Stock &amp; s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.total_val &gt; total_val)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="10-5-对象数组"><a href="#10-5-对象数组" class="headerlink" title="10.5 对象数组"></a>10.5 对象数组</h2><p>声明对象数组的方法与 声明标准类型数组相同。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stock mystuff[<span class="number">4</span>];</span><br></pre></td></tr></table></figure></div><p>可以用构造函数来初始化数组元素。在这种情况下，必须为每个元 素调用构造函数：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ create an array of initialized objects</span><br><span class="line">    Stock stocks[<span class="number">4</span>] = &#123;</span><br><span class="line">        <span class="built_in">Stock</span>(<span class="string">&quot;NanoSmart&quot;</span>, <span class="number">12</span>, <span class="number">20.0</span>),</span><br><span class="line">        <span class="built_in">Stock</span>(<span class="string">&quot;Boffo Objects&quot;</span>, <span class="number">200</span>, <span class="number">2.0</span>),</span><br><span class="line">        <span class="built_in">Stock</span>(<span class="string">&quot;Monolithic Obelisks&quot;</span>, <span class="number">130</span>, <span class="number">3.25</span>),</span><br><span class="line">        <span class="built_in">Stock</span>(<span class="string">&quot;Fleep Enterprises&quot;</span>, <span class="number">60</span>, <span class="number">6.5</span>)</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></div><p>这里的代码使用标准格式对数组进行初始化：用括号括起的、以逗 号分隔的值列表。其中，每次构造函数调用表示一个值。如果类包含多 个构造函数，则可以对不同的元素使用不同的构造函数。</p><h2 id="10-6-类作用域"><a href="#10-6-类作用域" class="headerlink" title="10.6 类作用域"></a>10.6 类作用域</h2><p>在类中定义的名称（如类数据成员名和类成员函数名）的作用域都 为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可 知的。因此，可以在不同类中使用相同的类成员名而不会引起冲突。</p><p>总之，在类声明或成员函数定义中，可以使用未修饰的成员名称 （未限定的名称），就像<code>sell( )</code> 调用 <code>set_tot()</code> 成员函数时那样。构造函数名称在被调用时，才能被识别，因为它的名称与类名相同。在其他情况下，使用类成员名时，必须根据上下文使用直接成员运算符、间接成员运算符 <code>-&gt;</code> 或作用域解析运算符 <code>::</code>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210811235956703.png"                      alt="image-20210811235956703"                ></p><h3 id="10-6-1-作用域为类的常量"><a href="#10-6-1-作用域为类的常量" class="headerlink" title="10.6.1 作用域为类的常量"></a>10.6.1 作用域为类的常量</h3><p>有时候，使符号常量的作用域为类很有用。例如，类声明可能使用 字面值30来指定数组的长度，由于该常量对于所有对象来说都是相同 的，因此创建一个由所有对象共享的常量是个不错的主意。你以为可以这样：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bakery</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> Months = <span class="number">12</span>;</span><br><span class="line">    <span class="type">double</span> costs[Months];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>但<strong>这是不行的</strong>！！ 因为声明类只是描述了对象的形式，并没有创建对象。</p><p>C++提供了另一种在类中定义常量的方式——使用关键字 <code>static</code>：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bakery</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> Months = <span class="number">12</span>;</span><br><span class="line">    <span class="type">double</span> costs[Months];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="10-6-2-作用域内枚举（C-11）"><a href="#10-6-2-作用域内枚举（C-11）" class="headerlink" title="10.6.2 作用域内枚举（C++11）"></a>10.6.2 作用域内枚举（C++11）</h3><h3 id="10-7-抽象数据类型"><a href="#10-7-抽象数据类型" class="headerlink" title="10.7 抽象数据类型"></a>10.7 抽象数据类型</h3><h3 id="10-8-总结"><a href="#10-8-总结" class="headerlink" title="10.8 总结"></a>10.8 总结</h3><p>面向对象编程强调的是程序如何表示数据。使用OOP方法解决编程问题的第一步是根据它与程序之间的接口来描述数据，从而指定如何使 用数据。然后，设计一个类来实现该接口。</p><p>通常，将类声明分成两部分组成，这两部分通常保存在不同的文件 中。类声明（包括由函数原型表示的方法）应放到头文件中。定义成员 函数的源代码放在方法文件中。这样便将接口描述与实现细节分开了。</p><p><strong>类是用户定义的类型，对象是类的实例</strong>。</p><p>每个对象都存储自己的数据，而共享类方法。</p><p>如果希望成员函数对多个对象进行操作，可以将额外的对象作为参数传递给它。如果方法需要显式地引用调用它的对象，则可以使用 <code>this</code> 指针。<code>this</code> 指针被设置为调用对象的地址，因此<code>*this</code> 是该对象的别名。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十章-对象和类&quot;&gt;&lt;a href=&quot;#第十章-对象和类&quot; class=&quot;headerlink&quot; title=&quot;第十章 对象和类&quot;&gt;&lt;/a&gt;第十章 对象和类&lt;/h1&gt;&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过程性编程和面向对象编程；&lt;/li&gt;
&lt;li&gt;类概</summary>
      
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习</title>
    <link href="http://example.com/2023/01/29/C-Primer-Plus-1/chapter11/"/>
    <id>http://example.com/2023/01/29/C-Primer-Plus-1/chapter11/</id>
    <published>2023-01-29T05:45:15.000Z</published>
    <updated>2023-01-30T10:51:35.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一章-使用类"><a href="#第十一章-使用类" class="headerlink" title="第十一章 使用类"></a>第十一章 使用类</h1><p>本章内容包括：</p><ul><li>运算符重载；</li><li>友元函数；</li><li>重载 <code>&lt;&lt;</code> 运算符，以便用于输出；</li><li>状态成员；</li><li>使用 <code>rand()</code> 生成随机值；</li><li>类的自动转换和强制类型转换；</li><li>类转换函数。</li></ul><p>学习C++的难点之一是需要记住大量的东西，但在拥有丰富的实践 经验之前，根本不可能全部记住这些东西。从这种意义上说，学习 C++ 就像学习功能复杂的字处理程序或电子制表程序一样。任何特性都不可怕，但多数人只掌握了那些经常使用的特性，如查找文本或设置为 斜体等。您可能在那里曾经学过如何生成替换字符或者创建目录，除非经常使用它们，否则这些技能可能根本与日常工作无关。也许，学习本 章知识的最好方法是，在我们自己开发的C++程序中使用其中的新特性。</p><h2 id="11-1-运算符重载"><a href="#11-1-运算符重载" class="headerlink" title="11.1 运算符重载"></a>11.1 运算符重载</h2><p>运算符重载是一种形式的 C++ 多态。<br>运算符 重载将重载的概念扩展到运算符上，允许赋予C++运算符多种含义。实 际上，很多C++（也包括C语言）运算符已经被重载。例如，将 <code>*</code> 运算符用于地址，将得到存储在这个地址中的值；但将它用于两个数字时，得到的将是它们的乘积。C++根据操作数的数目和类型来决定采用哪种操 作。</p><p>重载运算符可使代码看起来更自然。</p><p>要重载运算符，需使用被称为运算符函数的特殊函数形式。运算符函数的格式为：<code>operatorop(argument-list)</code>。</p><p>例如，<code>operator +()</code> 重载 <code>+</code> 运算符，<code>operator *()</code> 重载 <code>*</code> 运算符。<code>op</code> 必须是有效的C++运算符，不能虚构一个新的符号。例如，不能有 <code>operator@()</code> 这样的函数，因为C++中没有 <code>@</code> 运算符。然而，<code>operator</code> 函数可以重载 <code>[]</code> 运算符，因为 <code>[]</code> 是数组索引运算符。</p><h2 id="11-2-计算时间：一个运算符重载示例"><a href="#11-2-计算时间：一个运算符重载示例" class="headerlink" title="11.2 计算时间：一个运算符重载示例"></a>11.2 计算时间：一个运算符重载示例</h2><p>定义一个 <code>Time</code> 类:</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mytime0.h -- Time class before operator overloading</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYTIME0_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYTIME0_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hours;</span><br><span class="line">    <span class="type">int</span> minutes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Time</span>();</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m = <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddMin</span><span class="params">(<span class="type">int</span> m)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddHr</span><span class="params">(<span class="type">int</span> h)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">(<span class="type">int</span> h = <span class="number">0</span>, <span class="type">int</span> m = <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">Time <span class="title">Sum</span><span class="params">(<span class="type">const</span> Time &amp; t)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div><p>该类的定义：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mytime0.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>()</span><br><span class="line">&#123;</span><br><span class="line">    hours = minutes = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time::<span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m )</span><br><span class="line">&#123;</span><br><span class="line">    hours = h;</span><br><span class="line">    minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::AddMin</span><span class="params">(<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    minutes += m;</span><br><span class="line">    hours += minutes / <span class="number">60</span>;</span><br><span class="line">    minutes %= <span class="number">60</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::AddHr</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hours += h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::Reset</span><span class="params">(<span class="type">int</span> h, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    hours = h;</span><br><span class="line">    minutes = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Time <span class="title">Time::Sum</span><span class="params">(<span class="type">const</span> Time &amp; t)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Time sum;</span><br><span class="line">    sum.minutes = minutes + t.minutes;</span><br><span class="line">    sum.hours = hours + t.hours + sum.minutes / <span class="number">60</span>;</span><br><span class="line">    sum.minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::Show</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; hours &lt;&lt; <span class="string">&quot; hours, &quot;</span> &lt;&lt; minutes &lt;&lt; <span class="string">&quot; minutes&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>来看一下 <code>Sum()</code> 函数的代码。注意参数是引用，但返回类型却不是 引用。将参数声明为引用的目的是为了提高效率。如果按值传递 <code>Time</code> 对象，代码的功能将相同，但传递引用，速度将更快，使用的内存将更少。</p><p>然而，返回值不能是引用。因为函数将创建一个新的Time对象 （sum），来表示另外两个Time对象的和。返回对象（如代码所做的那 样）将创建对象的副本，而调用函数可以使用它。然而，如果返回类型 为 <code>Time &amp;</code>，则引用的将是 <code>sum</code> 对象。但由于 <code>sum</code> 对象是局部变量，在函数结束时将被删除，因此引用将指向一个不存在的对象。使用返回类型 <code>Time</code> 意味着程序将在删除 <code>sum</code> 之前构造它的拷贝，调用函数将得到该拷贝。</p><blockquote><p>不要返回指向局部变量或临时对象的引用。函数执行完毕后，局部变量和临时对象将消失， 引用将指向不存在的数据。</p></blockquote><p>但这种 sum 时间的方法看起来很傻。</p><h3 id="11-2-1-添加加法运算符"><a href="#11-2-1-添加加法运算符" class="headerlink" title="11.2.1 添加加法运算符"></a>11.2.1 添加加法运算符</h3><p>将Time类转换为重载的加法运算符很容易，只要将<code>Sum()</code> 的名称改为 <code>operator +()</code> 即可。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mytime1.h -- Time class before operator overloading</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYTIME1_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYTIME1_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hours;</span><br><span class="line">    <span class="type">int</span> minutes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Time</span>();</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m = <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddMin</span><span class="params">(<span class="type">int</span> m)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddHr</span><span class="params">(<span class="type">int</span> h)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">(<span class="type">int</span> h = <span class="number">0</span>, <span class="type">int</span> m = <span class="number">0</span>)</span></span>;</span><br><span class="line">    Time <span class="keyword">operator</span>+ (<span class="type">const</span> Time &amp; t) <span class="type">const</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div><p>类定义中改为：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mytime1.cpp  -- implementing Time methods</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mytime1.h&quot;</span></span></span><br><span class="line">...</span><br><span class="line">Time Time::<span class="keyword">operator</span>+(<span class="type">const</span> Time &amp; t) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Time sum;</span><br><span class="line">    sum.minutes = minutes + t.minutes;</span><br><span class="line">    sum.hours = hours + t.hours + sum.minutes / <span class="number">60</span>;</span><br><span class="line">    sum.minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><p>将该方法命令改为 <code>operator +()</code> 后，就可以使用运算符表示法：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total = coding + fixing;</span><br></pre></td></tr></table></figure></div><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usetime1.cpp -- using the second draft of the Time class</span></span><br><span class="line"><span class="comment">// compile usetime1.cpp and mytime1.cpp together</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mytime1.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line">    Time planning;</span><br><span class="line">    <span class="function">Time <span class="title">coding</span><span class="params">(<span class="number">2</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line">    <span class="function">Time <span class="title">fixing</span><span class="params">(<span class="number">5</span>, <span class="number">55</span>)</span></span>;</span><br><span class="line">    Time total;</span><br><span class="line"></span><br><span class="line">    total = coding + fixing;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;coding + fixing = &quot;</span>;</span><br><span class="line">    total.<span class="built_in">Show</span>();</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h3 id="11-2-2-重载限制"><a href="#11-2-2-重载限制" class="headerlink" title="11.2.2 重载限制"></a>11.2.2 重载限制</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812010750643.png"                      alt="image-20210812010750643"                ></p><p>多数C++运算符（参见表11.1）都可以用这样的方式重载。重载的运算符（有些例外情况）不必是成员函数，但必须至少有一个操作数是 用户定义的类型。下面详细介绍C++对用户定义的运算符重载的限制：</p><ul><li>1．重载后的运算符<strong>必须至少有一个操作数是用户定义的类型</strong>，这将防止用户为标准类型重载运算符；</li><li>2．使用运算符时不能违反运算符原来的句法规则。例如不要将 <code>-</code> 重载为加法运算。同样，不能修改运算符的优先级；</li><li>3．不能创建新运算符。例如，不能定义 <code>operator **()</code> 函数来表示求幂；</li><li>4．不能重载下面的运算符：</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812010658117.png"                      alt="image-20210812010658117"                ></p><ul><li>5．表11.1中的大多数运算符都可以通过成员或非成员函数进行重 载，但下面的运算符只能通过成员函数进行重载。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812010824269.png"                      alt="image-20210812010824269"                ></p><h3 id="11-2-3-其他重载运算符"><a href="#11-2-3-其他重载运算符" class="headerlink" title="11.2.3 其他重载运算符"></a>11.2.3 其他重载运算符</h3><p>还有一些其他的操作对 <code>Time</code> 类来说是有意义的。例如，可能要将两个时间相减或将时间乘以一个因子，这需要重载减法和乘法运算符。这 和重载加法运算符采用的技术相同，即创建 <code>operator –()</code> 和 <code>operator *()</code> 方法。也就是说，将下面的原型添加到类声明中：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span>- (<span class="type">const</span> time &amp; t) <span class="type">const</span>;</span><br><span class="line">Time <span class="keyword">operator</span>* (<span class="type">double</span> n) <span class="type">const</span>;</span><br></pre></td></tr></table></figure></div><p>修改类定义：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mytime2.cpp  -- implementing Time methods</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mytime2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Time Time::<span class="keyword">operator</span>-(<span class="type">const</span> Time &amp; t) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Time diff;</span><br><span class="line">    <span class="type">int</span> tot1, tot2;</span><br><span class="line">    tot1 = t.minutes + <span class="number">60</span> * t.hours;</span><br><span class="line">    tot2 = minutes + <span class="number">60</span> * hours;</span><br><span class="line">    diff.minutes = (tot2 - tot1) % <span class="number">60</span>;</span><br><span class="line">    diff.hours = (tot2 - tot1) / <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Time Time::<span class="keyword">operator</span>*(<span class="type">double</span> mult) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    Time result;</span><br><span class="line">    <span class="type">long</span> totalminutes = hours * mult * <span class="number">60</span> + minutes * mult;</span><br><span class="line">    result.hours = totalminutes / <span class="number">60</span>;</span><br><span class="line">    result.minutes = totalminutes % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div><h2 id="11-3-友元"><a href="#11-3-友元" class="headerlink" title="11.3 友元"></a>11.3 友元</h2><p>通常，公有类方法提 供唯一的访问途径，但是有时候这种限制太严格，以致于不适合特定的 编程问题。在这种情况下，C++提供了另外一种形式的访问权限：友 元。友元有3种：</p><ul><li>友元函数；</li><li>友元类；</li><li>友元成员函数。</li></ul><p>通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。</p><p>需要友元的原因是为了解决这样一个问题：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812011654884.png"                      alt="image-20210812011654884"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812011808963.png"                      alt="image-20210812011808963"                ></p><p>对于非成员重载运算符函数来说，<strong>运算符表达式左边的操作数对应于运算符函数的第一个参数，运算符表达式右边的操作数对应于运算符函数的第二个参数</strong>。而原来的成员函数则按相反的顺序处理操作数，也就是说，double值乘以Time值。</p><p>使用非成员函数可以按所需的顺序获得操作数（先是double，然后 是Time），但引发了一个新问题：<strong>非成员函数不能直接访问类的私有数据，至少常规非成员函数不能访问</strong>。然而，有一类特殊的<em>非成员函数</em>可以访问类的私有成员，它们被称为友元函数。</p><h3 id="11-3-1-创建友元"><a href="#11-3-1-创建友元" class="headerlink" title="11.3.1 创建友元"></a>11.3.1 创建友元</h3><p>创建友元函数的第一步是将其原型放在类声明中，并在原型声明前 加上关键字 <code>friend</code>。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> Time <span class="keyword">operator</span>* (<span class="type">double</span> m, <span class="type">const</span> Time &amp; t);</span><br></pre></td></tr></table></figure></div><p>该原型意味着下面两点：</p><ul><li>虽然 <code>operator *()</code> 函数是在类声明中声明的，但它不是成员函数，因 此不能使用成员运算符来调用；</li><li>虽然 <code>operator *()</code> 函数不是成员函数，但它与成员函数的访问权限相同。</li></ul><p>第二步是编写函数定义。<strong>因为它不是成员函数</strong>，所以不要使用 <code>Time::</code> 限定符。另外，不要在定义中使用关键字 <code>friend</code>，定义应该如下：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span>*(<span class="type">double</span> mult) &#123;</span><br><span class="line">    Time result;</span><br><span class="line">    <span class="type">long</span> totalminutes = hours * mult * <span class="number">60</span> + minutes * mult;</span><br><span class="line">    result.hours = totalminutes / <span class="number">60</span>;</span><br><span class="line">    result.minutes = totalminutes % <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>有了上述声明和定义后，语句：<code>A = 2.75 * B</code> 就被自动转换为 <code>A = operator*(2.75, B)</code>。</p><p>总之，<strong>类的友元函数是非成员函数，但访问权限与成员函数相同</strong>。</p><h3 id="11-3-2-常用的友元：重载-lt-lt-运算符"><a href="#11-3-2-常用的友元：重载-lt-lt-运算符" class="headerlink" title="11.3.2 常用的友元：重载 &lt;&lt; 运算符"></a>11.3.2 常用的友元：重载 <code>&lt;&lt;</code> 运算符</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mytime3.h -- Time class with friends</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYTIME3_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYTIME3_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hours;</span><br><span class="line">    <span class="type">int</span> minutes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Time</span>();</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> h, <span class="type">int</span> m = <span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddMin</span><span class="params">(<span class="type">int</span> m)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">AddHr</span><span class="params">(<span class="type">int</span> h)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Reset</span><span class="params">(<span class="type">int</span> h = <span class="number">0</span>, <span class="type">int</span> m = <span class="number">0</span>)</span></span>;</span><br><span class="line">    Time <span class="keyword">operator</span>+(<span class="type">const</span> Time &amp; t) <span class="type">const</span>;</span><br><span class="line">    Time <span class="keyword">operator</span>-(<span class="type">const</span> Time &amp; t) <span class="type">const</span>;</span><br><span class="line">    Time <span class="keyword">operator</span>*(<span class="type">double</span> n) <span class="type">const</span>;</span><br><span class="line">    <span class="keyword">friend</span> Time <span class="keyword">operator</span>*(<span class="type">double</span> m, <span class="type">const</span> Time &amp; t)</span><br><span class="line">        &#123; <span class="keyword">return</span> t * m; &#125;   <span class="comment">// inline definition</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="type">const</span> Time &amp; t);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div><p>代码中对 <code>friend Time operator*(double m, const Time &amp; t)</code> 的重载定义非常棒，是一个相当聪明的做法！它不是重新写一段代码，而是调用已重载的 <code>Time operator*(double n) const</code> 成员函数。</p><h2 id="11-4-重载运算符：作为成员函数还是非成员函数"><a href="#11-4-重载运算符：作为成员函数还是非成员函数" class="headerlink" title="11.4 重载运算符：作为成员函数还是非成员函数"></a>11.4 重载运算符：作为成员函数还是非成员函数</h2><p>一般来说，非成员函数应是友元函数，这样它才能直接访 问类的私有数据。加法运算符需要两个操作数。对于成员函数版本来说，一个操作数 通过this指针隐式地传递，另一个操作数作为函数参数显式地传递；对 于友元版本来说，两个操作数都作为参数来传递。</p><p>对于某些运算符来说（如前所述），成员函数是唯一合法的选择。在其他情况下，这两种格式没有太大的区别。有时，根据类设计，使用非成员函数版本可能更好（尤其是为类定义类型 转换时）。</p><h2 id="11-5-再谈重载：一个矢量类"><a href="#11-5-再谈重载：一个矢量类" class="headerlink" title="11.5 再谈重载：一个矢量类"></a>11.5 再谈重载：一个矢量类</h2><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// subtract Vector b from a</span></span><br><span class="line">Vector Vector::<span class="keyword">operator</span>-(<span class="type">const</span> Vector &amp; b) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(x - b.x, y - b.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reverse sign of Vector</span></span><br><span class="line">Vector Vector::<span class="keyword">operator</span>-() <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Vector</span>(-x, -y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>operator-( )有两种不同的定义。这是可行的，因为它们的特征标不同（两个矢量相减，或者单个矢量取反）。可以定义−运算符的一元和二元版本，因为C++提供了该运 算符的一元和二元版本。对于只有二元形式的运算符（如除法运算符），只能将其重载为二元运算符。</p><blockquote><p>因为运算符重载是通过函数来实现的，所以只要运算符函数的特征标不同，使用的运算符数 量与相应的内置C++运算符相同，就可以多次重载同一个运算符。</p></blockquote><h2 id="11-6-类的自动转换和强制类型转换"><a href="#11-6-类的自动转换和强制类型转换" class="headerlink" title="11.6 类的自动转换和强制类型转换"></a>11.6 类的自动转换和强制类型转换</h2><h2 id="11-7-总结"><a href="#11-7-总结" class="headerlink" title="11.7 总结"></a>11.7 总结</h2><p>一般来说，访问私有类成员的唯一方法是使用类方法。C++使用友 元函数来避开这种限制。要让函数成为友元，需要在类声明中声明该函 数，并在声明前加上关键字friend。</p><p>C++扩展了对运算符的重载，允许自定义特殊的运算符函数，这种 函数描述了特定的运算符与类之间的关系。运算符函数可以是类成员函数，也可以是友元函数（有一些运算符函数只能是类成员函数）。</p><p>最常见的运算符重载任务之一是定义&lt;&lt;运算符，使之可与cout一起 使用，来显示对象的内容。要让ostream对象成为第一个操作数，需要将 运算符函数定义为友元；要使重新定义的运算符能与其自身拼接，需要 将返回类型声明为 <code>ostream &amp;</code>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812015334769.png"                      alt="image-20210812015334769"                ></p><p>然而，如果类包含这样的方法，它返回需要显示的数据成员的值， 则可以使用这些方法，无需在<code>operator&lt;&lt;()</code>中直接访问这些成员。在这种情况下，函数不必（也不应当）是友元。</p><p>C++允许指定在类和基本类型之间进行转换的方式。首先，任何接 受唯一一个参数的构造函数都可被用作转换函数，将类型与该参数相同 的值转换为类。如果将类型与该参数相同的值赋给对象，则C++将自动调用该构造函数。</p><p>要将类对象转换为其他类型，必须定义转换函数，指出如何进行这种转换。转换函数必须是成员函数。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十一章-使用类&quot;&gt;&lt;a href=&quot;#第十一章-使用类&quot; class=&quot;headerlink&quot; title=&quot;第十一章 使用类&quot;&gt;&lt;/a&gt;第十一章 使用类&lt;/h1&gt;&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运算符重载；&lt;/li&gt;
&lt;li&gt;友元函数；&lt;/li</summary>
      
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++学习</title>
    <link href="http://example.com/2023/01/29/C-Primer-Plus-1/chapter12/"/>
    <id>http://example.com/2023/01/29/C-Primer-Plus-1/chapter12/</id>
    <published>2023-01-29T05:45:15.000Z</published>
    <updated>2023-01-30T10:51:42.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十二章-类和动态内存分配"><a href="#第十二章-类和动态内存分配" class="headerlink" title="第十二章 类和动态内存分配"></a>第十二章 类和动态内存分配</h1><p>本章内容包括：</p><ul><li>对类成员使用动态内存分配；</li><li>隐式和显示复制构造函数；</li><li>隐式和显示重载赋值运算符；</li><li>在构造函数中使用 <code>new</code> 所必须完成的工作；</li><li>使用静态类成员；</li><li>将定位 <code>new</code> 运算符用于对象；</li><li>使用指向对象的指针；</li><li>实现队列抽象数据类型（ADT）。</li></ul><p>对类使用 <code>new</code> 和 <code>delete</code> 将影响构造函数和析构函数的设计以及运算符的重载。</p><h2 id="12-1-动态内存和类"><a href="#12-1-动态内存和类" class="headerlink" title="12.1 动态内存和类"></a>12.1 动态内存和类</h2><h3 id="12-1-1-复习示例和静态类成员"><a href="#12-1-1-复习示例和静态类成员" class="headerlink" title="12.1.1 复习示例和静态类成员"></a>12.1.1 复习示例和静态类成员</h3><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strngbad.h -- flawed string class definition</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STRNGBAD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNGBAD_H_</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringBad</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> * str;                <span class="comment">// pointer to string</span></span><br><span class="line">    <span class="type">int</span> len;                   <span class="comment">// length of string</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num_strings;    <span class="comment">// number of objects</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StringBad</span>(<span class="type">const</span> <span class="type">char</span> * s); <span class="comment">// constructor</span></span><br><span class="line">    <span class="built_in">StringBad</span>();               <span class="comment">// default constructor</span></span><br><span class="line">    ~<span class="built_in">StringBad</span>();              <span class="comment">// destructor</span></span><br><span class="line"><span class="comment">// friend function</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os,</span><br><span class="line">                       <span class="type">const</span> StringBad &amp; st);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>对这个声明，需要注意的有两点。首先，它使用char指针（而不是 char数组）来表示姓名。这意味着类声明没有为字符串本身分配存储空 间，而是在构造函数中使用new来为字符串分配空间。这避免了在类声 明中预先定义字符串的长度。</p><p>其次，将num_strings成员声明为静态存储类。静态类成员有一个特点：无论创建了多少对象，程序都只创建一个静态类变量副本。也就是说，<code>StringBad</code> 类的所有对象共享同一个 <code>num_strings</code>。假设创建了10个 <code>StringBad</code> 对象，将有10个 <code>str</code> 成员和10个 <code>len</code> 成员，但只有一个共享的 <code>num_strings</code> 成员（参见图12.1）。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812100941808.png"                      alt="image-20210812100941808"                ></p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strngbad.cpp -- StringBad class methods</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>                    <span class="comment">// string.h for some</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;strngbad.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// initializing static class member</span></span><br><span class="line"><span class="type">int</span> StringBad::num_strings = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class methods</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// construct StringBad from C string</span></span><br><span class="line">StringBad::<span class="built_in">StringBad</span>(<span class="type">const</span> <span class="type">char</span> * s)</span><br><span class="line">&#123;</span><br><span class="line">    len = std::<span class="built_in">strlen</span>(s);             <span class="comment">// set size</span></span><br><span class="line">    str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];          <span class="comment">// allot storage</span></span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, s);              <span class="comment">// initialize pointer</span></span><br><span class="line">    num_strings++;                    <span class="comment">// set object count</span></span><br><span class="line">    cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot;: \&quot;&quot;</span> &lt;&lt; str</span><br><span class="line">         &lt;&lt; <span class="string">&quot;\&quot; object created\n&quot;</span>;    <span class="comment">// For Your Information</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBad::<span class="built_in">StringBad</span>()                <span class="comment">// default constructor</span></span><br><span class="line">&#123;</span><br><span class="line">    len = <span class="number">4</span>;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">4</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, <span class="string">&quot;C++&quot;</span>);          <span class="comment">// default string</span></span><br><span class="line">    num_strings++;</span><br><span class="line">    cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot;: \&quot;&quot;</span> &lt;&lt; str</span><br><span class="line">         &lt;&lt; <span class="string">&quot;\&quot; default object created\n&quot;</span>;  <span class="comment">// FYI</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBad::~<span class="built_in">StringBad</span>()               <span class="comment">// necessary destructor</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\&quot;&quot;</span> &lt;&lt; str &lt;&lt; <span class="string">&quot;\&quot; object deleted, &quot;</span>;    <span class="comment">// FYI</span></span><br><span class="line">    --num_strings;                    <span class="comment">// required</span></span><br><span class="line">    cout &lt;&lt; num_strings &lt;&lt; <span class="string">&quot; left\n&quot;</span>; <span class="comment">// FYI</span></span><br><span class="line">    <span class="keyword">delete</span> [] str;                    <span class="comment">// required</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::ostream &amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream &amp; os, <span class="type">const</span> StringBad &amp; st)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; st.str;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><code>int StringBad::num_strings = 0;</code> 这条语句将静态成员 <code>num_strings</code> 的值初始化为零。注意：<strong>不能在类声明中初始化静态成员变量，这是因为类声明中只描述如何分配内存，但并不分配内存</strong>。</p><p>可以在类声明之外使用单独的语句来进行初始化，这是因为静态类成员是单独存储的，而不是对象的组成部分。</p><p>另外，初始化是在方法文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果 在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。</p><p>上述代码中，<code>strlen()</code>返回字符串长度，但不包括末尾的空字符，因此构造函数将<code>len</code>加1，使分配的内存能够存储包含空字符的字符串。</p><p>删除对象可以释放对象本身占用的内存，但并不能自动释放属于对象成员的指针指向的内存。因此，必须使用析构函数。在析构函数中使用delete语句可确保对象过期 时，由构造函数使用new分配的内存被释放。</p><blockquote><p>在构造函数中使用 <code>new</code> 来分配内存时，必须在相应的析构函数中使用 <code>delete</code> 来释放内存。如果 使用 <code>new[]</code>（包括中括号）来分配内存，则应使用<code>delete[]</code>（包括中括号）来释放内存。</p></blockquote><p><code>StringBad</code>的第一个版本有许多故意留下的缺陷，是一个很糟糕的类（找到该类的错误之处，甚至可以作为一道困难的编程题），这些缺陷使得输出是不确定的。例如，有些 编译器无法编译它。虽然输出的具体内容有所差别，但基本问题和解决方法（稍后将介绍） 是相同的。</p><p>程序输出结果：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812111740343.png"                      alt="image-20210812111740343"                ></p><p><code>callme2()</code> 按值（而不是按引用）传递 <code>headline2</code>，结果表明这是一个严重的问题。</p><p>首先，将 <code>headline2</code> 作为函数参数来传递从而<strong>导致析构函数被调用</strong>。这是因为函数的参数  <code>sb</code> 是一个临时变量，当函数调用结束后会释放这个临时变量，从而导致析构函数被调用，糟糕的源头在于析构函数中恰巧就释放了字符串。 其次，虽然按值传递可以防止原始参数被修改，但实际上函数已使原始 字符串无法识别，导致显示一些非标准字符（显示的文本取决于内存中 包含的内容）。</p><p>因为自动存储对象被删除的顺序与创建顺序相反，所以最先删除的 3个对象是<code>knots</code>、<code>sailor</code>和<code>sport</code>。删除<code>knots</code>和<code>sailor</code>时是正常的，但在删 除<code>sport</code>时，<code>Dollars</code>变成了<code>Doll8</code>(或其他)。对于<code>sport</code>，程序只使用它来初始化 <code>sailor</code>，但这种操作修改了 <code>sports</code>（这又可以做一道题）。</p><p>具体而言，程序中 <code>Stringbad sailor = sports;</code> 这个语句既不是调用默认构造函数也不是调用参数为 <code>const char*</code> 的构造函数，而是等价于 <code>StringBad sailor=StringBad(sports);</code> ，又因为<code>sports</code>的类型为<code>StringBad</code>，因此与之相应的构造函数原型应该是 <code>StringBad(const String &amp;);</code>，<strong>但这个构造函数在<code>StringBad</code>类中没有显式声明更没有定义。这时当我们使用一个对象来初始化另一个对象时，编译器将自动生成上述构造函数（称为复制构造函数，因为它创建对象的一个副本）</strong>。但自动生成的复制构造函数不知道需要更新静态变量<code>num_string</code>，因此会将计数方案搞乱（这就是复制对象带来的问题）。实际上，这个例子说明的所有问题都是由编译器自动生成的成员函数引起的。</p><p>最后被删除的两个对象（<code>headline2</code>和 <code>headline1</code>）已经无法识别。</p><h3 id="12-1-2-特殊成员函数"><a href="#12-1-2-特殊成员函数" class="headerlink" title="12.1.2 特殊成员函数"></a>12.1.2 特殊成员函数</h3><p><code>StringBad</code>类的问题是由特殊成员函数引起的。这些成员函数是自动定义的，就<code>StringBad</code>而言，这些函数的行为与类设计不符。具体地说， C++自动提供了下面这些成员函数：</p><ul><li>默认构造函数；</li><li>默认析构函数；</li><li>复制构造函数；</li><li>复制预运算符；</li><li>地址运算符。</li></ul><p>更准确地说，编译器将生成上述最后三个函数的定义——如果程序 使用对象的方式要求这样做。例如，如果您将一个对象赋给另一个对 象，编译器将提供赋值运算符的定义。</p><p>结果表明，StringBad类中的问题是由隐式复制构造函数和隐式赋值运算符引起的。</p><p>1．默认构造函数</p><p>默认情况下，编译器将提供一个不接受任何参数，也不执行任何操作 的构造函数（默认的默认构造函数），这是因为创建对象时总是会调用 构造函数。</p><p>如果定义了构造函数，C++将不会定义默认构造函数。</p><p>2．复制构造函数</p><p>复制构造函数用于将一个对象复制到新创建的对象中。也就是说，<strong>它用于初始化过程中（包括按值传递参数），而不是常规的赋值过程</strong>（那赋值的时候怎么办？赋值靠赋值运算符&#x3D;，见12.1.4），原型是：<code>Class_name(const Class_name &amp;)</code>。它接受一个指向类对象的常量引用作为参数。</p><p>对于复制构造函数，需要知道两点：何时调用和有何功能。</p><p>3．何时调用复制构造函数</p><p>新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。 最常见的情况是将新对象显式地初始化为现有的对象。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812120029250.png"                      alt="image-20210812120029250"                ></p><p>其中中间的2种声明可能会使用复制构造函数直接创建metoo和 also，也可能使用复制构造函数生成一个临时对象，然后将临时对象的 内容赋给metoo和also，这取决于具体的实现。最后一种声明使用motto 初始化一个匿名对象，并将新对象的地址赋给pStringBad指针。</p><p><strong>每当程序生成了对象副本时，编译器都将使用复制构造函数</strong>。具体地说，当函数按值传递对象（如程序清单12.3中的 <code>callme2()</code>）或函数返回对象时，都将使用复制构造函数。记住，<strong>按值传递意味着创建原始变量的一个副本</strong>。编译器生成临时对象时，也将使用复制构造函数。</p><p>何时生成临时对象随编译器而异，但无论是哪种编译器，<strong>当按值传递和返回对象时，都将调用复制构造函数</strong>。</p><blockquote><p>由于按值传递对象将调用复制构造函数，因此应该按引用传递对象。这样可以节省调用构造函数的时间以及存储新对象的空间。</p></blockquote><p>4．默认的复制构造函数的功能</p><p>默认的复制构造函数逐个复制非静态成员（成员复制也称为浅复制），复制的是成员的值。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812120710195.png"                      alt="image-20210812120710195"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812120946029.png"                      alt="image-20210812120946029"                ></p><h3 id="12-1-3-回到-Stringbad：复制构造函数的哪里出了问题"><a href="#12-1-3-回到-Stringbad：复制构造函数的哪里出了问题" class="headerlink" title="12.1.3  回到 Stringbad：复制构造函数的哪里出了问题"></a>12.1.3  回到 Stringbad：复制构造函数的哪里出了问题</h3><p>第一个异常，num_string是负值。当<code>callme2()</code>被调用时，复制构造函数被用来初始化 <code>callme2()</code> 的形参，还被用来将对象 <code>sailor</code> 初始化为对象 <code>sports</code>。默认的复 制构造函数不说明其行为，因此它不指出创建过程，也不增加计数器 num_strings的值。但析构函数更新了计数，并且在任何对象过期时都将 被调用，而不管对象是如何被创建的。程序的输出表明，析构函数的调用次数比构造函数的调用次数多2。</p><p>第二个异常之处更微妙，也更危险，其症状之一是字符串内容出现乱码。原因在于隐式复制构造函数是按值进行复制的。例如，对于程序清 单12.3，隐式复制构造函数的功能相当于：<code>sailor.str = sport.str;</code>。这里复制的并不是字符串，而是一个指向字符串的指针。也就是 说，将sailor初始化为sports后，得到的是两个指向同一个字符串的指 针。当operator &lt;&lt;()函数使用指针来显示字符串时，这并不会出现问 题。但当析构函数被调用时，这将引发问题。析构函数StringBad释放str 指针指向的内存，因此释放sailor的效果如下：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812121546201.png"                      alt="image-20210812121546201"                ></p><p><code>sports.str</code>指向的内存已经被 <code>sailor</code> 的析构函数释放，这将导致不确定 的、可能有害的后果。</p><p>1．定义一个显式复制构造函数以解决问题</p><p>解决类设计中这种问题的方法是进行深度复制（deep copy）。也就是说，<strong>复制构造函数应当复制字符串并将副本的地址赋给<code>str</code>成员，而不仅仅是复制字符串地址</strong>。这样每个对象都有自己的字符串，而不是引用 另一个对象的字符串。调用析构函数时都将释放不同的字符串，而不会试图去释放已经被释放的字符串。可以这样编写<code>String</code>的复制构造函数：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> * s)     <span class="comment">// construct String from C string</span></span><br><span class="line">&#123;</span><br><span class="line">    len = std::<span class="built_in">strlen</span>(s);          <span class="comment">// set size</span></span><br><span class="line">    str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];       <span class="comment">// allot storage</span></span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, s);           <span class="comment">// initialize pointer</span></span><br><span class="line">    num_strings++;                 <span class="comment">// set object count</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812121927440.png"                      alt="image-20210812121927440"                ></p><h3 id="12-1-4-Stringbad的其他问题：赋值运算符"><a href="#12-1-4-Stringbad的其他问题：赋值运算符" class="headerlink" title="12.1.4 Stringbad的其他问题：赋值运算符"></a>12.1.4 Stringbad的其他问题：赋值运算符</h3><p>并不是程序清单12.3的所有问题都可以归咎于默认的复制构造函 数，还需要看一看默认的赋值运算符。C++允许类对象赋值，这是通过自动为类重载赋值运算符实现的。这种运算符 的原型如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class_name &amp; Class_name::operator=(const Class_name &amp;);</span><br></pre></td></tr></table></figure></div><p>它接受并返回一个指向类对象的引用。</p><p>1．赋值运算符的功能以及何时使用它</p><p>将已有的对象赋给另一个对象时，将使用重载的赋值运算符。初始化对象时，并不一定会使用赋值运算符，而更可能是调用复制构造函数。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBad metoo = knot; </span><br></pre></td></tr></table></figure></div><p>这里，<code>metoo</code> 是一个新创建的对象，被初始化为 <code>knot</code> 的值，因此使用复制构造函数。然而，正如前面指出的，实现时<strong>也可能分两步来处理这条语句：使用复制构造函数创建一个临时对象，然后通过赋值将临时 对象的值复制到新对象中</strong>。这就是说，初始化总是会调用复制构造函数，而使用 <code>=</code> 运算符时也可能调用赋值运算符。</p><p>与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制，静态成员不受影响。</p><p>2．赋值的问题出在哪里</p><p>程序清单12.3将headline1赋给knot：<code>knot=headline1;</code>。为knot调用析构函数时，正常。为Headline1调用析构函数时，异常。<strong>出现的问题与隐式复制构造函数相同：数据受损。这也是成员复制 的问题，即导致headline1.str和knot.str指向相同的地址</strong>。</p><ol start="3"><li>解决赋值的问题</li></ol><p>解决办法是提供赋 值运算符（进行深度复制）定义，这与复制构造函数相似，但也有 一些差别:</p><ul><li>由于目标对象可能引用了以前分配的数据，所以函数应使用<code>delete []</code> 来释放这些数据；</li><li><strong>函数应当避免将对象赋给自身；否则，给对象重新赋值前，释放内 存操作可能删除对象的内容</strong>；</li><li>函数返回一个指向调用对象的<strong>引用</strong>（注意是引用，不是值也不是指针）。</li></ul><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assign a String to a String</span></span><br><span class="line">String &amp; String::<span class="keyword">operator</span>=(<span class="type">const</span> String &amp; st)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;st)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">delete</span> [] str;</span><br><span class="line">    len = st.len;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="type">char</span>[len + <span class="number">1</span>];</span><br><span class="line">    std::<span class="built_in">strcpy</span>(str, st.str);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>赋值操作并不创建新的对象，因此不需要调整静态数据成员 <code>num_strings</code> 的值。</p><h2 id="12-2-改进后的新String类"><a href="#12-2-改进后的新String类" class="headerlink" title="12.2 改进后的新String类"></a>12.2 改进后的新String类</h2><p>首先，添加前面介绍过的复制构造函数和赋值运算符，使类 能够正确管理类对象使用的内存。其次，由于您已经知道对象何时被创 建和释放，因此可以让类构造函数和析构函数保持沉默，不再在每次被 调用时都显示消息。另外，也不用再监视构造函数的工作情况，因此可以简化默认构造函数，使之创建一个空字符串，而不是“C++”。</p><p>新默认构造函数中：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String::<span class="built_in">String</span>()                   <span class="comment">// default constructor</span></span><br><span class="line">&#123;</span><br><span class="line">    len = <span class="number">4</span>;</span><br><span class="line">    str = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">    str[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;                 <span class="comment">// default string</span></span><br><span class="line">    num_strings++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>为什么代码为 <code>str=new char[1];</code> 而不是 <code>str = new char;</code>，这两个方式相同，但区别在于前者和类析构函数兼容，而后者不兼容。这是析构函数：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String::~<span class="built_in">String</span>()                     <span class="comment">// necessary destructor</span></span><br><span class="line">&#123;</span><br><span class="line">    --num_strings;                    <span class="comment">// required</span></span><br><span class="line">    <span class="keyword">delete</span> [] str;                    <span class="comment">// required</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>对 <code>operator&gt;</code> 的重载很妙啊，直接利用了 <code>operator&lt;</code> 的重载结果：<br><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812163721949.png"                      alt="image-20210812163721949"                ></p><h3 id="12-2-3-使用中括号表示法访问字符"><a href="#12-2-3-使用中括号表示法访问字符" class="headerlink" title="12.2.3 使用中括号表示法访问字符"></a>12.2.3 使用中括号表示法访问字符</h3><p>在C++中，两个中括号组成一个运算符——中括号运算符，可以使 用方法operator 来重载该运算符。通常，二元C++运算符（带两个操作 数）位于两个操作数之间，例如2 +5。但对于中括号运算符，<strong>一个操作数位于第一个中括号的前面，另一个操作数位于两个中括号之间</strong>。例如：<code>city[0]</code> 中，<code>city</code>是第一个操作数，<code>[]</code>是运算符，<code>0</code>是第二个操作数。</p><p>在重载时，C++将区分常量和非常量函数的特征标。</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read-write char access for non-const String</span></span><br><span class="line"><span class="type">char</span> &amp; String::<span class="keyword">operator</span>[](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read-only char access for const String</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> &amp; String::<span class="keyword">operator</span>[](<span class="type">int</span> i) <span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> str[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>有了上述定义后，就可以读&#x2F;写常规String对象了；而对于const String对象，则只能读取其数据。</p><blockquote><p>重载要注意同时考虑对const 和非 const 变量进行。</p></blockquote><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812165647776.png"                      alt="image-20210812165647776"                ></p><p>也可以修改内容：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">means</span><span class="params">(<span class="string">&quot;might&quot;</span>)</span></span>;</span><br><span class="line">means[<span class="number">0</span>] = <span class="string">&#x27;r&#x27;</span>;   <span class="comment">// 这一句相当于 means.str[0] = &#x27;r&#x27;, 但 str 是私有成员，实际是没法在成员函数之外这样使用的。</span></span><br></pre></td></tr></table></figure></div><h3 id="12-2-4-静态类成员函数"><a href="#12-2-4-静态类成员函数" class="headerlink" title="12.2.4 静态类成员函数"></a>12.2.4 静态类成员函数</h3><p>首先，不能通过对象调用静态成员函数；实际上，静态成员函数甚 至不能使用this指针。</p><p>其次，由于静态成员函数不与特定的对象相关联，因此只能使用静 态数据成员。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812170316128.png"                      alt="image-20210812170316128"                ></p><h3 id="12-2-5-进一步重载赋值运算符"><a href="#12-2-5-进一步重载赋值运算符" class="headerlink" title="12.2.5 进一步重载赋值运算符"></a>12.2.5 进一步重载赋值运算符</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812170559987.png"                      alt="image-20210812170559987"                ></p><p>重载&gt;&gt;运算符提供了一种将键盘输入行读入到String对象中的简单 方法。它假定输入的字符数不多于String::CINLIM的字符数，并丢弃多 余的字符。在if条件下，如果由于某种原因（如到达文件尾或<code>get(char *, int)</code> 读取的是一个空行）导致输入失败，istream对象的值将置为 false。</p><h2 id="12-3-在构造函数中使用new时应注意的事项"><a href="#12-3-在构造函数中使用new时应注意的事项" class="headerlink" title="12.3 在构造函数中使用new时应注意的事项"></a>12.3 在构造函数中使用new时应注意的事项</h2><p>使用new初始化对象的指针成员时必须特别小心：</p><ul><li>如果在构造函数中使用new来初始化指针成员，则应在析构函数中 使用delete；</li><li>new和delete必须相互兼容。new对应于delete，new[ ]对应于delete[ ]；</li><li>如果有多个构造函数，则必须以相同的方式使用new，要么都带中 括号，要么都不带。因为只有一个析构函数，所有的构造函数都必 须与它兼容。然而，可以在一个构造函数中使用new初始化指针， 而在另一个构造函数中将指针初始化为空（0或C++11中的 nullptr），这是因为delete（无论是带中括号还是不带中括号）可以用于空指针；</li><li>应定义一个复制构造函数，通过深度复制将一个对象初始化为另一 个对象；</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812183412719.png"                      alt="image-20210812183412719"                ></p><ul><li>应当定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象；</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812183448925.png"                      alt="image-20210812183448925"                ></p><p>具体地说，该方法应完成这些操作：<strong>检查自我赋值的情况，释放成员指针以前指向的内存，复制数据而不仅仅是数据的地址，并返回一个指向调用对象的引用</strong>。</p><h3 id="12-3-1-应该和不应该"><a href="#12-3-1-应该和不应该" class="headerlink" title="12.3.1 应该和不应该"></a>12.3.1 应该和不应该</h3><h3 id="12-3-2-包含类成员的类的逐成员复制"><a href="#12-3-2-包含类成员的类的逐成员复制" class="headerlink" title="12.3.2 包含类成员的类的逐成员复制"></a>12.3.2 包含类成员的类的逐成员复制</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812185109539.png"                      alt="image-20210812185109539"                ></p><p>如果您将一个 Magazine对象复制或赋值给另一个Magazine对象，逐成员复制将使用成 员类型定义的复制构造函数和赋值运算符。也就是说，复制成员title 时，将使用String的复制构造函数，而将成员title赋给另一个Magazine对 象时，将使用String的赋值运算符，依此类推。</p><h2 id="12-4-有关返回对象的说明"><a href="#12-4-有关返回对象的说明" class="headerlink" title="12.4 有关返回对象的说明"></a>12.4 有关返回对象的说明</h2><p>当成员函数或独立的函数返回对象时，有几种返回方式可供选择。 可以<strong>返回指向对象的引用、指向对象的const引用或const对象</strong>。</p><h3 id="12-4-1-返回指向const对象的引用"><a href="#12-4-1-返回指向const对象的引用" class="headerlink" title="12.4.1 返回指向const对象的引用"></a>12.4.1 返回指向const对象的引用</h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812185620612.png"                      alt="image-20210812185620612"                ></p><p>这里有三点需要说明。首先，返回对象将调用复制构造函数，而返回引用不会，所以版本2效率更高。其次，引用指向的对象应该在调用函数执行时存在。第 三，<strong>v1和v2都被声明为const引用，因此返回类型必须为const，这样才匹配</strong>。</p><h3 id="12-4-2-返回指向非const对象的引用"><a href="#12-4-2-返回指向非const对象的引用" class="headerlink" title="12.4.2 返回指向非const对象的引用"></a>12.4.2 返回指向非const对象的引用</h3><p>两种常见的返回非 <code>const</code> 对象情形是，重载赋值运算符以及重载与 <code>cout</code> 一起使用的 <code>&lt;&lt;</code> 运算符。前者这样做旨在提高效率，而后者必须这样做。</p><p>Operator&lt;&lt;()的返回值用于串接输出：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;Good stuff&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; s1 &lt;&lt; <span class="string">&quot; is comming!&quot;</span>;</span><br></pre></td></tr></table></figure></div><p><code>operator&lt;&lt;（cout, s1）</code>的返回值成为一个用于显示字符串“is coming!”的对象。返回类型必须是 <code>ostream &amp;</code>，而不能仅仅是 <code>ostream</code>。<strong>如果使用返回类型<code>ostream</code>，将要求调用<code>ostream</code>类的复制构造 函数，而<code>ostream</code>没有公有的复制构造函数</strong>。</p><h3 id="12-4-3-返回对象"><a href="#12-4-3-返回对象" class="headerlink" title="12.4.3 返回对象"></a>12.4.3 返回对象</h3><p>如果被返回的对象是<strong>被调用函数中的局部变量，则不应按引用方式返回它，因为在被调用函数执行完毕时，局部对象将调用其析构函数</strong>。因此，当控制权回到调用函数时，引用指向的对象将不再存在。<strong>在这种情况下，应返回对象而不是引用</strong>。</p><h3 id="12-4-4-返回-const-对象"><a href="#12-4-4-返回-const-对象" class="headerlink" title="12.4.4 返回 const 对象"></a>12.4.4 返回 <code>const</code> 对象</h3><p>前面的Vector::operator+( )定义有一个奇异的属性，它旨在让您能够 以下面这样的方式使用它：<code>net = force1 + force2;</code>。</p><p>然而，这种定义也允许您这样使用它：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">force1 + force2 = net;</span><br><span class="line">cout &lt;&lt; (force1 + force2 = net).magval() &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div><p>这提出了三个问题。为何编写这样的语句？这些语句为何可行？这 些语句有何功能？<strong>首先，没有要编写这种语句的合理理由，但并非所有代码都是合理的</strong>。</p><p>这种代码之所以可行，是因为复制构造函数将创建一个临时 对象来表示返回值。因此，在前面的代码中，表达式force1 + force2的结 果为一个临时对象。在语句1中，该临时对象被赋给net；在语句2和3 中，net被赋给该临时对象。使用完临时对象后，将把它丢弃。</p><p>总之，如果方法或函数要返回局部对象，则应返回对象，而不是指 向对象的引用。在这种情况下，将使用复制构造函数来生成返回的对 象。如果方法或函数要返回一个没有公有复制构造函数的类（如ostream类）的对象，它必须返回一个指向这种对象的引用。最后，有些方法和 函数（如重载的赋值运算符）可以返回对象，也可以返回指向对象的引 用，在这种情况下，应首选引用，因为其效率更高。</p><h2 id="12-5-使用指向对象的指针"><a href="#12-5-使用指向对象的指针" class="headerlink" title="12.5 使用指向对象的指针"></a>12.5 使用指向对象的指针</h2><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812215628088.png"                      alt="image-20210812215628088"                ></p><h3 id="12-5-1-再谈new和delete"><a href="#12-5-1-再谈new和delete" class="headerlink" title="12.5.1 再谈new和delete"></a>12.5.1 再谈<code>new</code>和<code>delete</code></h3><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812220903934.png"                      alt="image-20210812220903934"                ></p><h3 id="12-5-2-指针和对象小结"><a href="#12-5-2-指针和对象小结" class="headerlink" title="12.5.2 指针和对象小结"></a>12.5.2 指针和对象小结</h3><ul><li>使用常规表示法来声明指向对象的指针；</li><li>可以将指针初始化为指向已有的对象；</li><li>可以使用new来初始化指针，这将创建一个新的对象；</li><li>对类使用new将调用相应的类构造函数来初始化新创建的对象。</li></ul><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812221115586.png"                      alt="image-20210812221115586"                ></p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812221146826.png"                      alt="image-20210812221146826"                ></p><ul><li>可以使用<code>-&gt;</code>运算符通过指针访问类方法；</li><li>可以对对象指针应用解除引用运算符<code>*</code>来获得对象。</li></ul><h3 id="12-5-3-再谈定位new运算符"><a href="#12-5-3-再谈定位new运算符" class="headerlink" title="12.5.3 再谈定位new运算符"></a>12.5.3 再谈定位new运算符</h3><h2 id="12-6-复习各种技术"><a href="#12-6-复习各种技术" class="headerlink" title="12.6 复习各种技术"></a>12.6 复习各种技术</h2><h3 id="12-6-1-重载-lt-lt-运算符"><a href="#12-6-1-重载-lt-lt-运算符" class="headerlink" title="12.6.1 重载&lt;&lt;运算符"></a>12.6.1 重载&lt;&lt;运算符</h3><p>要重新定义 &lt;&lt; 运算符，以便将它和cout一起用来显示对象的内 容，请定义下面的友元运算符函数：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210812221524669.png"                      alt="image-20210812221524669"                ></p><h3 id="12-6-2-转换函数"><a href="#12-6-2-转换函数" class="headerlink" title="12.6.2 转换函数"></a>12.6.2 转换函数</h3><p>要将单个值转换为类类型，需要创建原型如下所示的类构造函数：</p><div class="highlight-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">class_name</span>(type_name value);</span><br></pre></td></tr></table></figure></div><p>要将类转换为其他类型，需要创建原型如下所示的类成员函数：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">operator type_name();</span><br></pre></td></tr></table></figure></div><p>虽然该函数没有声明返回类型，但应返回所需类型的值。</p><p>使用转换函数时要小心。可以在声明构造函数时使用关键字 explicit，以防止它被用于隐式转换。</p><h3 id="12-6-3-其构造函数使用new的类"><a href="#12-6-3-其构造函数使用new的类" class="headerlink" title="12.6.3 其构造函数使用new的类"></a>12.6.3 其构造函数使用new的类</h3><h2 id="12-7-队列模拟"><a href="#12-7-队列模拟" class="headerlink" title="12.7 队列模拟"></a>12.7 队列模拟</h2><p>这里不记录了。</p><p>对于<code>const</code>数据成员，必须在执行到构造函数体之前，即创建对象时进行初始化。C++提供了一种特殊的语法来完成上 述工作，它叫做成员初始化列表（member initializer list）。成员初始化 列表由逗号分隔的初始化列表组成（前面带冒号）。它位于参数列表的 右括号之后、函数体左括号之前。如果数据成员的名称为 <code>mdata</code>，并需 要将它初始化为<code>val</code>，则初始化器为<code>mdata(val)</code>。</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210814205323898.png"                      alt="image-20210814205323898"                ></p><p><strong>只有构造函数可以使用这种初始化列表语法</strong>。如上所示，对于const 类成员，必须使用这种语法。另外，<strong>对于被声明为引用的类成员，也必须使用这种语法</strong>：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210814205737591.png"                      alt="image-20210814205737591"                ></p><p><strong>这是因为引用与const数据类似，只能在被创建时进行初始化</strong>。对于 简单数据成员（例如front和items），使用成员初始化列表和在函数体中 使用赋值没有什么区别。</p><blockquote><p>【注意】：<br>这种格式只能用于构造函数；<br>必须用这种格式来初始化非静态const数据成员；<br>必须用这种格式来初始化引用数据成员。</p></blockquote><p><strong>不能将成员初始化列表语法用于构造函数之外的其他类方法</strong>。</p><p>如果我们不希望复制构造函数被调用，也不允许赋值运算，可以这样做：</p><p><img                       lazyload                     src="/images/loading.svg"                     data-src="https://static.fungenomics.com/images/2021/08/image-20210814214006080.png"                      alt="image-20210814214006080"                ></p><p>这是一种禁用方法的技巧，同时可以作为一种暂时不编写这两个函数的预防措施：与其将来面对无法预料的运行故障，不如得到一个易于跟踪的编译错误，指出这些方法是不可访问的。另外，在定义其对象不允许 被复制的类时，这种方法也很有用。</p><p>还有没有其他影响需要注意呢？当然有。当对象被按值传递（或返 回）时，复制构造函数将被调用。然而，如果遵循优先采用按引用传递 对象的惯例，将不会有任何问题。另外，复制构造函数还被用于创建其 他的临时对象，但Queue定义中并没有导致创建临时对象的操作，例如 重载加法运算符。</p><h2 id="12-8-总结"><a href="#12-8-总结" class="headerlink" title="12.8 总结"></a>12.8 总结</h2><p>本章介绍了定义和使用类的许多重要方面。其中的一些方面是非常 微妙甚至很难理解的概念。</p><p>在类构造函数中使用new，也可能在对象过期 时引发问题。如果对象包含成员指针，同时它指向的内存是由new分配 的，则释放用于保存对象的内存并不会自动释放对象成员指针指向的内 存。因此在类构造函数中使用new类来分配内存时，应在类析构函数中 使用delete来释放分配的内存。这样，当对象过期时，将自动释放其指 针成员指向的内存。</p><p>如果对象包含指向new分配的内存的指针成员，则将一个对象初始 化为另一个对象，或将一个对象赋给另一个对象时，也会出现问题。</p><p>在 默认情况下，C++逐个对成员进行初始化和赋值，这意味着被初始化或 被赋值的对象的成员将与原始对象完全相同。如果原始对象的成员指向 一个数据块，则副本成员将指向同一个数据块。当程序最终删除这两个 对象时，类的析构函数将试图删除同一个内存数据块两次，这将出错。解决方法是：<strong>定义一个特殊的复制构造函数来重新定义初始化，并重载赋值运算符</strong>。</p><p>这样，旧对象和新对象都将引用独立 的、相同的数据，而不会重叠。由于同样的原因，必须定义赋值运算 符。对于每一种情况，最终目的都是执行深度复制，也就是说，复制实际的数据，而不仅仅是复制指向数据的指针。</p><p><strong>C++允许在类中包含结构、类和枚举定义。这些嵌套类型的作用域为整个类</strong>，这意味着它们被局限于类中，不 会与其他地方定义的同名结构、类和枚举发生冲突。</p><p>C++为<strong>类构造函数</strong>提供了一种可用来<strong>初始化数据成员的特殊语法</strong>。 这种语法包括冒号和由逗号分隔的初始化列表，被放在构造函数参数的 右括号后，函数体的左括号之前。每一个初始化器都由被初始化的成员 的名称和包含初始值的括号组成。从概念上来说，这些初始化操作是在 对象创建时进行的，此时函数体中的语句还没有执行。语法如下：</p><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue(int qs): qsize(qs), items(0), front(NULL), rear(NULL) &#123;&#125;</span><br></pre></td></tr></table></figure></div><p>如果数据成员是<strong>非静态const成员或引用，则必须采用这种格式</strong>，但 可将C++11新增的类内初始化用于非静态const成员。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十二章-类和动态内存分配&quot;&gt;&lt;a href=&quot;#第十二章-类和动态内存分配&quot; class=&quot;headerlink&quot; title=&quot;第十二章 类和动态内存分配&quot;&gt;&lt;/a&gt;第十二章 类和动态内存分配&lt;/h1&gt;&lt;p&gt;本章内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对类成员使</summary>
      
    
    
    
    
    <category term="C++" scheme="http://example.com/tags/C/"/>
    
  </entry>
  
</feed>
